{"file_contents":{"app/main.py":{"content":"import os\nimport logging\nfrom pathlib import Path\nfrom fastapi import FastAPI\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.responses import FileResponse\nfrom .config import CONFIG, DB_URL, APP_PORT\nfrom .services.stage_manager import StageManager\nfrom .services.scheduler import JobScheduler\nfrom .services.storage import make_db, Store\nfrom .services.automation import AutomationService\nfrom .services.system_health import SystemHealthService\nfrom .services.events import EventsService\nfrom .services.power_allocator import PowerAllocator\nfrom .services.wavemaker_manager import WavemakerManager\nfrom .services.preset_manager import PresetManager\nfrom .routers import telemetry, control, config_api, automation, arrays, history, wavemakers, presets, hardware, settings\n\nlogger = logging.getLogger(\"uvicorn.error\")\n\n\napp = FastAPI(title=CONFIG['site']['name'])\napp.mount('/ui', StaticFiles(directory='app/web', html=True), name='ui')\n\n\n@app.get('/')\nasync def root():\n    return FileResponse(\n        'app/web/index.html',\n        headers={\n            'Cache-Control': 'no-cache, no-store, must-revalidate',\n            'Pragma': 'no-cache',\n            'Expires': '0'\n        }\n    )\n\n\napp.include_router(telemetry.router, prefix='/api')\napp.include_router(control.router, prefix='/api')\napp.include_router(config_api.router, prefix='/api')\napp.include_router(automation.router, prefix='/api')\napp.include_router(arrays.router, prefix='/api')\napp.include_router(history.router)\napp.include_router(wavemakers.router, prefix='/api')\napp.include_router(presets.router, prefix='/api')\napp.include_router(hardware.router, prefix='/api')\napp.include_router(settings.router)\n\n\n@app.on_event('startup')\nasync def startup():\n    try:\n        logger.info(\"Starting Reef Controller initialization...\")\n        \n        db_path = DB_URL.replace('sqlite:///', '')\n        db_dir = os.path.dirname(db_path)\n        if db_dir and not os.path.exists(db_dir):\n            logger.info(f\"Creating database directory: {db_dir}\")\n            Path(db_dir).mkdir(parents=True, exist_ok=True)\n        \n        logger.info(\"Loading configuration...\")\n        app.state.config = CONFIG\n        \n        logger.info(\"Initializing stage manager...\")\n        app.state.stage_manager = StageManager(CONFIG)\n        app.state.mgr = app.state.stage_manager\n        \n        logger.info(\"Initializing system health service...\")\n        app.state.health = SystemHealthService()\n        \n        logger.info(\"Initializing events service...\")\n        app.state.events = EventsService(max_events=200)\n        \n        logger.info(\"Initializing power allocator...\")\n        app.state.power_allocator = PowerAllocator(CONFIG, app.state.events)\n        \n        logger.info(\"Initializing wavemaker manager...\")\n        app.state.wavemaker_manager = WavemakerManager()\n        \n        logger.info(f\"Initializing database at {DB_URL}...\")\n        engine = make_db(DB_URL)\n        app.state.store = Store(engine)\n        \n        logger.info(\"Initializing preset manager...\")\n        app.state.preset_manager = PresetManager(app.state.store)\n        \n        logger.info(\"Connecting preset manager to wavemaker manager...\")\n        app.state.wavemaker_manager.set_preset_manager(app.state.preset_manager)\n        \n        logger.info(\"Initializing automation service...\")\n        # Get timezone offset from environment (should match browser's detected timezone)\n        user_tz_offset = int(os.getenv('USER_TZ_OFFSET', '0'))\n        logger.info(f\"User timezone offset: {user_tz_offset} minutes (UTC{'+' if user_tz_offset >= 0 else ''}{user_tz_offset//60})\")\n        app.state.automation = AutomationService(\n            store=app.state.store,\n            preset_manager=app.state.preset_manager,\n            timezone_offset_minutes=user_tz_offset\n        )\n        \n        logger.info(\"Creating initial snapshot...\")\n        app.state.latest = app.state.stage_manager.snapshot()\n        \n        logger.info(\"Starting job scheduler...\")\n        scheduler = JobScheduler(\n            app.state.stage_manager,\n            persist_cb=app.state.store.persist,\n            interval_s=CONFIG['telemetry']['sample_interval_ms']/1000,\n            power_allocator=app.state.power_allocator,\n            wavemaker_manager=app.state.wavemaker_manager,\n            automation=app.state.automation\n        )\n        scheduler.start(app)\n        \n        logger.info(\"Initializing hardware control system...\")\n        from .services.hw_devices import registry as hw_registry, DeviceConfig\n        from .services.hw_patterns import pattern_registry, PatternConfig\n        from .hw_scheduler.realtime_loop import start_hw_scheduler, set_led_follow, set_preset_manager\n        from .services.storage import DeviceConfigRow\n        \n        # Load all device configurations from database\n        device_configs = app.state.store.get_all_device_configs()\n        \n        # If no devices in database, create defaults and save them\n        if not device_configs:\n            logger.info(\"No device configurations found, creating defaults...\")\n            default_wm1 = DeviceConfigRow(\n                device_id=\"WM1\",\n                name=\"Wavemaker CH1\",\n                device_type=\"WAVEMAKER\",\n                gpio_pin=18,\n                pwm_freq_hz=200,\n                min_intensity=0.05,\n                max_intensity=1.0,\n                volts_min=0.0,\n                volts_max=0.6\n            )\n            default_led1 = DeviceConfigRow(\n                device_id=\"LED1\",\n                name=\"LED CH1\",\n                device_type=\"LED\",\n                gpio_pin=19,\n                pwm_freq_hz=800,\n                min_intensity=0.0,\n                max_intensity=1.0,\n                volts_min=0.0,\n                volts_max=5.0,\n                follow_device_id=\"WM1\"\n            )\n            app.state.store.create_device_config(default_wm1)\n            app.state.store.create_device_config(default_led1)\n            device_configs = [default_wm1, default_led1]\n            logger.info(\"Created default device configurations\")\n        \n        # Register all devices from database\n        for device in device_configs:\n            device_config = DeviceConfig(\n                name=device.name,\n                gpio_pin=device.gpio_pin,\n                pwm_freq_hz=device.pwm_freq_hz,\n                min_intensity=device.min_intensity,\n                max_intensity=device.max_intensity,\n                volts_min=device.volts_min,\n                volts_max=device.volts_max,\n                gpio_pin_monitor=device.gpio_pin_monitor,\n                channel_name=device.channel_name\n            )\n            \n            if device.device_type == \"WAVEMAKER\":\n                hw_registry.register_wavemaker(device.device_id, device_config)\n                logger.info(f\"Registered wavemaker: {device.device_id} on GPIO{device.gpio_pin}\")\n            elif device.device_type == \"LED\":\n                hw_registry.register_led(device.device_id, device_config)\n                logger.info(f\"Registered LED: {device.device_id} on GPIO{device.gpio_pin}\")\n        \n        # Configure LED following relationships\n        for device in device_configs:\n            if device.device_type == \"LED\" and device.follow_device_id:\n                set_led_follow(device.device_id, device.follow_device_id)\n                logger.info(f\"Configured {device.device_id} to follow {device.follow_device_id}\")\n        \n        # Create default PULSE pattern for WM1 (fallback when no preset active)\n        default_pattern = PatternConfig(\n            mode=\"PULSE\",\n            period_s=6.0,\n            on_ratio=0.5,\n            phase_deg=0.0,\n            min_intensity=0.0,\n            max_intensity=1.0\n        )\n        pattern_registry.create_pattern(\"WM1\", default_pattern)\n        \n        # Link PresetManager to hardware control - presets drive GPIO output\n        set_preset_manager(app.state.preset_manager)\n        \n        # Start hardware scheduler (20Hz real-time loop)\n        start_hw_scheduler()\n        logger.info(f\"Hardware control started ({hw_registry.mode} mode)\")\n        \n        # Auto-resume wavemakers based on current schedule\n        logger.info(\"Auto-resuming wavemakers from schedule...\")\n        app.state.automation.auto_resume_from_schedule()\n        \n        logger.info(\"Reef Controller startup complete!\")\n        \n    except Exception as e:\n        logger.error(f\"Failed to initialize Reef Controller: {e}\", exc_info=True)\n        raise","size_bytes":8527},"app/config.py":{"content":"import os, yaml\nfrom dotenv import load_dotenv\n\n\nload_dotenv()\n\n\nAPP_PORT = int(os.getenv(\"APP_PORT\", \"5000\"))\nDB_URL = os.getenv(\"DB_URL\", \"sqlite:///./reef.db\")\nSENSOR_DRIVER = os.getenv(\"SENSOR_DRIVER\", \"sensors_sim\")\nGPIO_DRIVER = os.getenv(\"GPIO_DRIVER\", \"gpio\")\n\n\nwith open(\"config.yaml\", \"r\") as f:\n    CONFIG = yaml.safe_load(f)","size_bytes":336},"app/services/stage_manager.py":{"content":"from datetime import datetime\nfrom ..models import Telemetry, StageStatus\nfrom ..stages.led_stage import LEDStage\nfrom ..stages.battery_stage import BatteryStage\nfrom ..drivers import sensors_sim\n\n\nclass StageManager:\n    def __init__(self, config):\n        self.config = config\n        self.stages = []\n        self.stage_dict = {}\n        \n        for idx, arr in enumerate(config[\"stages\"][\"arrays\"], start=0):\n            sid = arr['id']\n            stage = LEDStage(sid, sensors_sim.SensorSim(seed=idx, stage_config=arr), config=arr)\n            self.stages.append(stage)\n            self.stage_dict[sid] = stage\n        \n        battery_stage = BatteryStage(\"Battery\", sensors_sim.SensorSim(seed=99))\n        self.stages.append(battery_stage)\n        self.stage_dict[\"Battery\"] = battery_stage\n\n\n    def list_status(self):\n        out = []\n        for st in self.stages:\n            stage_id = st.id if hasattr(st, 'id') else st.stage_id\n            out.append(StageStatus(stage_id=stage_id, enabled=st.enabled, mode=st.mode, duty=st.duty))\n        return out\n\n\n    def control(self, stage_id, mode=None, duty=None, enable=None):\n        st = self.stage_dict.get(stage_id)\n        if not st:\n            return False\n        if mode:\n            st.set_mode(mode)\n        st.apply_control(duty, enable)\n        return True\n\n\n    def snapshot(self):\n        rows = []\n        for st in self.stages:\n            t = st.read_telemetry()\n            stage_id = st.id if hasattr(st, 'id') else st.stage_id\n            rows.append(Telemetry(stage_id=stage_id, ts=datetime.utcnow(), mode=st.mode, **t))\n        return rows\n","size_bytes":1622},"app/models.py":{"content":"from typing import Optional, Literal, List\nfrom datetime import datetime\nfrom pydantic import BaseModel\n\n\nMode = Literal[\"OFF\", \"MANUAL\", \"AUTO\", \"REDUNDANT\"]\n\n\nclass Telemetry(BaseModel):\n    stage_id: str\n    ts: datetime\n    vin_v: float\n    iin_a: float\n    vout_v: float\n    iout_a: float\n    mode: Mode\n\n\nclass ControlRequest(BaseModel):\n    stage_id: str\n    mode: Mode\n    duty: Optional[float] = None\n    enable: Optional[bool] = None\n\n\nclass StageStatus(BaseModel):\n    stage_id: str\n    enabled: bool\n    mode: Mode\n    duty: float\n\n\nclass LED(BaseModel):\n    id: str\n    label: str\n    intensity_limit_pct: int\n    priority: int\n    is_on: bool = True\n    current_intensity_pct: float = 0.0\n\n\nclass ArrayConfig(BaseModel):\n    id: str\n    name: str\n    description: str\n    max_current_a: float\n    nominal_voltage_v: float\n    leds: List[LED]\n\n\nclass ArrayStatus(BaseModel):\n    id: str\n    name: str\n    description: str\n    enabled: bool\n    mode: Mode\n    duty: float\n    leds: List[LED]\n    vin_v: float\n    iin_a: float\n    vout_v: float\n    iout_a: float\n    power_w: float\n\n\nclass LEDSettingsUpdate(BaseModel):\n    label: Optional[str] = None\n    intensity_limit_pct: Optional[int] = None\n    priority: Optional[int] = None\n    is_on: Optional[bool] = None\n\n\nclass ArraySettingsRequest(BaseModel):\n    leds: dict[str, LEDSettingsUpdate]\n\n\nclass SystemLoad(BaseModel):\n    pv_w: float\n    load_w: float\n    battery_w: float\n    net_w: float\n    budget_w: float\n    timestamp: datetime\n\n\nclass PowerEvent(BaseModel):\n    timestamp: datetime\n    event_type: Literal[\"shed\", \"restore\", \"alert\", \"warning\"]\n    array_id: Optional[str] = None\n    led_id: Optional[str] = None\n    message: str\n    details: Optional[dict] = None\n\n\nclass HistoryPoint(BaseModel):\n    t: datetime\n    v: float\n    i: float\n    p: float\n\n\nWavemakerMode = Literal[\"off\", \"constant\", \"pulse\", \"gyre_left\", \"gyre_right\", \"random_reef\"]\n\n\nclass WavemakerChannel(BaseModel):\n    id: int\n    name: str\n    mode: WavemakerMode\n    target_power_pct: int\n    pulse_duty_ratio: float\n    current_power_w: float\n    voltage_v: float\n    current_a: float\n\n\nclass WavemakerControlRequest(BaseModel):\n    mode: Optional[WavemakerMode] = None\n    target_power_pct: Optional[int] = None\n    pulse_duty_ratio: Optional[float] = None\n\n\nclass WavemakerHistoryPoint(BaseModel):\n    t: datetime\n    power_w: float\n    duty_pct: float\n    pulse_duty_ratio: float\n\n\nclass WavemakerPresetResponse(BaseModel):\n    id: int\n    name: str\n    description: str\n    cycle_duration_sec: int\n    is_built_in: bool\n    flow_curves: dict\n\n\nclass WavemakerPresetRequest(BaseModel):\n    name: str\n    description: Optional[str] = \"\"\n    cycle_duration_sec: Optional[int] = 60\n    flow_curves: Optional[dict] = {}\n\n\nclass ScheduledTask(BaseModel):\n    id: Optional[int] = None\n    name: str\n    task_type: Literal[\"preset_activation\", \"feeding\", \"maintenance\"]\n    time: str\n    enabled: bool = True\n    preset_id: Optional[int] = None\n    days_of_week: Optional[List[int]] = None\n\n\nclass ScheduledTaskRequest(BaseModel):\n    name: str\n    task_type: Literal[\"preset_activation\", \"feeding\", \"maintenance\"]\n    time: str\n    enabled: Optional[bool] = True\n    preset_id: Optional[int] = None\n    days_of_week: Optional[List[int]] = None\n","size_bytes":3292},"app/drivers/sensors_sim.py":{"content":"import random\nimport time\nimport math\nfrom datetime import datetime\n\n\nclass SensorSim:\n    def __init__(self, seed=None, stage_config=None):\n        self.rng = random.Random(seed or time.time())\n        self.stage_config = stage_config or {}\n        self.base_vin = 36.0\n        self.base_vout = stage_config.get(\"nominal_voltage_v\", 30.0) if stage_config else 30.0\n        self.max_current = stage_config.get(\"max_current_a\", 2.0) if stage_config else 2.0\n    \n    def read(self, duty=0.0, enabled=True):\n        \"\"\"\n        Simulate realistic sensor readings based on duty cycle and LED configuration\n        duty: 0.0 to 1.0 (0% to 100%)\n        enabled: whether the stage is enabled\n        \"\"\"\n        if not enabled:\n            vin = self.base_vin + self.rng.uniform(-1, 1)\n            iin = self.rng.uniform(0.0, 0.1)\n            vout = self.base_vout + self.rng.uniform(-1, 1)\n            iout = 0.0\n            return vin, iin, vout, iout\n        \n        base_current = duty * self.max_current\n        iout = base_current + self.rng.uniform(-0.05, 0.05)\n        iout = max(0.0, iout)\n        \n        voltage_drop_factor = 1.0 - (duty * 0.08)\n        vout = (self.base_vout * voltage_drop_factor) + self.rng.uniform(-0.3, 0.3)\n        \n        iin = (iout * 1.1) + self.rng.uniform(-0.02, 0.02)\n        iin = max(0.0, iin)\n        \n        vin = self.base_vin + self.rng.uniform(-1.5, 1.5)\n        \n        return vin, iin, vout, iout\n\n\nclass PVSimulator:\n    def __init__(self, max_power_w=600, seed=None):\n        self.max_power_w = max_power_w\n        self.rng = random.Random(seed or time.time())\n        self.base_voltage = 48.0\n    \n    def get_diurnal_factor(self):\n        \"\"\"\n        Returns 0.0 to 1.0 based on time of day (simulates sunrise/sunset)\n        Peak at noon, 0 at night\n        \"\"\"\n        now = datetime.now()\n        hour = now.hour + now.minute / 60.0\n        \n        if hour < 6 or hour > 20:\n            return 0.0\n        elif hour < 8:\n            return (hour - 6) / 2.0\n        elif hour < 18:\n            return 1.0 - 0.2 * abs(13 - hour) / 5.0\n        else:\n            return 1.0 - (hour - 18) / 2.0\n    \n    def read(self):\n        \"\"\"\n        Returns simulated PV panel output\n        \"\"\"\n        diurnal = self.get_diurnal_factor()\n        \n        cloud_factor = self.rng.uniform(0.7, 1.0)\n        \n        power_factor = diurnal * cloud_factor\n        current_power = self.max_power_w * power_factor\n        \n        current = current_power / self.base_voltage if self.base_voltage > 0 else 0.0\n        voltage = self.base_voltage + self.rng.uniform(-2, 2)\n        \n        return voltage, current, voltage, current\n","size_bytes":2668},"config.yaml":{"content":"site:\n  name: \"Reef Controller\"\n  timezone: \"Australia/Brisbane\"\n\n\nstages:\n  arrays:\n    - id: \"A1\"\n      name: \"Acropora (SPS) Lights\"\n      description: \"High-intensity lighting for SPS corals\"\n      enabled: true\n      auto: true\n      pwm_channel: 0\n      max_current_a: 4.0\n      nominal_voltage_v: 36.0\n      timer:\n        on: \"08:00\"\n        off: \"20:30\"\n      leds:\n        - id: \"L1\"\n          label: \"Front Blue\"\n          intensity_limit_pct: 100\n          priority: 1\n        - id: \"L2\"\n          label: \"Front White\"\n          intensity_limit_pct: 100\n          priority: 2\n        - id: \"L3\"\n          label: \"Center Blue\"\n          intensity_limit_pct: 90\n          priority: 3\n        - id: \"L4\"\n          label: \"Center White\"\n          intensity_limit_pct: 90\n          priority: 4\n        - id: \"L5\"\n          label: \"Rear Blue\"\n          intensity_limit_pct: 80\n          priority: 5\n        - id: \"L6\"\n          label: \"Rear White\"\n          intensity_limit_pct: 80\n          priority: 6\n    \n    - id: \"A2\"\n      name: \"LPS Lights\"\n      description: \"Medium-intensity lighting for LPS corals\"\n      enabled: true\n      auto: true\n      pwm_channel: 1\n      max_current_a: 3.0\n      nominal_voltage_v: 32.0\n      timer:\n        on: \"08:15\"\n        off: \"20:45\"\n      leds:\n        - id: \"L1\"\n          label: \"Front Blue\"\n          intensity_limit_pct: 100\n          priority: 1\n        - id: \"L2\"\n          label: \"Front White\"\n          intensity_limit_pct: 85\n          priority: 2\n        - id: \"L3\"\n          label: \"Center Blue\"\n          intensity_limit_pct: 85\n          priority: 3\n        - id: \"L4\"\n          label: \"Center White\"\n          intensity_limit_pct: 75\n          priority: 4\n        - id: \"L5\"\n          label: \"Rear Blue\"\n          intensity_limit_pct: 75\n          priority: 5\n        - id: \"L6\"\n          label: \"Rear White\"\n          intensity_limit_pct: 70\n          priority: 6\n    \n    - id: \"A3\"\n      name: \"Center Lights\"\n      description: \"Ambient lighting for center display\"\n      enabled: true\n      auto: true\n      pwm_channel: 2\n      max_current_a: 2.5\n      nominal_voltage_v: 28.0\n      timer:\n        on: \"08:30\"\n        off: \"21:00\"\n      leds:\n        - id: \"L1\"\n          label: \"Front Actinic\"\n          intensity_limit_pct: 100\n          priority: 1\n        - id: \"L2\"\n          label: \"Front Daylight\"\n          intensity_limit_pct: 90\n          priority: 2\n        - id: \"L3\"\n          label: \"Center Actinic\"\n          intensity_limit_pct: 80\n          priority: 3\n        - id: \"L4\"\n          label: \"Center Daylight\"\n          intensity_limit_pct: 80\n          priority: 4\n        - id: \"L5\"\n          label: \"Rear Actinic\"\n          intensity_limit_pct: 70\n          priority: 5\n        - id: \"L6\"\n          label: \"Rear Daylight\"\n          intensity_limit_pct: 70\n          priority: 6\n  \n  battery:\n    enabled: true\n    charge_limit_v: 14.2\n    float_v: 13.6\n    discharge_cutoff_v: 12.0\n    reserve_minutes: 60\n    max_discharge_w: 150\n    min_charge_surplus_w: 50\n\n\npower_budget:\n  target_watts: 400\n  restore_hysteresis_pct: 10\n  restore_delay_s: 10\n  pv_max_w: 600\n\n\nsimulator:\n  pv_diurnal_enabled: true\n  pv_cloud_variation_pct: 30\n  deterministic_seed: null\n\n\ntelemetry:\n  sample_interval_ms: 1000\n  persist_every_s: 10\n  history_retention_hours: 48\n\n\nalerts:\n  low_battery_v: 12.2\n  high_panel_v: 85.0\n  sensor_stale_s: 10\n  panel_offline_s: 120\n  webhook_url: null\n","size_bytes":3456},"app/stages/led_stage.py":{"content":"from .base import BaseStage\nfrom app.models import LED\n\n\nclass LEDStage(BaseStage):\n    def __init__(self, stage_id: str, sensor, gpio=None, config=None):\n        super().__init__(stage_id, sensor, gpio)\n        self.id = stage_id\n        self.name = config.get(\"name\", stage_id) if config else stage_id\n        self.description = config.get(\"description\", \"\") if config else \"\"\n        self.max_current_a = config.get(\"max_current_a\", 3.0) if config else 3.0\n        self.nominal_voltage_v = config.get(\"nominal_voltage_v\", 36.0) if config else 36.0\n        \n        self.leds = []\n        if config and \"leds\" in config:\n            for led_config in config[\"leds\"]:\n                led = LED(\n                    id=led_config[\"id\"],\n                    label=led_config[\"label\"],\n                    intensity_limit_pct=led_config[\"intensity_limit_pct\"],\n                    priority=led_config[\"priority\"],\n                    is_on=True,\n                    current_intensity_pct=0.0\n                )\n                self.leds.append(led)\n    \n    def apply_control(self, duty: float | None = None, enable: bool | None = None):\n        super().apply_control(duty, enable)\n        \n        for led in self.leds:\n            if led.is_on:\n                led.current_intensity_pct = (led.intensity_limit_pct / 100.0) * self.duty * 100\n","size_bytes":1340},"app/routers/telemetry.py":{"content":"from fastapi import APIRouter\n\n\nrouter = APIRouter()\n\n\n@router.get(\"/health\")\nasync def health():\n    return {\"ok\": True}\n","size_bytes":122},"app/stages/base.py":{"content":"from typing import Literal\nMode = Literal[\"OFF\", \"MANUAL\", \"AUTO\", \"REDUNDANT\"]\n\n\nclass BaseStage:\n    def __init__(self, stage_id: str, sensor, gpio=None):\n        self.stage_id = stage_id\n        self.sensor = sensor\n        self.gpio = gpio\n        self.mode: Mode = \"OFF\"\n        self.enabled = True\n        self.duty = 0.0\n    \n    def read_telemetry(self):\n        # Pass duty and enabled state to sensor for realistic simulation\n        vin, iin, vout, iout = self.sensor.read(self.duty, self.enabled)\n        return dict(vin_v=vin, iin_a=iin, vout_v=vout, iout_a=iout)\n    \n    def apply_control(self, duty: float | None = None, enable: bool | None = None):\n        if duty is not None:\n            self.duty = max(0.0, min(1.0, duty))\n        if enable is not None:\n            self.enabled = bool(enable)\n    \n    def set_mode(self, mode: Mode):\n        self.mode = mode\n    \n    def tick(self, config):\n        pass\n","size_bytes":927},"app/services/scheduler.py":{"content":"from apscheduler.schedulers.asyncio import AsyncIOScheduler\n\n\nclass JobScheduler:\n    def __init__(self, mgr, persist_cb=None, interval_s=1.0, power_allocator=None, wavemaker_manager=None, automation=None):\n        self.mgr = mgr\n        self.persist_cb = persist_cb\n        self.interval_s = interval_s\n        self.power_allocator = power_allocator\n        self.wavemaker_manager = wavemaker_manager\n        self.automation = automation\n        self.sched = AsyncIOScheduler()\n\n\n    def start(self, app):\n        @self.sched.scheduled_job(\"interval\", seconds=self.interval_s)\n        def sample_job():\n            snap = self.mgr.snapshot()\n            \n            if self.power_allocator:\n                arrays_status = []\n                pv_power = 0.0\n                battery_power = 0.0\n                \n                for stage in self.mgr.stages:\n                    if hasattr(stage, 'leds'):\n                        arrays_status.append({\n                            'id': stage.id,\n                            'name': stage.name,\n                            'description': stage.description,\n                            'enabled': stage.enabled,\n                            'mode': stage.mode,\n                            'duty': stage.duty,\n                            'leds': stage.leds,\n                            'max_current_a': stage.max_current_a,\n                            'nominal_voltage_v': stage.nominal_voltage_v,\n                            'vin_v': 0.0,\n                            'iin_a': 0.0,\n                            'vout_v': 0.0,\n                            'iout_a': 0.0,\n                            'power_w': 0.0\n                        })\n                \n                for reading in snap:\n                    if reading.stage_id == 'Battery':\n                        battery_power = reading.vout_v * reading.iout_a\n                        battery_voltage = reading.vout_v\n                    else:\n                        for arr in arrays_status:\n                            if reading.stage_id == arr['id']:\n                                arr['vin_v'] = reading.vin_v\n                                arr['iin_a'] = reading.iin_a\n                                arr['vout_v'] = reading.vout_v\n                                arr['iout_a'] = reading.iout_a\n                                arr['power_w'] = reading.vout_v * reading.iout_a\n                \n                from app.models import ArrayStatus\n                from datetime import datetime\n                import math\n                \n                array_objs = [ArrayStatus(**arr) for arr in arrays_status]\n                \n                now = datetime.now()\n                hour = now.hour + now.minute / 60.0\n                if hour < 6 or hour > 20:\n                    diurnal_factor = 0.0\n                elif hour < 8:\n                    diurnal_factor = (hour - 6) / 2.0\n                elif hour < 18:\n                    diurnal_factor = 1.0 - 0.2 * abs(13 - hour) / 5.0\n                else:\n                    diurnal_factor = 1.0 - (hour - 18) / 2.0\n                \n                max_pv_w = app.state.config.get('power_budget', {}).get('pv_max_w', 600)\n                pv_power = max_pv_w * diurnal_factor\n                \n                max_discharge_w = app.state.config.get('stages', {}).get('battery', {}).get('max_discharge_w', 150)\n                \n                low_battery_v = app.state.config.get('alerts', {}).get('low_battery_v', 12.2)\n                battery_ok = battery_voltage > low_battery_v if 'battery_voltage' in locals() else True\n                battery_available = max_discharge_w if battery_ok else 0\n                \n                shed, restored = self.power_allocator.allocate_power(array_objs, pv_power, battery_available)\n                \n                for array_id, led_id in shed + restored:\n                    stage = self.mgr.stage_dict.get(array_id)\n                    if stage and hasattr(stage, 'leds'):\n                        for led in stage.leds:\n                            if led.id == led_id:\n                                array_obj = next((a for a in array_objs if a.id == array_id), None)\n                                if array_obj:\n                                    led_obj = next((l for l in array_obj.leds if l.id == led_id), None)\n                                    if led_obj:\n                                        led.is_on = led_obj.is_on\n                                        led.current_intensity_pct = led_obj.current_intensity_pct\n                                break\n            \n            if self.persist_cb:\n                self.persist_cb(snap)\n            app.state.latest = snap\n        \n        if self.wavemaker_manager:\n            import time\n            \n            @self.sched.scheduled_job(\"interval\", seconds=0.05)\n            def wavemaker_control_loop():\n                \"\"\"20Hz wavemaker PWM control loop\"\"\"\n                self.wavemaker_manager.update_all(time.time())\n            \n            @self.sched.scheduled_job(\"interval\", seconds=1.0)\n            def wavemaker_telemetry_loop():\n                \"\"\"1Hz wavemaker telemetry sampling\"\"\"\n                self.wavemaker_manager.sample_all_power()\n        \n        if self.automation:\n            @self.sched.scheduled_job(\"interval\", seconds=30)\n            def automation_task_check():\n                \"\"\"30-second interval task execution check\"\"\"\n                self.automation.check_and_execute_tasks()\n            \n            @self.sched.scheduled_job(\"interval\", seconds=1)\n            def feed_mode_timeout_check():\n                \"\"\"1-second interval feed mode timeout check\"\"\"\n                self.automation.check_feed_mode_timeout()\n        \n        self.sched.start()\n","size_bytes":5768},"README.md":{"content":"# Reef Controller - Professional Aquarium Automation System\n\nA sophisticated touch-enabled web application for controlling and monitoring reef aquarium equipment with intelligent power management and beautiful visualizations.\n\n## ðŸŒŠ Features\n\n### Per-LED Array Control\n- **3 LED Arrays**: Acropora (SPS), LPS, and Center Lights\n- **6 Individual LEDs per array** with configurable:\n  - Display names\n  - Intensity limits (0-100%)\n  - Priority levels for power shedding\n- Real-time intensity sliders with live telemetry feedback\n\n### Intelligent Power Management\n- **Automatic LED Shedding**: When power budget is exceeded, LEDs are automatically disabled in priority order (lowest priority first)\n- **Hysteresis-Controlled Restoration**: LEDs restore when surplus power is available for a sustained period (configurable delay)\n- **Event Logging**: All shedding and restoration events are tracked and displayed\n- **Configurable Budget**: Set target watts and restoration parameters in config.yaml\n\n### Touch-Optimized UI (1920Ã—1080)\n- **Weather-App Aesthetic**: Soft gradients, frosted glass cards, professional spacing\n- **Touch Targets**: All interactive elements â‰¥48Ã—48px (primary buttons â‰¥56Ã—56px)\n- **Responsive Layout**: Header with live clock, 3-column array grid, right sidebar\n- **Real-Time Updates**: All data refreshes every 2 seconds\n\n### System Monitoring\n- **Live Telemetry**: Voltage, current, and power for each array\n- **System Load Dashboard**: PV input, total load, battery flow, power budget\n- **System Health**: Color-coded status (green/yellow/red) with detailed alerts\n- **Event Feed**: Recent shed/restore/warning/alert events\n- **Task Scheduling**: View completed and upcoming automation tasks\n\n### Data Visualization\n- **Sparklines**: Mini power graphs on each array card (last 15 minutes)\n- **History Charts**: Click any array to view detailed voltage/current/power history\n- **Load Sparkline**: System-wide PV input visualization\n\n## ðŸš€ Quick Start\n\n### Running Locally\n```bash\n# Install dependencies (automatic on Replit)\n# Start the server\npython -m uvicorn app.main:app --host 0.0.0.0 --port 5000\n```\n\nVisit `http://localhost:5000` in your browser (optimized for 1920Ã—1080 displays).\n\n### Configuration\n\nEdit `config.yaml` to customize:\n\n```yaml\nstages:\n  arrays:\n    - id: \"A1\"\n      name: \"Acropora (SPS) Lights\"\n      max_current_a: 4.0\n      nominal_voltage_v: 36.0\n      leds:\n        - id: \"L1\"\n          label: \"Front Blue\"\n          intensity_limit_pct: 100\n          priority: 1  # Highest priority (shed last)\n\npower_budget:\n  target_watts: 400          # Maximum allowed system load\n  restore_hysteresis_pct: 10 # Require 10% surplus before restore\n  restore_delay_s: 10        # Wait 10s with surplus before restore\n```\n\n## ðŸ§ª Testing Power Shedding\n\n### Method 1: Lower the Power Budget\n1. Edit `config.yaml` and set `power_budget.target_watts: 50`\n2. Restart the application\n3. Set all arrays to 100% intensity\n4. Watch LEDs shed automatically in priority order\n5. Lower array intensity to create surplus\n6. Watch LEDs restore after 10 seconds\n\n### Method 2: Simulate Low PV Input\nThe PV simulator uses time-of-day to generate realistic solar curves:\n- **6 AM - 8 AM**: Sunrise (0% â†’ 100%)\n- **8 AM - 6 PM**: Full sun (100% with cloud variation Â±30%)\n- **6 PM - 8 PM**: Sunset (100% â†’ 0%)\n- **8 PM - 6 AM**: Night (0%)\n\nRun the app during simulated \"night\" hours or modify the simulator's time calculation.\n\n### Method 3: Manual API Testing\n```bash\n# Get current system load\ncurl http://localhost:5000/api/system/load\n\n# Set all arrays to maximum\ncurl -X POST http://localhost:5000/api/control \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"stage_id\": \"A1\", \"mode\": \"MANUAL\", \"duty\": 1.0}'\n\n# Watch events feed\ncurl http://localhost:5000/api/events?limit=20\n```\n\n## ðŸ“± Using the Touch Interface\n\n### Main Controls\n- **Array Intensity Sliders**: Drag to adjust 0-100% duty cycle\n- **Settings Button** (âš™): Click to modify LED names, limits, and priorities\n- **Array Cards**: Click to view detailed power history charts\n\n### LED Indicators\nEach LED shows:\n- **Status Dot**: Green (on) or gray (off)\n- **Current Intensity**: Actual output percentage\n- **Priority Number**: P1-P6 (P1 = highest priority, sheds last)\n\n### Settings Modal\n- Edit LED display names\n- Adjust intensity limits (0-100%)\n- Priority is shown but reordering not yet implemented\n\n### System Monitoring\n- **System Load**: Real-time PV, load, battery, and budget\n- **Upcoming Tasks**: Next scheduled automation events\n- **Completed Tasks**: Recent task history\n- **Recent Events**: Shed/restore/alert timeline\n\n## ðŸ—ï¸ Architecture\n\n### Backend (FastAPI)\n```\napp/\nâ”œâ”€â”€ main.py                    # Application entry point\nâ”œâ”€â”€ config.py                  # Configuration loader\nâ”œâ”€â”€ models.py                  # Pydantic data models\nâ”œâ”€â”€ drivers/\nâ”‚   â””â”€â”€ sensors_sim.py         # Simulated sensors (PV diurnal curve)\nâ”œâ”€â”€ services/\nâ”‚   â”œâ”€â”€ stage_manager.py       # LED array lifecycle\nâ”‚   â”œâ”€â”€ power_allocator.py     # Shedding/restoration logic\nâ”‚   â”œâ”€â”€ events.py              # Event tracking\nâ”‚   â”œâ”€â”€ automation.py          # Task scheduling\nâ”‚   â”œâ”€â”€ system_health.py       # Health monitoring\nâ”‚   â”œâ”€â”€ scheduler.py           # Periodic jobs\nâ”‚   â””â”€â”€ storage.py             # SQLite persistence\nâ”œâ”€â”€ routers/\nâ”‚   â”œâ”€â”€ arrays.py              # New LED array endpoints\nâ”‚   â”œâ”€â”€ automation.py          # Tasks and wave modes\nâ”‚   â”œâ”€â”€ control.py             # Manual control\nâ”‚   â”œâ”€â”€ config_api.py          # Status and snapshot\nâ”‚   â””â”€â”€ telemetry.py           # Health check\nâ””â”€â”€ stages/\n    â”œâ”€â”€ led_stage.py           # LED array implementation\n    â””â”€â”€ battery_stage.py       # Battery management\n```\n\n### Key Services\n\n#### Power Allocator\nImplements intelligent load management:\n- Calculates total load from all arrays\n- Sheds LEDs when load > available power\n- Restores LEDs with hysteresis and delay\n- Logs all events for auditing\n\n#### Events Service\nTracks system events in memory:\n- Shed/restore operations\n- System warnings and alerts\n- Ring buffer (200 events max)\n- Queryable via API\n\n#### PV Simulator\nRealistic solar panel behavior:\n- Diurnal curve (sunrise/sunset)\n- Cloud variation (Â±30%)\n- Time-of-day dependent output\n- Deterministic mode for testing\n\n### API Endpoints\n\n#### Array Management\n- `GET /api/arrays` - List all arrays with LED status\n- `POST /api/arrays/{id}/settings` - Update LED configuration\n- `GET /api/history/array/{id}?range_hours=1` - Array power history\n\n#### System Monitoring\n- `GET /api/system/load` - PV, load, battery, budget\n- `GET /api/system/health` - System status and alerts\n- `GET /api/events?limit=50` - Recent events\n\n#### Legacy Endpoints (Maintained)\n- `GET /api/status` - Stage status\n- `GET /api/snapshot` - Latest telemetry\n- `POST /api/control` - Manual control\n- `GET /api/automation/*` - Tasks and wave modes\n\n## ðŸ”§ Simulation Mode\n\nAll features work in simulation mode without hardware:\n\n### Simulated Behavior\n- **PV Output**: 0-600W based on time of day\n- **Array Current**: Scales with duty cycle (0-100% = 0-max_current_a)\n- **Voltage Droop**: Up to 8% drop at full load\n- **LED Intensity**: Respects individual LED limits\n- **Power Shedding**: Realistic budget enforcement\n\n### Deterministic Testing\nSet `simulator.deterministic_seed` in config.yaml for repeatable tests.\n\n## ðŸŽ¨ Design Philosophy\n\n### Touch-First\n- All controls sized for finger interaction\n- Generous spacing (8-12px gaps)\n- Large touch targets (48Ã—48px minimum)\n- Immediate visual feedback\n\n### Weather-App Aesthetic\n- Soft gradient background\n- Frosted glass cards with subtle shadows\n- Rounded corners (16-20px)\n- Professional color palette\n- Minimal, clean typography\n\n### Performance\n- Vanilla JavaScript (no frameworks)\n- Efficient 2-second polling\n- Lightweight assets\n- Single-page application\n\n## ðŸ“Š Configuration Reference\n\n### Array Settings\n```yaml\nstages:\n  arrays:\n    - id: \"A1\"              # Unique identifier\n      name: \"Display Name\"  # Shown in UI\n      description: \"Info\"   # Card subtitle\n      max_current_a: 4.0    # Maximum current draw\n      nominal_voltage_v: 36 # Nominal output voltage\n      leds: [...]           # 6 LED configurations\n```\n\n### LED Configuration\n```yaml\nleds:\n  - id: \"L1\"                    # L1-L6\n    label: \"Front Blue\"         # Display name\n    intensity_limit_pct: 100    # 0-100% cap\n    priority: 1                 # 1-6 (1=highest)\n```\n\n### Power Budget\n```yaml\npower_budget:\n  target_watts: 400              # Maximum system load\n  restore_hysteresis_pct: 10     # Surplus margin for restore\n  restore_delay_s: 10            # Delay before restore\n  pv_max_w: 600                  # Simulator PV capacity\n```\n\n## ðŸš¢ Deployment\n\nConfigured for Replit autoscale deployment:\n- Stateless design\n- SQLite persistence\n- Environment-based config\n- Port 5000 public access\n\nClick **Deploy** in Replit to publish!\n\n## ðŸ“ Future Enhancements\n\n- [ ] Drag-to-reorder LED priorities in settings\n- [ ] Real hardware integration (INA219, GPIO)\n- [ ] User authentication\n- [ ] Multi-tank support\n- [ ] Mobile responsive design\n- [ ] Advanced scheduling (sunrise/sunset sync)\n- [ ] Historical data export\n- [ ] Custom alert webhooks\n\n## ðŸ¤ Contributing\n\nThis is a demonstration project. For production use, consider:\n- Adding authentication/authorization\n- Implementing database migrations\n- Adding comprehensive testing\n- Hardware safety interlocks\n- Backup power monitoring\n\n## ðŸ“„ License\n\nMIT License - Free for personal and commercial use.\n\n---\n\n**Built with â¤ï¸ for reef aquarium hobbyists**\n","size_bytes":9771},"app/stages/battery_stage.py":{"content":"from .base import BaseStage\n\n\nclass BatteryStage(BaseStage):\n    pass\n","size_bytes":70},"app/services/storage.py":{"content":"from sqlmodel import SQLModel, Field, create_engine, Session, select, Column, JSON\nfrom datetime import datetime\nfrom typing import Optional, List\n\n\nclass TelemetryRow(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    ts: datetime\n    stage_id: str\n    vin_v: float\n    iin_a: float\n    vout_v: float\n    iout_a: float\n    mode: str\n    power_w: float = 0.0\n\n\nclass WavemakerPreset(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    name: str = Field(index=True)\n    description: str = \"\"\n    cycle_duration_sec: int = 60\n    is_built_in: bool = False\n    flow_curves: dict = Field(default={}, sa_column=Column(JSON))\n\n\nclass ScheduledTaskRow(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    name: str\n    task_type: str\n    time: str\n    enabled: bool = True\n    preset_id: Optional[int] = None\n    days_of_week: Optional[str] = None\n\n\nclass DeviceConfigRow(SQLModel, table=True):\n    device_id: str = Field(primary_key=True)\n    name: str\n    device_type: str\n    gpio_pin: int\n    pwm_freq_hz: int\n    min_intensity: float = 0.0\n    max_intensity: float = 1.0\n    volts_min: float = 0.0\n    volts_max: float = 5.0\n    follow_device_id: Optional[str] = None\n    gpio_pin_monitor: Optional[int] = None\n    channel_name: Optional[str] = None\n\n\ndef make_db(db_url: str):\n    engine = create_engine(db_url)\n    SQLModel.metadata.create_all(engine)\n    return engine\n\n\nclass Store:\n    def __init__(self, engine):\n        self.engine = engine\n    \n    def persist(self, rows):\n        with Session(self.engine) as s:\n            for r in rows:\n                data = r.model_dump()\n                if 'power_w' not in data and 'vout_v' in data and 'iout_a' in data:\n                    data['power_w'] = data['vout_v'] * data['iout_a']\n                s.add(TelemetryRow(**data))\n            s.commit()\n    \n    def get_history(self, stage_id: str, since: datetime, limit: int = 1000) -> List[TelemetryRow]:\n        with Session(self.engine) as s:\n            statement = (\n                select(TelemetryRow)\n                .where(TelemetryRow.stage_id == stage_id)\n                .where(TelemetryRow.ts >= since)\n                .order_by(TelemetryRow.ts.desc())\n                .limit(limit)\n            )\n            results = s.exec(statement).all()\n            return list(results)\n    \n    def query_telemetry_range(self, stage_id: str, start: datetime, end: datetime) -> List:\n        with Session(self.engine) as s:\n            statement = (\n                select(TelemetryRow)\n                .where(TelemetryRow.stage_id == stage_id)\n                .where(TelemetryRow.ts >= start)\n                .where(TelemetryRow.ts <= end)\n                .order_by(TelemetryRow.ts.asc())\n            )\n            results = s.exec(statement).all()\n            return [{\"timestamp\": r.ts, \"vout_v\": r.vout_v, \"iout_a\": r.iout_a, \"power_w\": r.power_w} for r in results]\n    \n    def get_all_presets(self) -> List[WavemakerPreset]:\n        with Session(self.engine) as s:\n            statement = select(WavemakerPreset).order_by(WavemakerPreset.name)\n            results = s.exec(statement).all()\n            return list(results)\n    \n    def get_preset(self, preset_id: int) -> Optional[WavemakerPreset]:\n        with Session(self.engine) as s:\n            return s.get(WavemakerPreset, preset_id)\n    \n    def get_preset_by_id(self, preset_id: int) -> Optional[WavemakerPreset]:\n        return self.get_preset(preset_id)\n    \n    def get_preset_by_name(self, name: str) -> Optional[WavemakerPreset]:\n        with Session(self.engine) as s:\n            statement = select(WavemakerPreset).where(WavemakerPreset.name == name)\n            return s.exec(statement).first()\n    \n    def create_preset(self, preset: WavemakerPreset) -> WavemakerPreset:\n        with Session(self.engine) as s:\n            s.add(preset)\n            s.commit()\n            s.refresh(preset)\n            return preset\n    \n    def update_preset(self, preset_id: int, **kwargs) -> Optional[WavemakerPreset]:\n        with Session(self.engine) as s:\n            preset = s.get(WavemakerPreset, preset_id)\n            if not preset:\n                return None\n            for key, value in kwargs.items():\n                if hasattr(preset, key):\n                    setattr(preset, key, value)\n            s.add(preset)\n            s.commit()\n            s.refresh(preset)\n            return preset\n    \n    def delete_preset(self, preset_id: int) -> bool:\n        with Session(self.engine) as s:\n            preset = s.get(WavemakerPreset, preset_id)\n            if not preset or preset.is_built_in:\n                return False\n            s.delete(preset)\n            s.commit()\n            return True\n    \n    def get_all_scheduled_tasks(self) -> List[ScheduledTaskRow]:\n        with Session(self.engine) as s:\n            statement = select(ScheduledTaskRow).order_by(ScheduledTaskRow.time)\n            results = s.exec(statement).all()\n            return list(results)\n    \n    def get_scheduled_task(self, task_id: int) -> Optional[ScheduledTaskRow]:\n        with Session(self.engine) as s:\n            return s.get(ScheduledTaskRow, task_id)\n    \n    def create_scheduled_task(self, task: ScheduledTaskRow) -> ScheduledTaskRow:\n        with Session(self.engine) as s:\n            s.add(task)\n            s.commit()\n            s.refresh(task)\n            return task\n    \n    def update_scheduled_task(self, task_id: int, **kwargs) -> Optional[ScheduledTaskRow]:\n        with Session(self.engine) as s:\n            task = s.get(ScheduledTaskRow, task_id)\n            if not task:\n                return None\n            for key, value in kwargs.items():\n                if hasattr(task, key):\n                    setattr(task, key, value)\n            s.add(task)\n            s.commit()\n            s.refresh(task)\n            return task\n    \n    def delete_scheduled_task(self, task_id: int) -> bool:\n        with Session(self.engine) as s:\n            task = s.get(ScheduledTaskRow, task_id)\n            if not task:\n                return False\n            s.delete(task)\n            s.commit()\n            return True\n    \n    def get_all_device_configs(self) -> List[DeviceConfigRow]:\n        with Session(self.engine) as s:\n            statement = select(DeviceConfigRow).order_by(DeviceConfigRow.device_id)\n            results = s.exec(statement).all()\n            return list(results)\n    \n    def get_device_config(self, device_id: str) -> Optional[DeviceConfigRow]:\n        with Session(self.engine) as s:\n            return s.get(DeviceConfigRow, device_id)\n    \n    def create_device_config(self, device: DeviceConfigRow) -> DeviceConfigRow:\n        with Session(self.engine) as s:\n            s.add(device)\n            s.commit()\n            s.refresh(device)\n            return device\n    \n    def update_device_config(self, device_id: str, **kwargs) -> Optional[DeviceConfigRow]:\n        with Session(self.engine) as s:\n            device = s.get(DeviceConfigRow, device_id)\n            if not device:\n                return None\n            for key, value in kwargs.items():\n                if hasattr(device, key):\n                    setattr(device, key, value)\n            s.add(device)\n            s.commit()\n            s.refresh(device)\n            return device\n    \n    def delete_device_config(self, device_id: str) -> bool:\n        with Session(self.engine) as s:\n            device = s.get(DeviceConfigRow, device_id)\n            if not device:\n                return False\n            s.delete(device)\n            s.commit()\n            return True\n","size_bytes":7677},"app/routers/config_api.py":{"content":"from fastapi import APIRouter, Request\n\n\nrouter = APIRouter()\n\n\n@router.get(\"/status\")\nasync def status(request: Request):\n    mgr = request.app.state.mgr\n    return [s.model_dump() for s in mgr.list_status()]\n\n\n@router.get(\"/snapshot\")\nasync def snapshot(request: Request):\n    return [r.model_dump() for r in request.app.state.latest]\n","size_bytes":337},"app/routers/control.py":{"content":"from fastapi import APIRouter, HTTPException, Request\nfrom ..models import ControlRequest\n\n\nrouter = APIRouter()\n\n\n@router.post(\"/control\")\nasync def control(req: ControlRequest, request: Request):\n    mgr = request.app.state.mgr\n    if req.stage_id not in mgr.stages:\n        raise HTTPException(404, \"stage not found\")\n    mgr.control(req.stage_id, mode=req.mode, duty=req.duty, enable=req.enable)\n    return {\"ok\": True}\n","size_bytes":424},"app/services/power_allocator.py":{"content":"from datetime import datetime, timedelta\nfrom typing import Dict, List, Tuple\nfrom app.models import LED, ArrayStatus\nfrom app.services.events import EventsService\n\n\nclass PowerAllocator:\n    def __init__(self, config: dict, events: EventsService):\n        self.config = config\n        self.events = events\n        self.target_watts = config.get(\"power_budget\", {}).get(\"target_watts\", 400)\n        self.restore_hysteresis_pct = config.get(\"power_budget\", {}).get(\"restore_hysteresis_pct\", 10)\n        self.restore_delay_s = config.get(\"power_budget\", {}).get(\"restore_delay_s\", 10)\n        \n        self.last_shed_time: Dict[Tuple[str, str], datetime] = {}\n        self.surplus_start_time: Dict[Tuple[str, str], datetime] = {}\n    \n    def calculate_load(self, arrays: List[ArrayStatus]) -> float:\n        total_load = 0.0\n        for array in arrays:\n            if array.enabled:\n                total_load += array.power_w\n        return total_load\n    \n    def get_all_leds_sorted_by_priority(self, arrays: List[ArrayStatus]) -> List[Tuple[str, LED]]:\n        all_leds = []\n        for array in arrays:\n            if array.enabled:\n                for led in array.leds:\n                    all_leds.append((array.id, led))\n        \n        all_leds.sort(key=lambda x: x[1].priority, reverse=True)\n        return all_leds\n    \n    def shed_leds(\n        self,\n        arrays: List[ArrayStatus],\n        pv_w: float,\n        battery_w_available: float\n    ) -> List[Tuple[str, str]]:\n        available_power = pv_w + battery_w_available\n        current_load = self.calculate_load(arrays)\n        \n        if current_load <= available_power:\n            return []\n        \n        power_to_reduce = current_load - available_power\n        leds_to_shed = []\n        \n        all_leds = self.get_all_leds_sorted_by_priority(arrays)\n        \n        for array_id, led in all_leds:\n            if not led.is_on:\n                continue\n            \n            array = next(a for a in arrays if a.id == array_id)\n            \n            led_power = (led.current_intensity_pct / 100.0) * (array.power_w / len([l for l in array.leds if l.is_on]))\n            \n            led.is_on = False\n            led.current_intensity_pct = 0.0\n            leds_to_shed.append((array_id, led.id))\n            \n            self.last_shed_time[(array_id, led.id)] = datetime.now()\n            self.events.add_event(\n                event_type=\"shed\",\n                message=f\"Shed {array.name} - {led.label}\",\n                array_id=array_id,\n                led_id=led.id,\n                details={\n                    \"reason\": \"insufficient_power\",\n                    \"available_w\": available_power,\n                    \"load_w\": current_load,\n                    \"led_power_w\": led_power\n                }\n            )\n            \n            power_to_reduce -= led_power\n            \n            if power_to_reduce <= 0:\n                break\n        \n        return leds_to_shed\n    \n    def restore_leds(\n        self,\n        arrays: List[ArrayStatus],\n        pv_w: float,\n        battery_w_available: float\n    ) -> List[Tuple[str, str]]:\n        available_power = pv_w + battery_w_available\n        current_load = self.calculate_load(arrays)\n        \n        surplus = available_power - current_load\n        required_surplus = available_power * (self.restore_hysteresis_pct / 100.0)\n        \n        if surplus <= required_surplus:\n            self.surplus_start_time.clear()\n            return []\n        \n        leds_to_restore = []\n        \n        all_leds = self.get_all_leds_sorted_by_priority(arrays)\n        all_leds.reverse()\n        \n        now = datetime.now()\n        \n        for array_id, led in all_leds:\n            if led.is_on:\n                continue\n            \n            key = (array_id, led.id)\n            \n            if key not in self.surplus_start_time:\n                self.surplus_start_time[key] = now\n                continue\n            \n            if (now - self.surplus_start_time[key]).total_seconds() < self.restore_delay_s:\n                continue\n            \n            array = next(a for a in arrays if a.id == array_id)\n            \n            estimated_power = (led.intensity_limit_pct / 100.0) * array.duty * (array.max_current_a * array.nominal_voltage_v / len(array.leds))\n            \n            if estimated_power > surplus:\n                continue\n            \n            led.is_on = True\n            led.current_intensity_pct = led.intensity_limit_pct * array.duty\n            leds_to_restore.append((array_id, led.id))\n            \n            self.events.add_event(\n                event_type=\"restore\",\n                message=f\"Restored {array.name} - {led.label}\",\n                array_id=array_id,\n                led_id=led.id,\n                details={\n                    \"available_w\": available_power,\n                    \"load_w\": current_load,\n                    \"surplus_w\": surplus,\n                    \"estimated_led_power_w\": estimated_power\n                }\n            )\n            \n            surplus -= estimated_power\n            self.surplus_start_time.pop(key, None)\n        \n        return leds_to_restore\n    \n    def allocate_power(\n        self,\n        arrays: List[ArrayStatus],\n        pv_w: float,\n        battery_w_available: float\n    ) -> Tuple[List[Tuple[str, str]], List[Tuple[str, str]]]:\n        shed = self.shed_leds(arrays, pv_w, battery_w_available)\n        restored = self.restore_leds(arrays, pv_w, battery_w_available)\n        \n        return (shed, restored)\n","size_bytes":5575},"app/services/system_health.py":{"content":"from typing import List, Dict\nimport random\n\n\nclass SystemHealthService:\n    def __init__(self):\n        self.warnings = []\n        self.errors = []\n        self.last_check = None\n    \n    def check_health(self, stages_data) -> Dict:\n        \"\"\"Check system health based on current stage data\"\"\"\n        self.warnings = []\n        self.errors = []\n        \n        # Check battery voltage\n        for stage in stages_data:\n            if stage.get(\"stage_id\") == \"Battery\":\n                vout = stage.get(\"vout_v\", 0)\n                if vout < 12.2:\n                    self.errors.append(\"Battery critically low - charging required\")\n                elif vout < 13.0:\n                    self.warnings.append(\"Battery voltage below optimal\")\n        \n        # Check LED arrays\n        for stage in stages_data:\n            if \"Array\" in stage.get(\"stage_id\", \"\"):\n                vin = stage.get(\"vin_v\", 0)\n                if vin > 80:\n                    self.warnings.append(f\"{stage['stage_id']}: Panel voltage high\")\n                elif vin < 20:\n                    self.errors.append(f\"{stage['stage_id']}: Panel offline or disconnected\")\n        \n        # Simulate occasional warnings\n        if random.random() < 0.1:\n            self.warnings.append(\"Temperature sensor reading slightly elevated\")\n        \n        # Determine overall status\n        if self.errors:\n            status = \"error\"\n            color = \"#ff4444\"\n        elif self.warnings:\n            status = \"warning\"\n            color = \"#ffaa00\"\n        else:\n            status = \"ok\"\n            color = \"#44ff44\"\n        \n        return {\n            \"status\": status,\n            \"color\": color,\n            \"errors\": self.errors,\n            \"warnings\": self.warnings,\n            \"info\": [] if (self.errors or self.warnings) else [\"All systems nominal\"]\n        }\n","size_bytes":1854},"app/services/events.py":{"content":"from datetime import datetime\nfrom collections import deque\nfrom typing import List, Literal, Optional\nfrom app.models import PowerEvent\n\n\nclass EventsService:\n    def __init__(self, max_events: int = 100):\n        self.events: deque = deque(maxlen=max_events)\n    \n    def add_event(\n        self,\n        event_type: Literal[\"shed\", \"restore\", \"alert\", \"warning\"],\n        message: str,\n        array_id: Optional[str] = None,\n        led_id: Optional[str] = None,\n        details: Optional[dict] = None\n    ):\n        event = PowerEvent(\n            timestamp=datetime.now(),\n            event_type=event_type,\n            array_id=array_id,\n            led_id=led_id,\n            message=message,\n            details=details or {}\n        )\n        self.events.appendleft(event)\n        return event\n    \n    def get_recent_events(self, limit: int = 50) -> List[PowerEvent]:\n        return list(self.events)[:limit]\n    \n    def clear(self):\n        self.events.clear()\n","size_bytes":974},"app/routers/automation.py":{"content":"from fastapi import APIRouter, Request, HTTPException\nfrom pydantic import BaseModel\nfrom app.models import ScheduledTask, ScheduledTaskRequest\nfrom app.services.storage import ScheduledTaskRow\nimport json\n\n\nrouter = APIRouter()\n\n\nclass WaveModeRequest(BaseModel):\n    mode: str\n\n\n@router.get(\"/automation/tasks/completed\")\nasync def get_completed_tasks(request: Request):\n    automation = request.app.state.automation\n    return automation.get_completed_tasks()\n\n\n@router.get(\"/automation/tasks/upcoming\")\nasync def get_upcoming_tasks(request: Request, tz_offset: int = 0):\n    \"\"\"Get upcoming tasks with timezone support.\n    \n    Args:\n        tz_offset: User's timezone offset from UTC in minutes (e.g., +660 for AEDT/UTC+11)\n    \"\"\"\n    automation = request.app.state.automation\n    return automation.get_upcoming_tasks(user_tz_offset_minutes=tz_offset)\n\n\n@router.get(\"/automation/wave-modes\")\nasync def get_wave_modes(request: Request):\n    automation = request.app.state.automation\n    return {\n        \"modes\": automation.get_wave_modes(),\n        \"current\": automation.get_current_wave_mode()\n    }\n\n\n@router.post(\"/automation/wave-modes\")\nasync def set_wave_mode(req: WaveModeRequest, request: Request):\n    automation = request.app.state.automation\n    success = automation.set_wave_mode(req.mode)\n    return {\"success\": success, \"mode\": req.mode if success else automation.get_current_wave_mode()}\n\n\n@router.get(\"/system/health\")\nasync def get_system_health(request: Request):\n    health = request.app.state.health\n    latest_data = [r.model_dump() for r in request.app.state.latest]\n    return health.check_health(latest_data)\n\n\n@router.get(\"/automation/scheduled\")\nasync def get_all_scheduled_tasks(request: Request):\n    store = request.app.state.store\n    tasks = store.get_all_scheduled_tasks()\n    return [\n        ScheduledTask(\n            id=t.id,\n            name=t.name,\n            task_type=t.task_type,\n            time=t.time,\n            enabled=t.enabled,\n            preset_id=t.preset_id,\n            days_of_week=json.loads(t.days_of_week) if t.days_of_week else None\n        )\n        for t in tasks\n    ]\n\n\ndef check_schedule_conflict(store, time: str, days_of_week, task_type: str, exclude_task_id=None):\n    \"\"\"Check if a scheduled task conflicts with existing tasks at the same time.\n    Only checks for conflicts between tasks of the same type (e.g., preset_activation vs preset_activation).\n    This allows different task types (presets, feeding, pumps) to be scheduled at the same time.\"\"\"\n    all_tasks = store.get_all_scheduled_tasks()\n    \n    for task in all_tasks:\n        if task.id == exclude_task_id:\n            continue\n        if not task.enabled:\n            continue\n        if task.time != time:\n            continue\n        \n        if task_type == 'preset_activation' and task.task_type == 'preset_activation':\n            task_days = json.loads(task.days_of_week) if task.days_of_week else []\n            new_days = days_of_week or []\n            \n            if len(task_days) == 0 and len(new_days) == 0:\n                return task\n            if len(task_days) == 0 or len(new_days) == 0:\n                return task\n            \n            if any(day in new_days for day in task_days):\n                return task\n    \n    return None\n\n\n@router.post(\"/automation/scheduled\")\nasync def create_scheduled_task(task_req: ScheduledTaskRequest, request: Request):\n    store = request.app.state.store\n    \n    if task_req.enabled:\n        conflict = check_schedule_conflict(store, task_req.time, task_req.days_of_week, task_req.task_type)\n        if conflict:\n            day_text = \"on selected days\" if task_req.days_of_week else \"every day\"\n            raise HTTPException(\n                status_code=409,\n                detail=f'Scheduling conflict: \"{conflict.name}\" already scheduled at {task_req.time} {day_text}'\n            )\n    \n    task_row = ScheduledTaskRow(\n        name=task_req.name,\n        task_type=task_req.task_type,\n        time=task_req.time,\n        enabled=task_req.enabled,\n        preset_id=task_req.preset_id,\n        days_of_week=json.dumps(task_req.days_of_week) if task_req.days_of_week else None\n    )\n    created = store.create_scheduled_task(task_row)\n    return ScheduledTask(\n        id=created.id,\n        name=created.name,\n        task_type=created.task_type,\n        time=created.time,\n        enabled=created.enabled,\n        preset_id=created.preset_id,\n        days_of_week=json.loads(created.days_of_week) if created.days_of_week else None\n    )\n\n\n@router.put(\"/automation/scheduled/{task_id}\")\nasync def update_scheduled_task(task_id: int, task_req: ScheduledTaskRequest, request: Request):\n    store = request.app.state.store\n    \n    if task_req.enabled:\n        conflict = check_schedule_conflict(store, task_req.time, task_req.days_of_week, task_req.task_type, exclude_task_id=task_id)\n        if conflict:\n            day_text = \"on selected days\" if task_req.days_of_week else \"every day\"\n            raise HTTPException(\n                status_code=409,\n                detail=f'Scheduling conflict: \"{conflict.name}\" already scheduled at {task_req.time} {day_text}'\n            )\n    \n    update_data = {\n        \"name\": task_req.name,\n        \"task_type\": task_req.task_type,\n        \"time\": task_req.time,\n        \"enabled\": task_req.enabled,\n        \"preset_id\": task_req.preset_id,\n        \"days_of_week\": json.dumps(task_req.days_of_week) if task_req.days_of_week else None\n    }\n    updated = store.update_scheduled_task(task_id, **update_data)\n    if not updated:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    return ScheduledTask(\n        id=updated.id,\n        name=updated.name,\n        task_type=updated.task_type,\n        time=updated.time,\n        enabled=updated.enabled,\n        preset_id=updated.preset_id,\n        days_of_week=json.loads(updated.days_of_week) if updated.days_of_week else None\n    )\n\n\n@router.delete(\"/automation/scheduled/{task_id}\")\nasync def delete_scheduled_task(task_id: int, request: Request):\n    store = request.app.state.store\n    success = store.delete_scheduled_task(task_id)\n    if not success:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    return {\"success\": True}\n\n\n@router.post(\"/feed/start\")\nasync def start_feed_mode(request: Request):\n    automation = request.app.state.automation\n    result = automation.start_feed_mode()\n    if not result.get(\"success\"):\n        raise HTTPException(status_code=400, detail=result.get(\"message\", \"Failed to start feed mode\"))\n    return result\n\n\n@router.get(\"/feed/status\")\nasync def get_feed_status(request: Request):\n    automation = request.app.state.automation\n    return automation.get_feed_mode_status()\n\n\n@router.post(\"/feed/stop\")\nasync def stop_feed_mode(request: Request):\n    automation = request.app.state.automation\n    result = automation.stop_feed_mode()\n    if not result.get(\"success\"):\n        raise HTTPException(status_code=400, detail=result.get(\"message\", \"Failed to stop feed mode\"))\n    return result\n","size_bytes":7080},"replit.md":{"content":"# Reef Controller\n\n## Overview\nReef Controller is a sophisticated web-based application built with FastAPI, designed for real-time monitoring and control of reef aquarium equipment.\n\n## Recent Changes\n- **v2.2.5** (2025-11-25): Theme text refinements and config import fix - Light theme text changed from pure black (#1a1a2e) to softer dark violet (#3d3d5c) for better readability. Dark theme text boxes/dropdowns changed from near-black to mauve (rgba 70,60,90) for consistency. Config import now performs \"clean slate\" - clears ALL existing devices before loading new config to prevent GPIO conflicts.\n- **v2.2.4** (2025-11-25): Final theme polish - Updated logs viewer, settings tabs, preset editor canvas grids, and calendar to use theme-aware colors. All UI elements now consistently use CSS variables for both Light and Dark themes.\n- **v2.2.3** (2025-11-25): Light theme readability fixes - Title/clock glow now uses white for light theme, graph/chart labels use dark text (#1a1a2e), wavemaker flow patterns use violet lines (#7c3aed) instead of white. Added theme-aware CSS variables for canvas rendering (--canvas-text, --canvas-grid, --canvas-line, --glow-color).\n- **v2.2.2** (2025-11-25): Header readability fix - Title and clock now use brighter colors (#4fc3f7 cyan, #9575cd violet, #f06292 magenta gradient) with stronger glow effects for better visibility. Background now scrolls with page content (position: absolute instead of fixed).\n- **v2.2.1** (2025-11-25): Color refinement - Reduced saturation of primary neon colors by ~20% (cyan #5cb8e2, violet #8a5fd6, magenta #d76fa1) for better blending with background. Dark Theme now uses grey overlay (rgba 51,51,51,0.28 for cards, 0.20 for inner) instead of pure black for more natural look.\n- **v2.2.0** (2025-11-25): Theme system with Light/Dark modes - Background now scrolls with page (full width, no fixed), removed ALL backdrop blur from cards for clearer background visibility. Light Theme uses very subtle white overlay (rgba 255,255,255,0.03 for cards, 0.02 for inner elements), Dark Theme uses subtle dark overlay (rgba 0,0,0,0.25 for cards, 0.15 for inner elements). Theme persists in localStorage. Settings page has theme selector dropdown.\n- **v2.1.0** (2025-11-25): Static background and UX polish - Replaced animated gradient with generated deep-ocean bioluminescent background image (coral silhouettes, glowing particles), removed ALL hover transform animations (no more flash/shimmer/bounce effects), UI is now completely static on mouseover except for color/shadow changes. Improves performance and visual stability.\n- **v2.0.0** (2025-11-25): MAJOR VISUAL OVERHAUL - Transformed from monochrome to vibrant neon dashboard with aurora gradient background (#0b1026â†’#1a1446â†’#35105f), neon color palette (cyan #38bdf8, violet #7c3aed, magenta #ec4899), glowing interactive elements with text-shadow effects, gradient rainbow sliders (violetâ†’cyanâ†’magenta), enhanced glassmorphism cards with gradient borders, glow/bloom effects on all controls, radial lighting overlays, and comprehensive theming matching modern dashboard aesthetics. Fixed white-text readability on modal/table backgrounds.\n- **v1.8.2** (2025-11-25): Added GPIO conflict detection for config import - rejects imports with duplicate GPIO assignments before any changes are made, preventing hardware conflicts. Also added registry-level guards to prevent registering devices on already-claimed GPIO pins.\n- **v1.8.1** (2025-11-25): Fixed config import hot-reload bug - imported device configurations now immediately apply to hardware registry without requiring restart. This resolves LED jitter issues when importing configs with different GPIO mappings.\n\nIts primary purpose is to manage LED lighting arrays, battery backup systems, and wave pumps through an intuitive web interface. The project aims to provide comprehensive control over an aquarium environment, featuring real-time telemetry, interactive controls, and intelligent power management capabilities. Key ambitions include offering production-ready wave pump control with various patterns, granular per-LED control with intelligent power shedding, and a touch-optimized user interface for easy interaction.\n\n## User Preferences\nNone specified yet.\n\n## System Architecture\nThe Reef Controller is built upon a FastAPI backend and a vanilla JavaScript frontend, emphasizing a touch-optimized user experience.\n\n### UI/UX Decisions\n- **Touch-Optimized Interface**: Designed for 1920x1080 displays with large touch targets and \"weather-app\" styling with ocean gradient backgrounds and clean card layouts.\n- **Real-time Updates**: UI polls backend every 2 seconds for synchronized telemetry and control states.\n- **Navigation Menu**: Hamburger menu in header provides access to Dashboard, Logs, and Hardware Settings pages with smooth page transitions.\n- **Interactive Modals**: Full-screen modals for settings, history, and a dedicated Schedule Calendar (95vwÃ—90vh) with weekly grid display.\n- **Visual Feedback**: Disabled LEDs are gray, array cards show intensity limits, and disabled scheduled tasks are grayed out.\n- **Chart Modals**: History and power charts use 90% viewport width.\n- **Preset Editor**: Full-screen modal with sidebar, Canvas-based graphical curve editor for 12 wavemakers, and interactive keyframe manipulation.\n- **Scheduler Calendar View**: Weekly grid (24 hours x 7 days) with visual task placement, clickable cells for new tasks, and clickable task badges for editing.\n- **Toast Notifications**: Non-blocking success/error/info toasts replace `alert()` calls.\n- **Clean Interactions**: Removed button hover bounce effects. Feed Mode button toggles states.\n- **Logs Viewer**: Full-page log viewer with auto-refresh, log level filtering (INFO/WARNING/ERROR), and real-time workflow output display.\n- **Hardware Settings Page**: Compact 8-column grid layout for GPIO device management. Shows device ID with type as subtitle, editable channel names, GPIO pin assignments (with optional monitor pin), PWM frequency, intensity range, and voltage limits. Devices are sorted by type (wavemakers first) then channel number. Compact action buttons (Test/Save/Del) without emoji. Tabs for Wavemakers, LEDs, and All Devices views.\n\n### Technical Implementations\n- **Backend (FastAPI)**:\n    - **Services**: `StageManager`, `PowerAllocator`, `EventsService`, `AutomationService`, `SystemHealthService`, `JobScheduler`, `Store` (SQLite persistence).\n    - **API Endpoints**: Comprehensive RESTful API for controlling arrays, wavemakers, telemetry, events, and historical data, supporting partial updates.\n    - **Hardware Settings API**: Full CRUD operations for device configurations via `/api/settings/hardware/*` endpoints with GPIO pin conflict validation and LED follow relationship management.\n    - **Logs API**: Real-time workflow log streaming via `/api/settings/logs` endpoint.\n    - **Wavemaker Control**: 12 independent channels with various patterns, 20Hz control loop, 1Hz telemetry loop.\n    - **LED Control**: Individual and array-level enable/disable, proportional scaling based on intensity limits.\n    - **Intelligent Power Management**: Priority-based power shedding with hysteresis, running every second.\n    - **Timezone Support**: Frontend detects browser timezone, backend uses `USER_TZ_OFFSET` for scheduler and ETA calculations.\n    - **Database-Driven Configuration**: Device configurations (GPIO pins, PWM frequency, voltage limits, follow relationships) persisted in SQLite `device_configs` table, loaded automatically on startup with default device seeding.\n- **Frontend (Vanilla JavaScript)**:\n    - No external frameworks.\n    - Uses HTML5 Canvas for sparklines and visual flow pattern displays, with `getBoundingClientRect()` for accurate mouse interaction.\n    - Implements local state persistence for sliders/toggles.\n    - Smart preset selector updates only on state changes to prevent visual jumping.\n\n### Feature Specifications\n- **Wavemaker Preset System**: Coordinated flow control across 12 wavemakers using 9 built-in presets with custom flow curves. Presets include: Gentle Flow, Pulse, Gyre Clockwise/Counter-Clockwise, Feed Mode, Random Reef, Sequential Walk (single channel 1-12), Knight Rider (bouncing 1-12-1), and Paired Police (oscillating pairs). Features a graphical Canvas-based editor with interactive keyframe editing and automated scheduler integration.\n- **Feed Mode**: Manual button activation pauses all wavemakers for 10 minutes using a dedicated \"Feed Mode\" preset, then automatically restores the previous preset. Includes real-time countdown and scheduler integration.\n- **Automation Scheduler UI**: Full-screen modal for managing scheduled preset activations with sidebar task list, form editor (time picker, preset selector, day-of-week filtering, enabled toggle), and full CRUD operations.\n- **Automation Scheduler Backend**: Fully automated 24/7 preset activation system with 30-second precision, Â±30 second time window matching, and automatic startup resume (up to 7 days backward search). Supports day-of-week filtering and timezone-aware execution.\n- **Hardware Configuration System**: Database-driven device management with web-based configuration UI for GPIO pin assignments, PWM frequencies (wavemakers: 200Hz, LEDs: 800Hz), voltage limits (wavemakers: 0-0.6V, LEDs: 0-5V), and LED mirror relationships. Supports dynamic device addition/removal with automatic conflict detection and startup device seeding (default: WM1 on GPIO18, LED1 on GPIO19 following WM1). Device deletion properly unregisters from HAL, stopping output and cleaning up hardware resources.\n- **Logs Viewer**: Real-time workflow log monitoring with auto-refresh, log level filtering, and search capabilities for troubleshooting and system health monitoring.\n- **Wavemaker Subsystem**: Supports 12 independent channels with patterns (Off, Constant, Pulse, Gyre Left/Right, Random Reef), API for status, control, and 15-minute history. Channel names: Front Left/Right, Mid Left/Right, Back Left/Right, Side Left/Right Top/Bottom, Rear Left/Right.\n- **LED Control**: Granular control over 3 arrays, each with 6 individual LEDs, configurable name, intensity limit, and priority.\n- **Intelligent Power Management**: Automatic shedding of lowest-priority loads when power budget is exceeded, with hysteresis.\n- **System Monitoring**: Real-time display of PV input, battery flow, and net power.\n- **Simulation Mode**: Comprehensive software simulation for development, including diurnal PV curves, LED load calculation, battery flow, and configurable power budgets.\n\n### System Design Choices\n- **Hardware Abstraction Layer (HAL)**: Unifies control for simulated, Raspberry Pi (pigpio), and ESP32 serial USB adapter hardware via `HARDWARE_MODE` environment variable.\n  - `HARDWARE_MODE=mock`: Software simulation (default)\n  - `HARDWARE_MODE=pigpio` or `pi` or `real`: Raspberry Pi with pigpio daemon\n  - `HARDWARE_MODE=esp32`: ESP32 USB-to-GPIO adapter with serial communication\n- **ESP32 Serial Driver**: Supports USB-connected ESP32 boards (e.g., Keyestudio KS0413) using pyserial for PWM control. Protocol: `PIN:VALUE\\n` format (VALUE: 0-255). Configurable via `ESP32_SERIAL_PORT` (default: COM4) and `ESP32_SERIAL_BAUD` (default: 115200).\n- **Database**: SQLite for telemetry, event persistence, and device configuration storage (`device_configs` table).\n- **Configuration**: Environment variables (`APP_PORT`, `DB_URL`, `HARDWARE_MODE`, `ESP32_SERIAL_PORT`, `ESP32_SERIAL_BAUD`, `USER_TZ_OFFSET`) and `config.yaml`, with runtime device configuration persisted in database.\n- **Platform-Agnostic GPIO**: USB-to-GPIO adapter support (ESP32, Raspberry Pi) for PC-style boards (Linux/Windows compatible), abstracting hardware control from specific board requirements.\n- **Deployment**: Designed for Replit's autoscale deployment, emphasizing statelessness and environment-based configuration.\n\n## External Dependencies\n- **FastAPI**: Web framework.\n- **Uvicorn**: ASGI server.\n- **SQLModel**: ORM for SQLite.\n- **APScheduler**: Python library for scheduling tasks.\n- **PyYAML**: For parsing YAML configuration files.\n- **PySerial**: Serial communication library for ESP32 USB adapter.\n- **PCA9685 PWM Controller**: Hardware for pump control (I2C).\n- **INA219 Power Sensors**: Hardware for monitoring current/voltage (I2C).","size_bytes":12387},"app/routers/history.py":{"content":"from fastapi import APIRouter, Query, HTTPException, Request\nfrom typing import List, Dict, Any\nfrom datetime import datetime, timedelta\nimport math\nimport math as m\n\nrouter = APIRouter(prefix=\"/api/history\", tags=[\"history\"])\n\n@router.get(\"/array/{array_id}\")\nasync def get_array_history(\n    request: Request,\n    array_id: str,\n    time_range: str = Query(\"1h\", regex=\"^(1h|6h|24h)$\", alias=\"range\")\n):\n    store = request.app.state.store\n    \n    range_minutes = {\n        \"1h\": 60,\n        \"6h\": 360,\n        \"24h\": 1440\n    }\n    \n    minutes = range_minutes.get(time_range, 60)\n    start_time = datetime.now() - timedelta(minutes=minutes)\n    \n    try:\n        rows = store.query_telemetry_range(array_id, start_time, datetime.now())\n        \n        downsample_factor = max(1, m.ceil(len(rows) / 100))\n        sampled = rows[::downsample_factor]\n        \n        history = []\n        for row in sampled:\n            history.append({\n                \"t\": row[\"timestamp\"].isoformat(),\n                \"v\": round(row[\"vout_v\"], 2),\n                \"i\": round(row[\"iout_a\"], 3),\n                \"p\": round(row[\"power_w\"], 1)\n            })\n        \n        return {\"array_id\": array_id, \"range\": time_range, \"data\": history}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.get(\"/system\")\nasync def get_system_history(\n    request: Request,\n    time_range: str = Query(\"1h\", regex=\"^(1h|6h|24h)$\", alias=\"range\")\n):\n    store = request.app.state.store\n    \n    range_minutes = {\n        \"1h\": 60,\n        \"6h\": 360,\n        \"24h\": 1440\n    }\n    \n    minutes = range_minutes.get(time_range, 60)\n    start_time = datetime.now() - timedelta(minutes=minutes)\n    \n    try:\n        all_data = {}\n        for array_id in [\"A1\", \"A2\", \"A3\"]:\n            rows = store.query_telemetry_range(array_id, start_time, datetime.now())\n            all_data[array_id] = rows\n        \n        max_len = max((len(v) for v in all_data.values()), default=0)\n        downsample_factor = max(1, m.ceil(max_len / 100))\n        \n        history = []\n        if max_len > 0:\n            for i in range(0, max_len, downsample_factor):\n                entry = {\"t\": None, \"arrays\": {}, \"battery_w\": 0}\n                total_load = 0\n                for array_id, rows in all_data.items():\n                    if i < len(rows):\n                        row = rows[i]\n                        if entry[\"t\"] is None:\n                            entry[\"t\"] = row[\"timestamp\"].isoformat()\n                        entry[\"arrays\"][array_id] = {\n                            \"p\": round(row[\"power_w\"], 1)\n                        }\n                        total_load += row[\"power_w\"]\n                \n                pv_power = 0.0\n                if hasattr(request.app.state, \"latest\") and request.app.state.latest:\n                    for reading in request.app.state.latest:\n                        if reading.stage_id == \"PV\":\n                            pv_power = reading.vout_v * reading.iout_a\n                            break\n                entry[\"battery_w\"] = round(pv_power - total_load, 1)\n                \n                if entry[\"t\"]:\n                    history.append(entry)\n        \n        return {\"range\": time_range, \"data\": history}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n","size_bytes":3360},"app/services/automation.py":{"content":"from datetime import datetime, timedelta\nfrom typing import List, Dict, Optional\nimport json\n\n\nclass AutomationService:\n    def __init__(self, store=None, preset_manager=None, timezone_offset_minutes=0):\n        self.store = store\n        self.preset_manager = preset_manager\n        self.last_executed_tasks = {}\n        # Timezone offset from UTC in minutes (e.g., +600 for AEST/UTC+10, +660 for AEDT/UTC+11)\n        # Defaults to 0 (UTC) - frontend detects browser timezone automatically\n        self.timezone_offset_minutes = timezone_offset_minutes\n        \n        self.feed_mode_active = False\n        self.feed_mode_start_time = None\n        self.feed_mode_duration_minutes = 10\n        self.preset_before_feed = None\n        \n        self.completed_tasks = [\n            {\"name\": \"Morning Feeding\", \"time\": \"08:15 AM\", \"status\": \"completed\"},\n            {\"name\": \"Peak Flow Cycle\", \"time\": \"10:30 AM\", \"status\": \"completed\"},\n            {\"name\": \"Water Quality Check\", \"time\": \"12:00 PM\", \"status\": \"completed\"},\n        ]\n        \n        self.wave_modes = {\n            \"Left Swirl\": {\"pattern\": \"circular_left\", \"intensity\": 0.7},\n            \"Right Swirl\": {\"pattern\": \"circular_right\", \"intensity\": 0.7},\n            \"Front-Back Surge\": {\"pattern\": \"surge_fb\", \"intensity\": 0.8},\n            \"Cross Current\": {\"pattern\": \"cross\", \"intensity\": 0.6},\n            \"Reef Pulse\": {\"pattern\": \"pulse\", \"intensity\": 0.9},\n        }\n        \n        self.current_wave_mode = \"Reef Pulse\"\n    \n    def get_completed_tasks(self) -> List[Dict]:\n        return self.completed_tasks\n    \n    def get_upcoming_tasks(self, user_tz_offset_minutes: int = 0) -> List[Dict]:\n        \"\"\"Get upcoming tasks with timezone support.\n        \n        Args:\n            user_tz_offset_minutes: User's timezone offset from UTC in minutes (e.g., +660 for AEDT/UTC+11)\n        \"\"\"\n        if not self.store:\n            return [\n                {\"name\": \"Evening Feeding\", \"time\": \"06:00 PM\", \"eta_minutes\": 45},\n                {\"name\": \"Night Mode Transition\", \"time\": \"08:30 PM\", \"eta_minutes\": 195},\n            ]\n        \n        tasks = self.store.get_all_scheduled_tasks()\n        # Get current time in UTC\n        now_utc = datetime.utcnow()\n        # Convert to user's timezone\n        user_offset = timedelta(minutes=user_tz_offset_minutes)\n        now_user = now_utc + user_offset\n        \n        upcoming = []\n        \n        for task in tasks:\n            if not task.enabled:\n                continue\n            \n            try:\n                task_hour, task_min = task.time.split(':')\n                \n                # Parse day-of-week filter if present\n                days_filter = None\n                if task.days_of_week:\n                    days_filter = json.loads(task.days_of_week) if isinstance(task.days_of_week, str) else task.days_of_week\n                \n                # Find next occurrence IN USER'S TIMEZONE\n                task_dt = now_user.replace(hour=int(task_hour), minute=int(task_min), second=0, microsecond=0)\n                \n                # If no day filter, simple logic: if time passed today, use tomorrow\n                if not days_filter or len(days_filter) == 0:\n                    if task_dt <= now_user:\n                        task_dt += timedelta(days=1)\n                else:\n                    # With day filter, prioritize tasks that haven't passed today\n                    # Python weekday(): Monday=0, Sunday=6 (matches our filter format)\n                    current_weekday = now_user.weekday()\n                    \n                    # If time is still in the future TODAY and today matches the filter, use it\n                    if task_dt > now_user and current_weekday in days_filter:\n                        # Task is scheduled for later today and today matches filter - use it!\n                        pass  # task_dt already set correctly for today\n                    else:\n                        # Time has passed today or today doesn't match filter - find next matching day\n                        found = False\n                        for days_ahead in range(1, 8):  # Check 1-7 days ahead (skip today, already checked)\n                            candidate = task_dt + timedelta(days=days_ahead)\n                            candidate_weekday = candidate.weekday()\n                            \n                            # Check if this day matches the filter\n                            if candidate_weekday in days_filter:\n                                task_dt = candidate\n                                found = True\n                                break\n                        \n                        if not found:\n                            continue  # Skip this task if no valid occurrence found\n                \n                eta_minutes = int((task_dt - now_user).total_seconds() / 60)\n                \n                upcoming.append({\n                    \"id\": task.id,\n                    \"name\": task.name,\n                    \"time\": task.time,\n                    \"eta_minutes\": eta_minutes,\n                    \"type\": task.task_type,\n                    \"preset_id\": task.preset_id\n                })\n            except Exception as e:\n                print(f\"[Automation] Error calculating upcoming task for {task.name}: {e}\")\n                continue\n        \n        upcoming.sort(key=lambda x: x[\"eta_minutes\"])\n        return upcoming[:5]\n    \n    def get_wave_modes(self) -> List[str]:\n        return list(self.wave_modes.keys())\n    \n    def get_current_wave_mode(self) -> str:\n        return self.current_wave_mode\n    \n    def set_wave_mode(self, mode: str) -> bool:\n        if mode in self.wave_modes:\n            self.current_wave_mode = mode\n            return True\n        return False\n    \n    def start_feed_mode(self) -> Dict:\n        if not self.preset_manager or not self.store:\n            return {\"success\": False, \"message\": \"Preset manager not available\"}\n        \n        if self.feed_mode_active:\n            return {\"success\": False, \"message\": \"Feed mode already active\"}\n        \n        feed_preset = self.store.get_preset_by_name(\"Feed Mode\")\n        if not feed_preset:\n            return {\"success\": False, \"message\": \"Feed Mode preset not found\"}\n        \n        current_preset = self.preset_manager.get_active_preset()\n        self.preset_before_feed = current_preset.id if current_preset else None\n        \n        self.preset_manager.set_active_preset(feed_preset.id)\n        self.feed_mode_active = True\n        self.feed_mode_start_time = datetime.utcnow()  # Use UTC for consistent timezone handling\n        \n        print(f\"[Feed Mode] Started - previous preset: {self.preset_before_feed}\")\n        return {\"success\": True, \"message\": \"Feed mode activated\"}\n    \n    def get_feed_mode_status(self) -> Dict:\n        if not self.feed_mode_active:\n            return {\n                \"active\": False,\n                \"remaining_seconds\": 0,\n                \"duration_minutes\": self.feed_mode_duration_minutes\n            }\n        \n        # Use UTC for consistent timezone handling\n        elapsed = (datetime.utcnow() - self.feed_mode_start_time).total_seconds()\n        total_seconds = self.feed_mode_duration_minutes * 60\n        remaining = max(0, total_seconds - elapsed)\n        \n        return {\n            \"active\": True,\n            \"remaining_seconds\": int(remaining),\n            \"duration_minutes\": self.feed_mode_duration_minutes,\n            \"start_time\": self.feed_mode_start_time.isoformat()\n        }\n    \n    def stop_feed_mode(self, restore_preset: bool = True) -> Dict:\n        if not self.feed_mode_active:\n            return {\"success\": False, \"message\": \"Feed mode not active\"}\n        \n        self.feed_mode_active = False\n        \n        if restore_preset and self.preset_before_feed:\n            try:\n                self.preset_manager.set_active_preset(self.preset_before_feed)\n                print(f\"[Feed Mode] Stopped - restored preset {self.preset_before_feed}\")\n            except Exception as e:\n                print(f\"[Feed Mode] Failed to restore preset: {e}\")\n        \n        self.feed_mode_start_time = None\n        self.preset_before_feed = None\n        \n        return {\"success\": True, \"message\": \"Feed mode stopped\"}\n    \n    def check_feed_mode_timeout(self):\n        if not self.feed_mode_active or not self.feed_mode_start_time:\n            return\n        \n        # Use UTC for feed mode timing (timezone-independent)\n        now_utc = datetime.utcnow()\n        elapsed = (now_utc - self.feed_mode_start_time).total_seconds()\n        duration_seconds = self.feed_mode_duration_minutes * 60\n        \n        if elapsed >= duration_seconds:\n            print(f\"[Feed Mode] Timeout reached, auto-stopping\")\n            self.stop_feed_mode(restore_preset=True)\n    \n    def check_and_execute_tasks(self):\n        if not self.store or not self.preset_manager:\n            return\n        \n        if self.feed_mode_active:\n            return\n        \n        tasks = self.store.get_all_scheduled_tasks()\n        # Use user's timezone for task execution\n        now_utc = datetime.utcnow()\n        now = now_utc + timedelta(minutes=self.timezone_offset_minutes)\n        today = now.weekday()\n        \n        for task in tasks:\n            if not task.enabled:\n                continue\n            \n            # Check day of week filter\n            if task.days_of_week:\n                try:\n                    days = json.loads(task.days_of_week) if isinstance(task.days_of_week, str) else task.days_of_week\n                    if today not in days:\n                        continue\n                except:\n                    pass\n            \n            # Parse task time and create datetime for comparison\n            try:\n                task_hour, task_min = task.time.split(':')\n                task_datetime = now.replace(hour=int(task_hour), minute=int(task_min), second=0, microsecond=0)\n            except:\n                continue\n            \n            # Check if we're within Â±30 seconds of the scheduled time (use absolute time comparison)\n            time_diff_seconds = abs((now - task_datetime).total_seconds())\n            \n            # Allow execution if within 30 seconds window\n            if time_diff_seconds <= 30:\n                # Prevent duplicate execution (only run once per minute)\n                task_key = f\"{task.id}_{task.time}\"\n                last_exec = self.last_executed_tasks.get(task_key)\n                \n                if last_exec and (now - last_exec).total_seconds() < 60:\n                    print(f\"[Automation] âŠ˜ SKIPPED: '{task.name}' at {task.time} - already executed {int((now - last_exec).total_seconds())}s ago\")\n                    continue\n                \n                print(f\"[Automation] â†’ TRIGGERING: '{task.name}' scheduled for {task.time} (current: {now.strftime('%H:%M:%S')})\")\n                self._execute_task(task)\n                self.last_executed_tasks[task_key] = now\n    \n    def _execute_task(self, task):\n        \"\"\"Execute a scheduled task\"\"\"\n        if task.task_type == \"preset_activation\" and task.preset_id:\n            try:\n                # Get preset details for logging\n                preset = self.store.get_preset_by_id(task.preset_id)\n                preset_name = preset.name if preset else f\"ID {task.preset_id}\"\n                \n                self.preset_manager.set_active_preset(task.preset_id)\n                print(f\"[Automation] âœ“ EXECUTED: '{task.name}' at {task.time} - activated preset '{preset_name}' (ID: {task.preset_id})\")\n            except Exception as e:\n                print(f\"[Automation] âœ— FAILED: task '{task.name}' - {e}\")\n    \n    def auto_resume_from_schedule(self):\n        \"\"\"Find and activate the preset that should be active right now based on schedule\"\"\"\n        if not self.store or not self.preset_manager:\n            print(\"[Automation] Auto-resume skipped - store or preset_manager not available\")\n            return\n        \n        tasks = self.store.get_all_scheduled_tasks()\n        if not tasks:\n            print(\"[Automation] No scheduled tasks found for auto-resume\")\n            return\n        \n        # Use user's timezone for auto-resume\n        now_utc = datetime.utcnow()\n        now = now_utc + timedelta(minutes=self.timezone_offset_minutes)\n        \n        # Build a list of all task occurrences with their actual datetime (including day of week filter)\n        task_occurrences = []\n        for task in tasks:\n            if not task.enabled or task.task_type != \"preset_activation\":\n                continue\n            \n            # Parse task time\n            try:\n                task_hour, task_min = task.time.split(':')\n            except:\n                continue\n            \n            # Check day of week filter\n            applicable_days = None\n            if task.days_of_week:\n                try:\n                    applicable_days = json.loads(task.days_of_week) if isinstance(task.days_of_week, str) else task.days_of_week\n                except:\n                    applicable_days = None\n            \n            # If no day filter, task runs every day - check today and yesterday\n            # If has day filter, only check days it applies to\n            days_to_check = []\n            if applicable_days is None:\n                # No filter - check last 7 days to find most recent occurrence\n                days_to_check = list(range(7))\n            else:\n                # Has filter - only check days where this task runs, going back up to 7 days\n                for days_back in range(7):\n                    check_date = now - timedelta(days=days_back)\n                    if check_date.weekday() in applicable_days:\n                        days_to_check.append(days_back)\n            \n            # Create datetime for each applicable occurrence\n            for days_back in days_to_check:\n                task_datetime = (now - timedelta(days=days_back)).replace(\n                    hour=int(task_hour), \n                    minute=int(task_min), \n                    second=0, \n                    microsecond=0\n                )\n                \n                # Only consider if it's in the past\n                if task_datetime <= now:\n                    task_occurrences.append({\n                        'task': task,\n                        'datetime': task_datetime\n                    })\n        \n        if not task_occurrences:\n            print(\"[Automation] No past task occurrences found for auto-resume\")\n            return\n        \n        # Sort by datetime and get the most recent\n        task_occurrences.sort(key=lambda x: x['datetime'], reverse=True)\n        most_recent = task_occurrences[0]\n        \n        # Activate the preset\n        task = most_recent['task']\n        if task.preset_id:\n            try:\n                self.preset_manager.set_active_preset(task.preset_id)\n                time_ago = now - most_recent['datetime']\n                hours_ago = int(time_ago.total_seconds() / 3600)\n                print(f\"[Automation] Auto-resumed: activated preset {task.preset_id} for task '{task.name}' (scheduled {hours_ago}h ago at {task.time})\")\n            except Exception as e:\n                print(f\"[Automation] Failed to auto-resume task {task.name}: {e}\")\n        else:\n            print(\"[Automation] No suitable task found for auto-resume\")\n","size_bytes":15464},"app/drivers/__init__.py":{"content":"","size_bytes":0},"app/routers/arrays.py":{"content":"from fastapi import APIRouter, Request, HTTPException, Query\nfrom datetime import datetime, timedelta\nfrom typing import Optional\nfrom app.models import ArrayStatus, ArraySettingsRequest, SystemLoad, PowerEvent\n\n\nrouter = APIRouter()\n\n\n@router.get(\"/arrays\")\nasync def get_arrays(request: Request):\n    stage_manager = request.app.state.stage_manager\n    arrays = []\n    \n    for stage in stage_manager.stages:\n        if hasattr(stage, 'leds'):\n            array_status = ArrayStatus(\n                id=stage.id,\n                name=stage.name,\n                description=stage.description,\n                enabled=stage.enabled,\n                mode=stage.mode,\n                duty=stage.duty,\n                leds=stage.leds,\n                vin_v=0.0,\n                iin_a=0.0,\n                vout_v=0.0,\n                iout_a=0.0,\n                power_w=0.0\n            )\n            \n            latest = request.app.state.latest\n            if latest:\n                for reading in latest:\n                    if reading.stage_id == stage.id:\n                        array_status.vin_v = reading.vin_v\n                        array_status.iin_a = reading.iin_a\n                        array_status.vout_v = reading.vout_v\n                        array_status.iout_a = reading.iout_a\n                        array_status.power_w = reading.vout_v * reading.iout_a\n                        break\n            \n            arrays.append(array_status)\n    \n    return {\"arrays\": arrays}\n\n\n@router.post(\"/arrays/{array_id}/settings\")\nasync def update_array_settings(\n    array_id: str,\n    settings: ArraySettingsRequest,\n    request: Request\n):\n    stage_manager = request.app.state.stage_manager\n    \n    stage = None\n    for s in stage_manager.stages:\n        if s.id == array_id:\n            stage = s\n            break\n    \n    if not stage:\n        raise HTTPException(status_code=404, detail=\"Array not found\")\n    \n    if not hasattr(stage, 'leds'):\n        raise HTTPException(status_code=400, detail=\"Stage is not an array\")\n    \n    for led_id, updates in settings.leds.items():\n        led = next((l for l in stage.leds if l.id == led_id), None)\n        if not led:\n            continue\n        \n        if updates.label is not None:\n            led.label = updates.label\n        if updates.intensity_limit_pct is not None:\n            led.intensity_limit_pct = max(0, min(100, updates.intensity_limit_pct))\n        if updates.priority is not None:\n            led.priority = updates.priority\n        if updates.is_on is not None:\n            led.is_on = updates.is_on\n    \n    stage.apply_control()\n    \n    return {\"success\": True, \"array_id\": array_id}\n\n\n@router.get(\"/system/load\")\nasync def get_system_load(request: Request):\n    latest = request.app.state.latest\n    \n    pv_w = 0.0\n    load_w = 0.0\n    \n    if latest:\n        for reading in latest:\n            if reading.stage_id == \"PV\":\n                pv_w = reading.vout_v * reading.iout_a\n            else:\n                load_w += reading.vout_v * reading.iout_a\n    \n    battery_w = pv_w - load_w\n    \n    config = request.app.state.config\n    budget_w = config.get(\"power_budget\", {}).get(\"target_watts\", 400)\n    \n    return SystemLoad(\n        pv_w=pv_w,\n        load_w=load_w,\n        battery_w=battery_w,\n        net_w=pv_w - load_w,\n        budget_w=budget_w,\n        timestamp=datetime.now()\n    )\n\n\n@router.get(\"/events\")\nasync def get_events(request: Request, limit: int = Query(default=50, ge=1, le=200)):\n    events_service = request.app.state.events\n    events = events_service.get_recent_events(limit=limit)\n    return {\"events\": events}\n","size_bytes":3638},"app/routers/wavemakers.py":{"content":"\"\"\"\nWavemaker API Endpoints\n\"\"\"\nfrom fastapi import APIRouter, HTTPException, Request\nfrom typing import List\nfrom ..models import WavemakerChannel, WavemakerControlRequest, WavemakerHistoryPoint\n\nrouter = APIRouter()\n\n\n@router.get('/wavemakers', response_model=List[WavemakerChannel])\nasync def get_all_wavemakers(request: Request):\n    \"\"\"Get status of all 6 wavemaker channels\"\"\"\n    manager = request.app.state.wavemaker_manager\n    return manager.get_all_status()\n\n\n@router.get('/wavemakers/{channel_id}', response_model=WavemakerChannel)\nasync def get_wavemaker(channel_id: int, request: Request):\n    \"\"\"Get status of a specific wavemaker channel\"\"\"\n    try:\n        manager = request.app.state.wavemaker_manager\n        return manager.get_channel_status(channel_id)\n    except ValueError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n\n\n@router.put('/wavemakers/{channel_id}', response_model=WavemakerChannel)\nasync def update_wavemaker(channel_id: int, update: WavemakerControlRequest, request: Request):\n    \"\"\"Update wavemaker channel mode and/or target power\"\"\"\n    try:\n        manager = request.app.state.wavemaker_manager\n        manager.update_channel(\n            channel_id,\n            mode=update.mode,\n            target_pct=update.target_power_pct,\n            pulse_duty_ratio=update.pulse_duty_ratio\n        )\n        return manager.get_channel_status(channel_id)\n    except ValueError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n\n\n@router.get('/wavemakers/{channel_id}/history', response_model=List[WavemakerHistoryPoint])\nasync def get_wavemaker_history(channel_id: int, request: Request, window: int = 900):\n    \"\"\"\n    Get power history for a wavemaker channel\n    \n    Args:\n        channel_id: Channel ID (0-5)\n        window: Time window in seconds (default 900 = 15 minutes)\n    \"\"\"\n    if not (0 <= channel_id < 6):\n        raise HTTPException(status_code=404, detail=f\"Invalid channel ID: {channel_id}\")\n        \n    manager = request.app.state.wavemaker_manager\n    return manager.get_channel_history(channel_id, window_s=window)\n\n\n@router.post('/wavemakers/emergency-stop')\nasync def emergency_stop(request: Request):\n    \"\"\"Emergency stop all wavemaker channels\"\"\"\n    manager = request.app.state.wavemaker_manager\n    manager.emergency_stop()\n    return {\"status\": \"all channels stopped\"}\n","size_bytes":2368},"app/hardware/__init__.py":{"content":"","size_bytes":0},"app/services/wavemaker_manager.py":{"content":"\"\"\"\nWavemaker Manager Service\nCoordinates 6 wavemaker channels with different wave patterns\n\"\"\"\nimport time\nimport math\nimport random\nfrom datetime import datetime, timedelta\nfrom collections import deque\nfrom typing import List, Dict, Deque\nfrom ..models import WavemakerMode, WavemakerChannel, WavemakerHistoryPoint\nfrom ..hardware.hal import WavemakerHAL\n\n\nclass Channel:\n    \"\"\"Individual wavemaker channel with pattern generation\"\"\"\n    \n    def __init__(self, channel_id: int, name: str):\n        self.id = channel_id\n        self.name = name\n        self.mode: WavemakerMode = \"off\"\n        self.target_power_pct: int = 0\n        self.current_duty: float = 0.0\n        \n        self.voltage_v: float = 0.0\n        self.current_a: float = 0.0\n        self.power_w: float = 0.0\n        \n        self.pattern_phase: float = 0.0\n        self.pulse_on_time: float = 0.0\n        self.pulse_period: float = 10.0\n        self.pulse_duty_ratio: float = 0.6\n        \n        self.random_current: float = 0.0\n        self.random_target: float = 0.0\n        self.random_transition_start: float = 0.0\n        self.random_transition_duration: float = 2.0\n        \n    def _compute_duty_from_mode(self, t_now: float) -> float:\n        \"\"\"\n        Compute PWM duty cycle based on current mode and time\n        \n        Returns:\n            Duty cycle from 0.0 to 1.0\n        \"\"\"\n        if self.mode == \"off\":\n            return 0.0\n            \n        if self.mode == \"constant\":\n            return self.target_power_pct / 100.0\n            \n        if self.mode == \"pulse\":\n            time_in_cycle = (t_now - self.pulse_on_time) % self.pulse_period\n            on_duration = self.pulse_period * self.pulse_duty_ratio\n            \n            if time_in_cycle < on_duration:\n                return self.target_power_pct / 100.0\n            else:\n                return 0.0\n                \n        if self.mode == \"gyre_left\":\n            phase = (t_now / 30.0) * 2 * math.pi + self.pattern_phase\n            wave = (math.sin(phase) + 1) / 2\n            \n            if self.id % 2 == 0:\n                duty = wave * (self.target_power_pct / 100.0)\n            else:\n                duty = (1 - wave) * (self.target_power_pct / 100.0)\n            return max(0.0, min(1.0, duty))\n            \n        if self.mode == \"gyre_right\":\n            phase = (t_now / 30.0) * 2 * math.pi + self.pattern_phase\n            wave = (math.sin(phase) + 1) / 2\n            \n            if self.id % 2 == 0:\n                duty = (1 - wave) * (self.target_power_pct / 100.0)\n            else:\n                duty = wave * (self.target_power_pct / 100.0)\n            return max(0.0, min(1.0, duty))\n            \n        if self.mode == \"random_reef\":\n            elapsed = t_now - self.random_transition_start\n            \n            if elapsed >= self.random_transition_duration:\n                self.random_current = self.random_target\n                self.random_target = random.uniform(0.3, 1.0) * (self.target_power_pct / 100.0)\n                self.random_transition_start = t_now\n                self.random_transition_duration = random.uniform(5.0, 15.0)\n                elapsed = 0.0\n                \n            progress = min(1.0, elapsed / self.random_transition_duration)\n            smooth_progress = 0.5 * (1 - math.cos(progress * math.pi))\n            \n            duty = (1 - smooth_progress) * self.random_current + smooth_progress * self.random_target\n            return max(0.0, min(1.0, duty))\n            \n        return 0.0\n        \n    def update_pwm(self, t_now: float, hal: WavemakerHAL):\n        \"\"\"Update PWM output based on current mode\"\"\"\n        new_duty = self._compute_duty_from_mode(t_now)\n        self.current_duty = new_duty\n        hal.set_channel_pwm(self.id, new_duty)\n        \n    def read_power(self, hal: WavemakerHAL):\n        \"\"\"Read power telemetry from sensor\"\"\"\n        telemetry = hal.read_channel_power(self.id)\n        self.voltage_v = telemetry[\"voltage\"]\n        self.current_a = telemetry[\"current\"]\n        self.power_w = telemetry[\"power\"]\n        \n    def set_mode(self, mode: WavemakerMode, target_pct: int, pulse_duty_ratio: float = None):\n        \"\"\"Update channel mode and target power\"\"\"\n        self.mode = mode\n        self.target_power_pct = max(0, min(100, target_pct))\n        \n        if pulse_duty_ratio is not None:\n            self.pulse_duty_ratio = max(0.0, min(1.0, pulse_duty_ratio))\n        \n        if mode == \"pulse\":\n            self.pulse_on_time = time.time()\n            \n        if mode == \"random_reef\":\n            self.random_current = self.current_duty\n            self.random_target = self.target_power_pct / 100.0\n            self.random_transition_start = time.time()\n            \n    def to_model(self) -> WavemakerChannel:\n        \"\"\"Convert to API model\"\"\"\n        return WavemakerChannel(\n            id=self.id,\n            name=self.name,\n            mode=self.mode,\n            target_power_pct=self.target_power_pct,\n            pulse_duty_ratio=self.pulse_duty_ratio,\n            current_power_w=round(self.power_w, 2),\n            voltage_v=round(self.voltage_v, 2),\n            current_a=round(self.current_a, 3)\n        )\n\n\nclass WavemakerManager:\n    \"\"\"Manages all 12 wavemaker channels\"\"\"\n    \n    def __init__(self):\n        self.hal = WavemakerHAL()\n        \n        self.channels = [\n            Channel(0, \"Front Left\"),\n            Channel(1, \"Front Right\"),\n            Channel(2, \"Mid Left\"),\n            Channel(3, \"Mid Right\"),\n            Channel(4, \"Back Left\"),\n            Channel(5, \"Back Right\"),\n            Channel(6, \"Side Left Top\"),\n            Channel(7, \"Side Right Top\"),\n            Channel(8, \"Side Left Bottom\"),\n            Channel(9, \"Side Right Bottom\"),\n            Channel(10, \"Rear Left\"),\n            Channel(11, \"Rear Right\")\n        ]\n        \n        self.history_window_s = 900\n        self.history: Dict[int, Deque[WavemakerHistoryPoint]] = {\n            i: deque(maxlen=900) for i in range(12)\n        }\n        \n        self.last_telemetry_time = 0.0\n        self.preset_manager = None\n        \n    def set_preset_manager(self, preset_manager):\n        \"\"\"Inject preset manager for preset-based control\"\"\"\n        self.preset_manager = preset_manager\n    \n    def apply_preset_power_levels(self):\n        \"\"\"Apply power levels from active preset to all channels\"\"\"\n        if not self.preset_manager:\n            return\n        \n        power_levels = self.preset_manager.get_current_power_levels()\n        \n        for wavemaker_num, power_pct in power_levels.items():\n            channel_index = wavemaker_num - 1\n            if 0 <= channel_index < len(self.channels):\n                channel = self.channels[channel_index]\n                channel.mode = \"constant\"\n                channel.target_power_pct = int(power_pct)\n    \n    def update_all(self, t_now: float):\n        \"\"\"Update all channels (20 Hz control loop)\"\"\"\n        if self.preset_manager and self.preset_manager.get_active_preset():\n            self.apply_preset_power_levels()\n        \n        for channel in self.channels:\n            channel.update_pwm(t_now, self.hal)\n            \n    def sample_all_power(self):\n        \"\"\"Sample power from all channels (1 Hz telemetry loop)\"\"\"\n        current_time = time.time()\n        \n        if current_time - self.last_telemetry_time < 0.5:\n            return\n            \n        self.last_telemetry_time = current_time\n        \n        for channel in self.channels:\n            channel.read_power(self.hal)\n            \n            point = WavemakerHistoryPoint(\n                t=datetime.now(),\n                power_w=channel.power_w,\n                duty_pct=round(channel.current_duty * 100, 1),\n                pulse_duty_ratio=channel.pulse_duty_ratio\n            )\n            self.history[channel.id].append(point)\n            \n    def get_channel_status(self, channel_id: int) -> WavemakerChannel:\n        \"\"\"Get status for a specific channel\"\"\"\n        if 0 <= channel_id < len(self.channels):\n            return self.channels[channel_id].to_model()\n        raise ValueError(f\"Invalid channel ID: {channel_id}\")\n        \n    def get_all_status(self) -> List[WavemakerChannel]:\n        \"\"\"Get status for all channels\"\"\"\n        return [ch.to_model() for ch in self.channels]\n        \n    def update_channel(self, channel_id: int, mode: WavemakerMode = None, target_pct: int = None, pulse_duty_ratio: float = None):\n        \"\"\"Update a channel's mode and/or target power (partial updates supported)\"\"\"\n        if not (0 <= channel_id < len(self.channels)):\n            raise ValueError(f\"Invalid channel ID: {channel_id}\")\n            \n        channel = self.channels[channel_id]\n        \n        new_mode = mode if mode is not None else channel.mode\n        new_target = target_pct if target_pct is not None else channel.target_power_pct\n        \n        channel.set_mode(new_mode, new_target, pulse_duty_ratio)\n        \n    def get_channel_history(self, channel_id: int, window_s: int = 900) -> List[WavemakerHistoryPoint]:\n        \"\"\"Get power history for a channel\"\"\"\n        if channel_id not in self.history:\n            return []\n            \n        cutoff_time = datetime.now() - timedelta(seconds=window_s)\n        \n        return [\n            point for point in self.history[channel_id]\n            if point.t >= cutoff_time\n        ]\n        \n    def emergency_stop(self):\n        \"\"\"Emergency stop all channels\"\"\"\n        for channel in self.channels:\n            channel.set_mode(\"off\", 0)\n        self.hal.shutdown_all()\n","size_bytes":9589},"app/hardware/pca.py":{"content":"\"\"\"\nPCA9685 PWM Controller - Hardware Abstraction\nSupports both simulated and real PCA9685 16-channel PWM driver\n\"\"\"\nimport os\nimport time\nimport math\nfrom typing import Optional\n\nHARDWARE_MODE = os.getenv(\"HARDWARE_MODE\", \"sim\")\n\n\nclass PCA9685Simulated:\n    \"\"\"Simulated PCA9685 for development/testing\"\"\"\n    \n    def __init__(self, address: int = 0x40):\n        self.address = address\n        self.channels = [0] * 16\n        self.frequency = 1000\n        \n    def set_pwm_freq(self, freq: int):\n        \"\"\"Set PWM frequency\"\"\"\n        self.frequency = freq\n        \n    def set_pwm(self, channel: int, on: int, off: int):\n        \"\"\"Set PWM duty cycle for a channel\"\"\"\n        if 0 <= channel < 16:\n            duty = off / 4096.0\n            self.channels[channel] = duty\n            \n    def set_pwm_duty(self, channel: int, duty: float):\n        \"\"\"Set PWM duty cycle (0.0 to 1.0)\"\"\"\n        if 0 <= channel < 16:\n            off_value = int(duty * 4095)\n            self.set_pwm(channel, 0, off_value)\n            self.channels[channel] = duty\n\n\nclass PCA9685Real:\n    \"\"\"Real PCA9685 hardware driver\"\"\"\n    \n    def __init__(self, address: int = 0x40):\n        try:\n            from adafruit_pca9685 import PCA9685\n            import board\n            import busio\n            \n            i2c = busio.I2C(board.SCL, board.SDA)\n            self.pca = PCA9685(i2c, address=address)\n            self.pca.frequency = 1000\n        except ImportError:\n            raise RuntimeError(\"Real hardware libraries not available. Install adafruit-circuitpython-pca9685\")\n            \n    def set_pwm_freq(self, freq: int):\n        \"\"\"Set PWM frequency\"\"\"\n        self.pca.frequency = freq\n        \n    def set_pwm(self, channel: int, on: int, off: int):\n        \"\"\"Set PWM for channel\"\"\"\n        self.pca.channels[channel].duty_cycle = off\n        \n    def set_pwm_duty(self, channel: int, duty: float):\n        \"\"\"Set PWM duty cycle (0.0 to 1.0)\"\"\"\n        duty_cycle = int(duty * 65535)\n        self.pca.channels[channel].duty_cycle = duty_cycle\n\n\ndef create_pca9685(address: int = 0x40):\n    \"\"\"Factory function to create appropriate PCA9685 instance\"\"\"\n    if HARDWARE_MODE == \"pi\":\n        return PCA9685Real(address)\n    else:\n        return PCA9685Simulated(address)\n","size_bytes":2272},"app/hardware/hal.py":{"content":"\"\"\"\nHardware Abstraction Layer (HAL)\nProvides unified interface for wavemaker hardware control\n\"\"\"\nimport os\nfrom typing import Dict\nfrom .pca import create_pca9685\nfrom .sensors import SensorArray\n\nHARDWARE_MODE = os.getenv(\"HARDWARE_MODE\", \"sim\")\n\n\nclass WavemakerHAL:\n    \"\"\"Hardware abstraction for 12-channel wavemaker system\"\"\"\n    \n    def __init__(self):\n        self.pca = create_pca9685(address=0x40)\n        self.pca.set_pwm_freq(1000)\n        \n        sensor_addresses = {\n            0: 0x40,\n            1: 0x41,\n            2: 0x44,\n            3: 0x45,\n            4: 0x48,\n            5: 0x49,\n            6: 0x4A,\n            7: 0x4B,\n            8: 0x4C,\n            9: 0x4D,\n            10: 0x4E,\n            11: 0x4F\n        }\n        self.sensors = SensorArray(sensor_addresses)\n        \n        self.channel_map = {\n            0: 0,\n            1: 1,\n            2: 2,\n            3: 3,\n            4: 4,\n            5: 5,\n            6: 6,\n            7: 7,\n            8: 8,\n            9: 9,\n            10: 10,\n            11: 11\n        }\n        \n    def set_channel_pwm(self, channel_id: int, duty: float):\n        \"\"\"\n        Set PWM duty cycle for a channel\n        \n        Args:\n            channel_id: Channel number (0-11)\n            duty: Duty cycle 0.0 to 1.0\n        \"\"\"\n        if channel_id not in self.channel_map:\n            return\n            \n        duty = max(0.0, min(1.0, duty))\n        pwm_channel = self.channel_map[channel_id]\n        \n        self.pca.set_pwm_duty(pwm_channel, duty)\n        \n        self.sensors.update_pwm_duty(channel_id, duty)\n        \n    def read_channel_power(self, channel_id: int) -> Dict[str, float]:\n        \"\"\"\n        Read power telemetry for a channel\n        \n        Returns:\n            Dict with voltage, current, power\n        \"\"\"\n        return self.sensors.read_channel(channel_id)\n        \n    def read_all_power(self) -> Dict[int, Dict[str, float]]:\n        \"\"\"Read power for all channels\"\"\"\n        return {\n            channel_id: self.read_channel_power(channel_id)\n            for channel_id in range(12)\n        }\n        \n    def shutdown_all(self):\n        \"\"\"Emergency shutdown - set all channels to 0%\"\"\"\n        for channel_id in range(12):\n            self.set_channel_pwm(channel_id, 0.0)\n","size_bytes":2297},"app/hardware/sensors.py":{"content":"\"\"\"\nINA219/INA226 Power Sensors - Hardware Abstraction\nSupports both simulated and real power monitoring sensors\n\"\"\"\nimport os\nimport time\nimport random\nimport math\nfrom typing import Dict\n\nHARDWARE_MODE = os.getenv(\"HARDWARE_MODE\", \"sim\")\n\n\nclass INA219Simulated:\n    \"\"\"Simulated INA219 power sensor\"\"\"\n    \n    def __init__(self, address: int, max_expected_amps: float = 2.0):\n        self.address = address\n        self.max_amps = max_expected_amps\n        self.base_voltage = 24.0\n        self.pwm_duty = 0.0\n        self.last_update = time.time()\n        \n    def set_pwm_duty(self, duty: float):\n        \"\"\"Update the PWM duty cycle to calculate realistic power\"\"\"\n        self.pwm_duty = max(0.0, min(1.0, duty))\n        \n    def voltage(self) -> float:\n        \"\"\"Simulate bus voltage with slight variation\"\"\"\n        base_drop = 0.5 * self.pwm_duty\n        noise = random.uniform(-0.1, 0.1)\n        return self.base_voltage - base_drop + noise\n        \n    def current(self) -> float:\n        \"\"\"Simulate current draw based on PWM duty\"\"\"\n        if self.pwm_duty < 0.05:\n            return 0.0\n            \n        base_current = self.max_amps * self.pwm_duty\n        efficiency = 0.85 + 0.1 * self.pwm_duty\n        noise = random.uniform(-0.02, 0.02)\n        \n        return (base_current / efficiency) + noise\n        \n    def power(self) -> float:\n        \"\"\"Calculate power (V * I)\"\"\"\n        return self.voltage() * self.current()\n\n\nclass INA219Real:\n    \"\"\"Real INA219 hardware sensor\"\"\"\n    \n    def __init__(self, address: int, max_expected_amps: float = 2.0):\n        try:\n            from ina219 import INA219\n            self.ina = INA219(shunt_ohms=0.1, max_expected_amps=max_expected_amps, address=address)\n            self.ina.configure(voltage_range=self.ina.RANGE_32V)\n        except ImportError:\n            raise RuntimeError(\"Real hardware libraries not available. Install pi-ina219\")\n            \n    def set_pwm_duty(self, duty: float):\n        \"\"\"No-op for real sensors - they measure actual current draw\"\"\"\n        pass\n            \n    def voltage(self) -> float:\n        \"\"\"Read bus voltage\"\"\"\n        return self.ina.voltage()\n        \n    def current(self) -> float:\n        \"\"\"Read current in amps\"\"\"\n        return self.ina.current() / 1000.0\n        \n    def power(self) -> float:\n        \"\"\"Read power in watts\"\"\"\n        return self.ina.power() / 1000.0\n\n\nclass SensorArray:\n    \"\"\"Manages multiple power sensors\"\"\"\n    \n    def __init__(self, sensor_addresses: Dict[int, int]):\n        \"\"\"\n        Args:\n            sensor_addresses: Dict mapping channel_id to I2C address\n        \"\"\"\n        self.sensors: Dict[int, INA219Simulated | INA219Real] = {}\n        \n        for channel_id, address in sensor_addresses.items():\n            if HARDWARE_MODE == \"pi\":\n                self.sensors[channel_id] = INA219Real(address, max_expected_amps=3.0)\n            else:\n                self.sensors[channel_id] = INA219Simulated(address, max_expected_amps=2.5)\n                \n    def read_channel(self, channel_id: int) -> Dict[str, float]:\n        \"\"\"Read voltage, current, power for a channel\"\"\"\n        if channel_id not in self.sensors:\n            return {\"voltage\": 0.0, \"current\": 0.0, \"power\": 0.0}\n            \n        sensor = self.sensors[channel_id]\n        return {\n            \"voltage\": round(sensor.voltage(), 2),\n            \"current\": round(sensor.current(), 3),\n            \"power\": round(sensor.power(), 2)\n        }\n        \n    def update_pwm_duty(self, channel_id: int, duty: float):\n        \"\"\"Update PWM duty for simulated sensors (no-op for real sensors)\"\"\"\n        if channel_id in self.sensors:\n            self.sensors[channel_id].set_pwm_duty(duty)\n","size_bytes":3719},"app/routers/presets.py":{"content":"from fastapi import APIRouter, HTTPException, Request\nfrom typing import List\nfrom ..models import WavemakerPresetResponse, WavemakerPresetRequest\nfrom ..services.storage import WavemakerPreset\n\nrouter = APIRouter()\n\n\n@router.get('/presets', response_model=List[WavemakerPresetResponse])\nasync def list_presets(request: Request):\n    presets = request.app.state.store.get_all_presets()\n    return [WavemakerPresetResponse(**p.model_dump()) for p in presets]\n\n\n@router.get('/presets/{preset_id}', response_model=WavemakerPresetResponse)\nasync def get_preset(preset_id: int, request: Request):\n    preset = request.app.state.store.get_preset(preset_id)\n    if not preset:\n        raise HTTPException(status_code=404, detail=\"Preset not found\")\n    return WavemakerPresetResponse(**preset.model_dump())\n\n\n@router.post('/presets', response_model=WavemakerPresetResponse)\nasync def create_preset(data: WavemakerPresetRequest, request: Request):\n    preset = WavemakerPreset(\n        name=data.name,\n        description=data.description or \"\",\n        cycle_duration_sec=data.cycle_duration_sec or 60,\n        is_built_in=False,\n        flow_curves=data.flow_curves or {}\n    )\n    created = request.app.state.store.create_preset(preset)\n    return WavemakerPresetResponse(**created.model_dump())\n\n\n@router.put('/presets/{preset_id}', response_model=WavemakerPresetResponse)\nasync def update_preset(preset_id: int, data: WavemakerPresetRequest, request: Request):\n    updates = {}\n    if data.name:\n        updates['name'] = data.name\n    if data.description is not None:\n        updates['description'] = data.description\n    if data.cycle_duration_sec is not None:\n        updates['cycle_duration_sec'] = data.cycle_duration_sec\n    if data.flow_curves is not None:\n        updates['flow_curves'] = data.flow_curves\n    \n    updated = request.app.state.store.update_preset(preset_id, **updates)\n    if not updated:\n        raise HTTPException(status_code=404, detail=\"Preset not found\")\n    return WavemakerPresetResponse(**updated.model_dump())\n\n\n@router.delete('/presets/{preset_id}')\nasync def delete_preset(preset_id: int, request: Request):\n    success = request.app.state.store.delete_preset(preset_id)\n    if not success:\n        raise HTTPException(status_code=404, detail=\"Preset not found or is built-in\")\n    return {\"success\": True}\n\n\n@router.post('/presets/{preset_id}/activate')\nasync def activate_preset(preset_id: int, request: Request):\n    success = request.app.state.preset_manager.set_active_preset(preset_id)\n    if not success:\n        raise HTTPException(status_code=404, detail=\"Preset not found\")\n    return {\"success\": True, \"active_preset_id\": preset_id}\n\n\n@router.get('/presets/active/status')\nasync def get_active_preset_status(request: Request):\n    preset = request.app.state.preset_manager.get_active_preset()\n    if not preset:\n        return {\"active_preset\": None, \"power_levels\": {}}\n    \n    power_levels = request.app.state.preset_manager.get_current_power_levels()\n    \n    return {\n        \"active_preset\": WavemakerPresetResponse(**preset.model_dump()),\n        \"power_levels\": power_levels\n    }\n","size_bytes":3133},"app/services/preset_manager.py":{"content":"import time\nimport math\nfrom typing import Optional, Dict, List\nfrom .storage import WavemakerPreset, Store\n\n\nclass PresetManager:\n    def __init__(self, store: Store):\n        self.store = store\n        self.active_preset_id: Optional[int] = None\n        self.cycle_start_time: float = time.time()\n        self._initialize_built_in_presets()\n    \n    def _initialize_built_in_presets(self):\n        existing = self.store.get_all_presets()\n        if not existing:\n            built_in_presets = [\n                self._create_gentle_preset(),\n                self._create_pulse_preset(),\n                self._create_gyre_cw_preset(),\n                self._create_gyre_ccw_preset(),\n                self._create_feed_mode_preset(),\n                self._create_random_reef_preset(),\n                self._create_sequential_walk_preset(),\n                self._create_knight_rider_preset(),\n                self._create_paired_police_preset()\n            ]\n            \n            for preset in built_in_presets:\n                self.store.create_preset(preset)\n    \n    def _create_gentle_preset(self) -> WavemakerPreset:\n        flow_curves = {}\n        for i in range(1, 13):\n            flow_curves[f\"wavemaker_{i}\"] = [\n                {\"time\": 0, \"power\": 30},\n                {\"time\": 100, \"power\": 30}\n            ]\n        \n        return WavemakerPreset(\n            name=\"Gentle Flow\",\n            description=\"Calm, steady flow for sensitive corals\",\n            cycle_duration_sec=60,\n            is_built_in=True,\n            flow_curves=flow_curves\n        )\n    \n    def _create_pulse_preset(self) -> WavemakerPreset:\n        flow_curves = {}\n        for i in range(1, 13):\n            flow_curves[f\"wavemaker_{i}\"] = [\n                {\"time\": 0, \"power\": 0},\n                {\"time\": 20, \"power\": 100},\n                {\"time\": 50, \"power\": 0},\n                {\"time\": 100, \"power\": 0}\n            ]\n        \n        return WavemakerPreset(\n            name=\"Pulse\",\n            description=\"Short bursts of strong flow\",\n            cycle_duration_sec=10,\n            is_built_in=True,\n            flow_curves=flow_curves\n        )\n    \n    def _create_gyre_cw_preset(self) -> WavemakerPreset:\n        flow_curves = {}\n        phase_offsets = [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330]\n        \n        for i, offset in enumerate(phase_offsets, 1):\n            points = []\n            for t in range(0, 361, 30):\n                phase = (t + offset) % 360\n                power = int(50 + 50 * math.sin(math.radians(phase)))\n                time_pct = (t / 360) * 100\n                points.append({\"time\": round(time_pct, 1), \"power\": power})\n            flow_curves[f\"wavemaker_{i}\"] = points\n        \n        return WavemakerPreset(\n            name=\"Gyre Clockwise\",\n            description=\"Rotating flow pattern, clockwise\",\n            cycle_duration_sec=60,\n            is_built_in=True,\n            flow_curves=flow_curves\n        )\n    \n    def _create_gyre_ccw_preset(self) -> WavemakerPreset:\n        flow_curves = {}\n        phase_offsets = [0, 330, 300, 270, 240, 210, 180, 150, 120, 90, 60, 30]\n        \n        for i, offset in enumerate(phase_offsets, 1):\n            points = []\n            for t in range(0, 361, 30):\n                phase = (t + offset) % 360\n                power = int(50 + 50 * math.sin(math.radians(phase)))\n                time_pct = (t / 360) * 100\n                points.append({\"time\": round(time_pct, 1), \"power\": power})\n            flow_curves[f\"wavemaker_{i}\"] = points\n        \n        return WavemakerPreset(\n            name=\"Gyre Counter-Clockwise\",\n            description=\"Rotating flow pattern, counter-clockwise\",\n            cycle_duration_sec=60,\n            is_built_in=True,\n            flow_curves=flow_curves\n        )\n    \n    def _create_feed_mode_preset(self) -> WavemakerPreset:\n        flow_curves = {}\n        for i in range(1, 13):\n            flow_curves[f\"wavemaker_{i}\"] = [\n                {\"time\": 0, \"power\": 5},\n                {\"time\": 100, \"power\": 5}\n            ]\n        \n        return WavemakerPreset(\n            name=\"Feed Mode\",\n            description=\"Minimal flow for feeding time\",\n            cycle_duration_sec=600,\n            is_built_in=True,\n            flow_curves=flow_curves\n        )\n    \n    def _create_random_reef_preset(self) -> WavemakerPreset:\n        import random\n        random.seed(42)\n        \n        flow_curves = {}\n        for i in range(1, 13):\n            points = [{\"time\": 0, \"power\": random.randint(0, 100)}]\n            for pct in range(8, 108, 8):\n                points.append({\"time\": min(pct, 100), \"power\": random.randint(0, 100)})\n            flow_curves[f\"wavemaker_{i}\"] = points\n        \n        return WavemakerPreset(\n            name=\"Random Reef\",\n            description=\"Chaotic natural reef flow\",\n            cycle_duration_sec=60,\n            is_built_in=True,\n            flow_curves=flow_curves\n        )\n    \n    def _create_sequential_walk_preset(self) -> WavemakerPreset:\n        \"\"\"Single channel walks 1-12 repeatedly\"\"\"\n        flow_curves = {}\n        segment_size = 100 / 12  # Each channel gets 1/12 of the cycle\n        \n        for i in range(1, 13):\n            points = []\n            \n            # Determine which segment this channel is active (0-indexed)\n            active_segment = i - 1  # Channel 1 is active in segment 0, etc.\n            \n            for seg in range(12):\n                start_time = round(seg * segment_size, 1)\n                end_time = round((seg + 1) * segment_size, 1)\n                \n                if seg == active_segment:\n                    # This is the active segment - create plateau at 100%\n                    # First, add a keyframe at start_time with power 0 to prevent ramp-up\n                    if start_time > 0:\n                        points.append({\"time\": start_time, \"power\": 0})\n                    points.append({\"time\": start_time, \"power\": 100})\n                    points.append({\"time\": end_time, \"power\": 100})\n                    # Immediate drop to 0% at end of segment (even if end_time == 100)\n                    points.append({\"time\": end_time, \"power\": 0})\n                elif seg == 0:\n                    # Start of cycle - set initial power\n                    if active_segment == 0:\n                        # Channel 1 starts at 100% immediately\n                        pass\n                    else:\n                        points.append({\"time\": start_time, \"power\": 0})\n            \n            # Ensure we end at 100% with power 0\n            if not any(p[\"time\"] == 100 and p[\"power\"] == 0 for p in points):\n                points.append({\"time\": 100, \"power\": 0})\n            \n            flow_curves[f\"wavemaker_{i}\"] = points\n        \n        return WavemakerPreset(\n            name=\"Sequential Walk\",\n            description=\"Single channel walks 1-12 repeatedly\",\n            cycle_duration_sec=12,\n            is_built_in=True,\n            flow_curves=flow_curves\n        )\n    \n    def _create_knight_rider_preset(self) -> WavemakerPreset:\n        \"\"\"Bouncing pattern 1-12-1 like Knight Rider scanner\"\"\"\n        flow_curves = {}\n        \n        # Pattern: 1,2,3,4,5,6,7,8,9,10,11,12,11,10,9,8,7,6,5,4,3,2 (22 steps)\n        sequence = list(range(1, 13)) + list(range(11, 1, -1))\n        num_steps = len(sequence)\n        segment_size = 100 / num_steps\n        \n        for i in range(1, 13):\n            points = []\n            for step_idx, active_channel in enumerate(sequence):\n                time_pct = step_idx * segment_size\n                power = 100 if active_channel == i else 0\n                points.append({\"time\": round(time_pct, 1), \"power\": power})\n            \n            # Add final point at 100%\n            points.append({\"time\": 100, \"power\": 100 if sequence[0] == i else 0})\n            flow_curves[f\"wavemaker_{i}\"] = points\n        \n        return WavemakerPreset(\n            name=\"Knight Rider\",\n            description=\"Bouncing scanner pattern 1-12-1\",\n            cycle_duration_sec=22,\n            is_built_in=True,\n            flow_curves=flow_curves\n        )\n    \n    def _create_paired_police_preset(self) -> WavemakerPreset:\n        \"\"\"Each pair oscillates like police lights: 1-2, 3-4, 5-6, etc.\"\"\"\n        flow_curves = {}\n        \n        for i in range(1, 13):\n            # Determine which pair this channel belongs to\n            pair_num = (i - 1) // 2  # 0-based pair index\n            is_odd = (i % 2) == 1  # True if channel 1, 3, 5, 7, 9, 11\n            \n            # Create oscillating pattern\n            points = [\n                {\"time\": 0, \"power\": 100 if is_odd else 0},\n                {\"time\": 50, \"power\": 0 if is_odd else 100},\n                {\"time\": 100, \"power\": 100 if is_odd else 0}\n            ]\n            \n            flow_curves[f\"wavemaker_{i}\"] = points\n        \n        return WavemakerPreset(\n            name=\"Paired Police\",\n            description=\"Each pair oscillates independently (1-2, 3-4, 5-6...)\",\n            cycle_duration_sec=2,\n            is_built_in=True,\n            flow_curves=flow_curves\n        )\n    \n    def set_active_preset(self, preset_id: int) -> bool:\n        preset = self.store.get_preset(preset_id)\n        if not preset:\n            return False\n        \n        self.active_preset_id = preset_id\n        self.cycle_start_time = time.time()\n        return True\n    \n    def get_active_preset(self) -> Optional[WavemakerPreset]:\n        if self.active_preset_id is None:\n            return None\n        return self.store.get_preset(self.active_preset_id)\n    \n    def get_current_power_levels(self) -> Dict[int, float]:\n        if self.active_preset_id is None:\n            return {i: 0.0 for i in range(1, 13)}\n        \n        preset = self.store.get_preset(self.active_preset_id)\n        if not preset:\n            return {i: 0.0 for i in range(1, 13)}\n        \n        elapsed = time.time() - self.cycle_start_time\n        position_in_cycle_sec = elapsed % preset.cycle_duration_sec\n        position_in_cycle_pct = (position_in_cycle_sec / preset.cycle_duration_sec) * 100\n        \n        power_levels = {}\n        for i in range(1, 13):\n            wm_key = f\"wavemaker_{i}\"\n            if wm_key in preset.flow_curves:\n                power_levels[i] = self._interpolate_power(\n                    preset.flow_curves[wm_key],\n                    position_in_cycle_pct\n                )\n            else:\n                power_levels[i] = 0.0\n        \n        return power_levels\n    \n    def _interpolate_power(self, curve: List[Dict], time_pos: float) -> float:\n        if not curve:\n            return 0.0\n        \n        curve_sorted = sorted(curve, key=lambda x: x[\"time\"])\n        \n        if time_pos <= curve_sorted[0][\"time\"]:\n            return float(curve_sorted[0][\"power\"])\n        \n        if time_pos >= curve_sorted[-1][\"time\"]:\n            return float(curve_sorted[-1][\"power\"])\n        \n        for i in range(len(curve_sorted) - 1):\n            p1 = curve_sorted[i]\n            p2 = curve_sorted[i + 1]\n            \n            if p1[\"time\"] <= time_pos <= p2[\"time\"]:\n                t_range = p2[\"time\"] - p1[\"time\"]\n                if t_range == 0:\n                    return float(p1[\"power\"])\n                \n                t_ratio = (time_pos - p1[\"time\"]) / t_range\n                power = p1[\"power\"] + t_ratio * (p2[\"power\"] - p1[\"power\"])\n                return float(power)\n        \n        return float(curve_sorted[-1][\"power\"])\n","size_bytes":11557},"app/services/hw_devices.py":{"content":"\"\"\"Device registry for managing hardware PWM devices (wavemakers, LEDs).\"\"\"\n\nimport logging\nimport os\nfrom typing import Dict, Optional\nfrom dataclasses import dataclass\n\n# Determine GPIO driver based on HARDWARE_MODE environment variable\nHARDWARE_MODE = os.getenv(\"HARDWARE_MODE\", \"mock\").lower()\n\nif HARDWARE_MODE == \"esp32\":\n    # ESP32 serial USB adapter\n    try:\n        from app.hw.esp32_serial import PigpioPWM\n        GPIO_MODE = \"ESP32\"\n        logging.info(\"GPIO Mode: ESP32 Serial (USB adapter)\")\n    except ImportError as e:\n        logging.error(f\"Failed to load ESP32 driver: {e}\")\n        from app.hw.gpio_mock import PigpioPWM\n        GPIO_MODE = \"MOCK (ESP32 fallback)\"\n        logging.warning(\"Falling back to MOCK mode\")\nelif HARDWARE_MODE in (\"pi\", \"pigpio\", \"real\"):\n    # Raspberry Pi with pigpio\n    try:\n        import pigpio\n        from app.hw.pigpio_driver import PigpioPWM\n        GPIO_MODE = \"PIGPIO\"\n        logging.info(\"GPIO Mode: PIGPIO (Raspberry Pi)\")\n    except (ImportError, RuntimeError) as e:\n        logging.warning(f\"Pigpio not available: {e}\")\n        from app.hw.gpio_mock import PigpioPWM\n        GPIO_MODE = \"MOCK (pigpio fallback)\"\nelse:\n    # Default to mock/simulation\n    from app.hw.gpio_mock import PigpioPWM\n    GPIO_MODE = \"MOCK\"\n    logging.info(\"GPIO Mode: MOCK (simulation)\")\n\nlogging.info(f\"GPIO Driver loaded: {GPIO_MODE}\")\n\n\n@dataclass\nclass DeviceConfig:\n    \"\"\"Configuration for a PWM device.\"\"\"\n    name: str\n    gpio_pin: int\n    pwm_freq_hz: int\n    min_intensity: float = 0.0\n    max_intensity: float = 1.0\n    volts_min: float = 0.0\n    volts_max: float = 5.0\n    gpio_pin_monitor: Optional[int] = None\n    channel_name: Optional[str] = None\n\n\nclass PWMDevice:\n    \"\"\"Represents a single PWM-controlled device (wavemaker or LED).\"\"\"\n    \n    def __init__(self, config: DeviceConfig):\n        \"\"\"\n        Initialize PWM device.\n        \n        Args:\n            config: Device configuration\n        \"\"\"\n        self.config = config\n        self.hw = PigpioPWM(config.gpio_pin, config.pwm_freq_hz)\n        self.current_duty = 0.0\n        \n        logging.info(\n            f\"Initialized {config.name} on GPIO{config.gpio_pin} \"\n            f\"({config.pwm_freq_hz}Hz, range {config.min_intensity:.2f}-{config.max_intensity:.2f})\"\n        )\n    \n    def apply(self, intensity: float) -> None:\n        \"\"\"\n        Apply intensity value to device.\n        \n        Args:\n            intensity: Target intensity [0.0-1.0]\n        \"\"\"\n        # Clamp to [0, 1]\n        intensity = max(0.0, min(1.0, intensity))\n        \n        # Map to [min_intensity, max_intensity] range\n        scaled = self.config.min_intensity + intensity * (\n            self.config.max_intensity - self.config.min_intensity\n        )\n        \n        self.hw.set_duty(scaled)\n        self.current_duty = scaled\n    \n    def set_frequency(self, freq_hz: int) -> None:\n        \"\"\"Update PWM frequency.\"\"\"\n        self.config.pwm_freq_hz = freq_hz\n        self.hw.set_frequency(freq_hz)\n    \n    def set_range(self, min_intensity: float, max_intensity: float) -> None:\n        \"\"\"Update intensity range.\"\"\"\n        self.config.min_intensity = min_intensity\n        self.config.max_intensity = max_intensity\n    \n    def stop(self) -> None:\n        \"\"\"Stop device output.\"\"\"\n        self.hw.stop()\n        self.current_duty = 0.0\n    \n    def cleanup(self) -> None:\n        \"\"\"Clean up hardware resources.\"\"\"\n        try:\n            self.hw.stop()\n            if hasattr(self.hw, 'cleanup'):\n                self.hw.cleanup()\n        except Exception as e:\n            logging.error(f\"Error during cleanup of {self.config.name}: {e}\")\n        self.current_duty = 0.0\n    \n    def get_voltage(self) -> float:\n        \"\"\"Calculate approximate output voltage based on current duty.\"\"\"\n        return self.config.volts_min + self.current_duty * (\n            self.config.volts_max - self.config.volts_min\n        )\n    \n    def to_dict(self) -> dict:\n        \"\"\"Export device state as dictionary.\"\"\"\n        return {\n            \"name\": self.config.name,\n            \"gpio_pin\": self.config.gpio_pin,\n            \"pwm_freq_hz\": self.config.pwm_freq_hz,\n            \"min_intensity\": self.config.min_intensity,\n            \"max_intensity\": self.config.max_intensity,\n            \"volts_min\": self.config.volts_min,\n            \"volts_max\": self.config.volts_max,\n            \"gpio_pin_monitor\": self.config.gpio_pin_monitor,\n            \"channel_name\": self.config.channel_name,\n            \"current_duty\": self.current_duty,\n            \"current_voltage\": self.get_voltage(),\n        }\n\n\nclass DeviceRegistry:\n    \"\"\"Central registry for all PWM devices.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize empty registry.\"\"\"\n        self.wavemakers: Dict[str, PWMDevice] = {}\n        self.leds: Dict[str, PWMDevice] = {}\n        self.mode = GPIO_MODE\n    \n    def _get_gpio_map(self, exclude_device_id: Optional[str] = None) -> Dict[int, str]:\n        \"\"\"\n        Get map of GPIO pins to device IDs currently in use.\n        \n        Args:\n            exclude_device_id: Optionally exclude a device (for reload scenarios)\n            \n        Returns:\n            Dict mapping GPIO pin numbers to device IDs\n        \"\"\"\n        gpio_map: Dict[int, str] = {}\n        \n        for device_id, device in self.wavemakers.items():\n            if device_id != exclude_device_id:\n                gpio_map[device.config.gpio_pin] = device_id\n                if device.config.gpio_pin_monitor is not None:\n                    gpio_map[device.config.gpio_pin_monitor] = f\"{device_id} (monitor)\"\n        \n        for device_id, device in self.leds.items():\n            if device_id != exclude_device_id:\n                gpio_map[device.config.gpio_pin] = device_id\n                if device.config.gpio_pin_monitor is not None:\n                    gpio_map[device.config.gpio_pin_monitor] = f\"{device_id} (monitor)\"\n        \n        return gpio_map\n    \n    def _check_gpio_conflict(self, config: DeviceConfig, exclude_device_id: Optional[str] = None) -> Optional[str]:\n        \"\"\"\n        Check if config's GPIO pins conflict with existing devices.\n        \n        Args:\n            config: Device configuration to check\n            exclude_device_id: Optionally exclude a device (for reload scenarios)\n            \n        Returns:\n            Conflict message if conflict found, None otherwise\n        \"\"\"\n        gpio_map = self._get_gpio_map(exclude_device_id)\n        \n        if config.gpio_pin in gpio_map:\n            return f\"GPIO {config.gpio_pin} already in use by {gpio_map[config.gpio_pin]}\"\n        \n        if config.gpio_pin_monitor is not None and config.gpio_pin_monitor in gpio_map:\n            return f\"GPIO {config.gpio_pin_monitor} (monitor) already in use by {gpio_map[config.gpio_pin_monitor]}\"\n        \n        return None\n    \n    def register_wavemaker(self, device_id: str, config: DeviceConfig) -> PWMDevice:\n        \"\"\"\n        Register a wavemaker device.\n        \n        Args:\n            device_id: Unique identifier (e.g., \"WM1\")\n            config: Device configuration\n            \n        Returns:\n            Created PWMDevice instance\n            \n        Raises:\n            ValueError: If GPIO pin is already in use by another device\n        \"\"\"\n        conflict = self._check_gpio_conflict(config)\n        if conflict:\n            logging.error(f\"Cannot register wavemaker {device_id}: {conflict}\")\n            raise ValueError(f\"Cannot register wavemaker {device_id}: {conflict}\")\n        \n        device = PWMDevice(config)\n        self.wavemakers[device_id] = device\n        logging.info(f\"Registered wavemaker {device_id}\")\n        return device\n    \n    def register_led(self, device_id: str, config: DeviceConfig) -> PWMDevice:\n        \"\"\"\n        Register an LED device.\n        \n        Args:\n            device_id: Unique identifier (e.g., \"LED1\")\n            config: Device configuration\n            \n        Returns:\n            Created PWMDevice instance\n            \n        Raises:\n            ValueError: If GPIO pin is already in use by another device\n        \"\"\"\n        conflict = self._check_gpio_conflict(config)\n        if conflict:\n            logging.error(f\"Cannot register LED {device_id}: {conflict}\")\n            raise ValueError(f\"Cannot register LED {device_id}: {conflict}\")\n        \n        device = PWMDevice(config)\n        self.leds[device_id] = device\n        logging.info(f\"Registered LED {device_id}\")\n        return device\n    \n    def get_wavemaker(self, device_id: str) -> Optional[PWMDevice]:\n        \"\"\"Get wavemaker device by ID.\"\"\"\n        return self.wavemakers.get(device_id)\n    \n    def get_led(self, device_id: str) -> Optional[PWMDevice]:\n        \"\"\"Get LED device by ID.\"\"\"\n        return self.leds.get(device_id)\n    \n    def stop_all(self) -> None:\n        \"\"\"Emergency stop - zero all outputs.\"\"\"\n        logging.warning(\"EMERGENCY STOP - Zeroing all device outputs\")\n        for device in list(self.wavemakers.values()) + list(self.leds.values()):\n            device.stop()\n    \n    def get_all_states(self) -> dict:\n        \"\"\"Get current state of all devices.\"\"\"\n        return {\n            \"mode\": self.mode,\n            \"wavemakers\": {\n                device_id: device.to_dict()\n                for device_id, device in self.wavemakers.items()\n            },\n            \"leds\": {\n                device_id: device.to_dict()\n                for device_id, device in self.leds.items()\n            },\n        }\n    \n    def unregister_device(self, device_id: str) -> bool:\n        \"\"\"\n        Unregister a device, stopping output and cleaning up resources.\n        \n        Args:\n            device_id: Device identifier\n            \n        Returns:\n            True if device was found and unregistered, False otherwise\n        \"\"\"\n        # Try wavemakers first\n        device = self.wavemakers.get(device_id)\n        if device:\n            device.stop()\n            device.cleanup()\n            del self.wavemakers[device_id]\n            logging.info(f\"Unregistered wavemaker {device_id}\")\n            return True\n        \n        # Try LEDs\n        device = self.leds.get(device_id)\n        if device:\n            device.stop()\n            device.cleanup()\n            del self.leds[device_id]\n            logging.info(f\"Unregistered LED {device_id}\")\n            return True\n        \n        logging.warning(f\"Device {device_id} not found in registry\")\n        return False\n    \n    def update_device_config(self, device_id: str, config: DeviceConfig, device_type: str) -> bool:\n        \"\"\"\n        Update device configuration in-place without hardware re-initialization.\n        \n        Use this for intensity/voltage range changes that don't require GPIO changes.\n        \n        Args:\n            device_id: Device identifier\n            config: New device configuration\n            device_type: 'WAVEMAKER' or 'LED'\n            \n        Returns:\n            True if device was found and updated\n        \"\"\"\n        if device_type == 'WAVEMAKER':\n            device = self.wavemakers.get(device_id)\n        else:\n            device = self.leds.get(device_id)\n        \n        if not device:\n            logging.warning(f\"Device {device_id} not found for config update\")\n            return False\n        \n        # Update config parameters in-place\n        device.config.name = config.name\n        device.config.min_intensity = config.min_intensity\n        device.config.max_intensity = config.max_intensity\n        device.config.volts_min = config.volts_min\n        device.config.volts_max = config.volts_max\n        device.config.gpio_pin_monitor = config.gpio_pin_monitor\n        device.config.channel_name = config.channel_name\n        \n        # Update PWM frequency if it changed (doesn't require re-init)\n        if device.config.pwm_freq_hz != config.pwm_freq_hz:\n            device.set_frequency(config.pwm_freq_hz)\n        \n        logging.info(f\"Updated {device_id} config in-place: range {config.min_intensity:.2f}-{config.max_intensity:.2f}\")\n        return True\n    \n    def reload_device(self, device_id: str, config: DeviceConfig, device_type: str) -> PWMDevice:\n        \"\"\"\n        Reload a device with new configuration (hot-reload for GPIO pin changes).\n        \n        Args:\n            device_id: Device identifier\n            config: New device configuration\n            device_type: 'WAVEMAKER' or 'LED'\n            \n        Returns:\n            Reloaded PWMDevice instance\n            \n        Raises:\n            ValueError: If new GPIO pin conflicts with another device\n        \"\"\"\n        # Check for GPIO conflicts (exclude self since we're reloading)\n        conflict = self._check_gpio_conflict(config, exclude_device_id=device_id)\n        if conflict:\n            logging.error(f\"Cannot reload {device_id}: {conflict}\")\n            raise ValueError(f\"Cannot reload {device_id}: {conflict}\")\n        \n        # Clean up old device\n        if device_type == 'WAVEMAKER':\n            old_device = self.wavemakers.get(device_id)\n            if old_device:\n                old_device.stop()\n                old_device.cleanup()\n                logging.info(f\"Cleaned up old wavemaker {device_id}\")\n        else:\n            old_device = self.leds.get(device_id)\n            if old_device:\n                old_device.stop()\n                old_device.cleanup()\n                logging.info(f\"Cleaned up old LED {device_id}\")\n        \n        # Create new device with updated config\n        new_device = PWMDevice(config)\n        \n        if device_type == 'WAVEMAKER':\n            self.wavemakers[device_id] = new_device\n            logging.info(f\"Reloaded wavemaker {device_id} on GPIO{config.gpio_pin}\")\n        else:\n            self.leds[device_id] = new_device\n            logging.info(f\"Reloaded LED {device_id} on GPIO{config.gpio_pin}\")\n        \n        return new_device\n\n\n# Global registry instance\nregistry = DeviceRegistry()\n","size_bytes":13994},"app/routers/hardware.py":{"content":"\"\"\"API endpoints for hardware device control.\"\"\"\n\nimport logging\nfrom fastapi import APIRouter, HTTPException, Request\nfrom pydantic import BaseModel, Field\nfrom typing import Literal, Optional\n\nfrom app.services.hw_devices import registry as device_registry, DeviceConfig\nfrom app.services.hw_patterns import pattern_registry, PatternConfig, PatternMode\nfrom app.hw_scheduler.realtime_loop import (\n    set_manual_mode,\n    set_led_follow,\n    get_control_state,\n    manual_devices,\n)\n\n\nrouter = APIRouter()\n\n\n# Request models\nclass DeviceSettingsUpdate(BaseModel):\n    \"\"\"Update device hardware settings.\"\"\"\n    gpio_pin: Optional[int] = Field(None, ge=0, le=27, description=\"BCM GPIO pin number\")\n    pwm_freq_hz: Optional[int] = Field(None, ge=50, le=10000, description=\"PWM frequency in Hz\")\n    min_intensity: Optional[float] = Field(None, ge=0.0, le=1.0)\n    max_intensity: Optional[float] = Field(None, ge=0.0, le=1.0)\n    volts_min: Optional[float] = Field(None, ge=0.0, le=10.0)\n    volts_max: Optional[float] = Field(None, ge=0.0, le=10.0)\n\n\nclass PatternUpdate(BaseModel):\n    \"\"\"Update device pattern.\"\"\"\n    mode: PatternMode\n    period_s: Optional[float] = Field(5.0, ge=0.1, le=60.0)\n    on_ratio: Optional[float] = Field(0.5, ge=0.0, le=1.0)\n    phase_deg: Optional[float] = Field(0.0, ge=0.0, le=360.0)\n    min_intensity: Optional[float] = Field(0.0, ge=0.0, le=1.0)\n    max_intensity: Optional[float] = Field(1.0, ge=0.0, le=1.0)\n\n\nclass ManualControl(BaseModel):\n    \"\"\"Manual control request.\"\"\"\n    duty: float = Field(..., ge=0.0, le=1.0, description=\"Manual duty cycle\")\n\n\nclass ModeSwitch(BaseModel):\n    \"\"\"Mode switch request.\"\"\"\n    manual: bool = Field(..., description=\"True for manual mode, False for automatic\")\n\n\nclass LEDFollowConfig(BaseModel):\n    \"\"\"LED follow configuration.\"\"\"\n    wavemaker_id: Optional[str] = Field(None, description=\"Wavemaker ID to follow, null to disable\")\n\n\n# Endpoints\n\n@router.get(\"/hardware/status\")\nasync def get_hardware_status():\n    \"\"\"Get overall hardware and control status.\"\"\"\n    return {\n        \"devices\": device_registry.get_all_states(),\n        \"control\": get_control_state(),\n    }\n\n\n@router.post(\"/hardware/emergency_stop\")\nasync def emergency_stop():\n    \"\"\"Emergency stop - zero all device outputs.\"\"\"\n    device_registry.stop_all()\n    return {\"status\": \"all devices stopped\"}\n\n\n@router.get(\"/hardware/wavemakers/{device_id}\")\nasync def get_wavemaker_status(device_id: str):\n    \"\"\"Get status of specific wavemaker.\"\"\"\n    device = device_registry.get_wavemaker(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"Wavemaker {device_id} not found\")\n    \n    pattern = pattern_registry.get_pattern(device_id)\n    is_manual = device_id in manual_devices\n    \n    return {\n        \"device\": device.to_dict(),\n        \"pattern\": {\n            \"mode\": pattern.config.mode if pattern else \"OFF\",\n            \"config\": vars(pattern.config) if pattern else None,\n        } if pattern else None,\n        \"manual_mode\": is_manual,\n    }\n\n\n@router.post(\"/hardware/wavemakers/{device_id}/settings\")\nasync def update_wavemaker_settings(device_id: str, settings: DeviceSettingsUpdate):\n    \"\"\"Update wavemaker hardware settings (GPIO pin, PWM freq, voltage range).\"\"\"\n    device = device_registry.get_wavemaker(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"Wavemaker {device_id} not found\")\n    \n    # Apply updates\n    if settings.pwm_freq_hz is not None:\n        device.set_frequency(settings.pwm_freq_hz)\n    \n    if settings.min_intensity is not None and settings.max_intensity is not None:\n        if settings.min_intensity >= settings.max_intensity:\n            raise HTTPException(status_code=400, detail=\"min_intensity must be < max_intensity\")\n        device.set_range(settings.min_intensity, settings.max_intensity)\n    \n    if settings.volts_min is not None:\n        device.config.volts_min = settings.volts_min\n    \n    if settings.volts_max is not None:\n        device.config.volts_max = settings.volts_max\n    \n    # Note: GPIO pin change requires device restart (not supported dynamically)\n    if settings.gpio_pin is not None:\n        logging.warning(f\"GPIO pin change requested for {device_id} but requires restart\")\n        return {\n            \"status\": \"partial_update\",\n            \"message\": \"GPIO pin change requires device restart\",\n            \"device\": device.to_dict()\n        }\n    \n    return {\"status\": \"updated\", \"device\": device.to_dict()}\n\n\n@router.post(\"/hardware/wavemakers/{device_id}/pattern\")\nasync def update_wavemaker_pattern(device_id: str, pattern_update: PatternUpdate):\n    \"\"\"Update wavemaker pattern configuration.\"\"\"\n    device = device_registry.get_wavemaker(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"Wavemaker {device_id} not found\")\n    \n    # Create pattern config\n    pattern_config = PatternConfig(\n        mode=pattern_update.mode,\n        period_s=pattern_update.period_s if pattern_update.period_s is not None else 5.0,\n        on_ratio=pattern_update.on_ratio if pattern_update.on_ratio is not None else 0.5,\n        phase_deg=pattern_update.phase_deg if pattern_update.phase_deg is not None else 0.0,\n        min_intensity=pattern_update.min_intensity if pattern_update.min_intensity is not None else 0.0,\n        max_intensity=pattern_update.max_intensity if pattern_update.max_intensity is not None else 1.0,\n    )\n    \n    # Update pattern\n    pattern_registry.create_pattern(device_id, pattern_config)\n    \n    return {\n        \"status\": \"pattern_updated\",\n        \"device_id\": device_id,\n        \"pattern\": vars(pattern_config),\n    }\n\n\n@router.post(\"/hardware/wavemakers/{device_id}/mode\")\nasync def set_wavemaker_mode(device_id: str, mode: ModeSwitch):\n    \"\"\"Switch between manual and automatic (pattern) mode.\"\"\"\n    device = device_registry.get_wavemaker(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"Wavemaker {device_id} not found\")\n    \n    set_manual_mode(device_id, mode.manual)\n    \n    return {\n        \"status\": \"mode_updated\",\n        \"device_id\": device_id,\n        \"manual_mode\": mode.manual,\n    }\n\n\n@router.post(\"/hardware/wavemakers/{device_id}/manual\")\nasync def set_wavemaker_manual_duty(device_id: str, control: ManualControl):\n    \"\"\"Set manual duty cycle (only works in manual mode).\"\"\"\n    device = device_registry.get_wavemaker(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"Wavemaker {device_id} not found\")\n    \n    if device_id not in manual_devices:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Device {device_id} not in manual mode. Switch to manual mode first.\"\n        )\n    \n    device.apply(control.duty)\n    \n    return {\n        \"status\": \"duty_set\",\n        \"device_id\": device_id,\n        \"duty\": control.duty,\n        \"voltage\": device.get_voltage(),\n    }\n\n\n# LED endpoints\n\n@router.get(\"/hardware/leds/{device_id}\")\nasync def get_led_status(device_id: str):\n    \"\"\"Get status of specific LED.\"\"\"\n    device = device_registry.get_led(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"LED {device_id} not found\")\n    \n    is_manual = device_id in manual_devices\n    \n    from app.hw_scheduler.realtime_loop import led_follow_map\n    following = led_follow_map.get(device_id)\n    \n    return {\n        \"device\": device.to_dict(),\n        \"manual_mode\": is_manual,\n        \"following\": following,\n    }\n\n\n@router.post(\"/hardware/leds/{device_id}/follow\")\nasync def set_led_follow_mode(device_id: str, config: LEDFollowConfig):\n    \"\"\"Configure LED to follow a wavemaker's pattern.\"\"\"\n    device = device_registry.get_led(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"LED {device_id} not found\")\n    \n    # Verify wavemaker exists if specified\n    if config.wavemaker_id:\n        wm_device = device_registry.get_wavemaker(config.wavemaker_id)\n        if not wm_device:\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Wavemaker {config.wavemaker_id} not found\"\n            )\n    \n    set_led_follow(device_id, config.wavemaker_id)\n    \n    # If following, take LED out of manual mode\n    if config.wavemaker_id:\n        set_manual_mode(device_id, False)\n    \n    return {\n        \"status\": \"follow_configured\",\n        \"led_id\": device_id,\n        \"following\": config.wavemaker_id,\n    }\n\n\n@router.post(\"/hardware/leds/{device_id}/mode\")\nasync def set_led_mode(device_id: str, mode: ModeSwitch):\n    \"\"\"Switch LED between manual and automatic mode.\"\"\"\n    device = device_registry.get_led(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"LED {device_id} not found\")\n    \n    set_manual_mode(device_id, mode.manual)\n    \n    return {\n        \"status\": \"mode_updated\",\n        \"device_id\": device_id,\n        \"manual_mode\": mode.manual,\n    }\n\n\n@router.post(\"/hardware/leds/{device_id}/manual\")\nasync def set_led_manual_duty(device_id: str, control: ManualControl):\n    \"\"\"Set manual LED brightness (only works in manual mode).\"\"\"\n    device = device_registry.get_led(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"LED {device_id} not found\")\n    \n    if device_id not in manual_devices:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"LED {device_id} not in manual mode. Switch to manual mode first.\"\n        )\n    \n    device.apply(control.duty)\n    \n    return {\n        \"status\": \"duty_set\",\n        \"device_id\": device_id,\n        \"duty\": control.duty,\n        \"voltage\": device.get_voltage(),\n    }\n","size_bytes":9708},"app/hw/__init__.py":{"content":"\"\"\"Hardware abstraction layer for GPIO/PWM control.\"\"\"\n","size_bytes":55},"app/hw_scheduler/__init__.py":{"content":"\"\"\"Hardware control scheduler.\"\"\"\n","size_bytes":34},"app/hw_scheduler/realtime_loop.py":{"content":"\"\"\"Real-time control loop for GPIO/PWM devices.\"\"\"\n\nimport logging\nimport time\nfrom typing import Dict, Set, Optional\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\n\nfrom app.services.hw_devices import registry as device_registry\nfrom app.services.hw_patterns import pattern_registry\n\n\n# LED follow mappings (LED_ID -> WAVEMAKER_ID)\nled_follow_map: Dict[str, str] = {}\n\n# Devices in manual mode (don't apply patterns)\nmanual_devices: Set[str] = set()\n\n# Reference to PresetManager (set during startup)\npreset_manager_ref: Optional[object] = None\n\n\nasync def realtime_tick():\n    \"\"\"\n    Real-time control loop - runs at 10-20Hz.\n    \n    Evaluates patterns and applies to hardware devices.\n    Priority: Preset power levels > Pattern values\n    \"\"\"\n    try:\n        current_time = time.time()\n        \n        # Check if we have an active preset - if so, use preset power levels\n        # PresetManager returns Dict[int, float] with keys 1-6 and values 0-100\n        preset_power_levels = {}\n        preset_active = False\n        if preset_manager_ref is not None:\n            try:\n                levels = preset_manager_ref.get_current_power_levels()\n                if levels and any(v > 0 for v in levels.values()):\n                    preset_power_levels = levels\n                    preset_active = True\n            except Exception as e:\n                logging.debug(f\"Could not get preset power levels: {e}\")\n        \n        # Get all pattern values at current time (fallback when no preset)\n        pattern_values = pattern_registry.get_all_values(current_time)\n        \n        # Apply to all registered wavemakers (not hard-coded range)\n        for device_id in list(device_registry.wavemakers.keys()):\n            if device_id in manual_devices:\n                continue\n            \n            # Extract wavemaker number from device ID (e.g., \"WM1\" -> 1)\n            try:\n                wm_num = int(device_id.replace(\"WM\", \"\"))\n            except (ValueError, AttributeError):\n                logging.warning(f\"Could not extract wavemaker number from device ID: {device_id}\")\n                continue\n            \n            # Priority: preset power > pattern value > skip\n            intensity = None\n            if preset_active and wm_num in preset_power_levels:\n                # Preset power levels are 0-100, convert to 0.0-1.0\n                intensity = preset_power_levels[wm_num] / 100.0\n            elif device_id in pattern_values:\n                intensity = pattern_values[device_id]\n            \n            if intensity is not None:\n                device = device_registry.get_wavemaker(device_id)\n                if device:\n                    device.apply(intensity)\n        \n        # Apply LED follow mappings\n        for led_id, wavemaker_id in led_follow_map.items():\n            if led_id in manual_devices:\n                continue\n            \n            # Extract wavemaker number from device ID\n            try:\n                wm_num = int(wavemaker_id.replace(\"WM\", \"\"))\n            except (ValueError, AttributeError):\n                logging.warning(f\"Could not extract wavemaker number from {wavemaker_id}\")\n                continue\n            \n            # Get intensity using same priority logic\n            intensity = None\n            if preset_active and wm_num in preset_power_levels:\n                intensity = preset_power_levels[wm_num] / 100.0\n            elif wavemaker_id in pattern_values:\n                intensity = pattern_values[wavemaker_id]\n            \n            if intensity is not None:\n                led_device = device_registry.get_led(led_id)\n                if led_device:\n                    led_device.apply(intensity)\n    \n    except Exception as e:\n        logging.error(f\"Error in realtime tick: {e}\", exc_info=True)\n\n\n# APScheduler instance\nhw_scheduler = AsyncIOScheduler()\n\n\ndef start_hw_scheduler():\n    \"\"\"Start the hardware control scheduler.\"\"\"\n    if hw_scheduler.running:\n        logging.warning(\"Hardware scheduler already running\")\n        return\n    \n    # Add real-time control job at 20Hz (50ms interval)\n    hw_scheduler.add_job(\n        realtime_tick,\n        \"interval\",\n        seconds=0.05,  # 20Hz\n        id=\"realtime_control\",\n        replace_existing=True\n    )\n    \n    hw_scheduler.start()\n    logging.info(\"Hardware scheduler started at 20Hz\")\n\n\ndef stop_hw_scheduler():\n    \"\"\"Stop the hardware scheduler.\"\"\"\n    if hw_scheduler.running:\n        hw_scheduler.shutdown()\n        logging.info(\"Hardware scheduler stopped\")\n\n\ndef set_manual_mode(device_id: str, manual: bool):\n    \"\"\"\n    Set device to manual or automatic (pattern) mode.\n    \n    Args:\n        device_id: Device identifier\n        manual: True for manual mode, False for automatic\n    \"\"\"\n    if manual:\n        manual_devices.add(device_id)\n        logging.info(f\"{device_id} set to MANUAL mode\")\n    else:\n        manual_devices.discard(device_id)\n        logging.info(f\"{device_id} set to AUTOMATIC mode\")\n\n\ndef set_led_follow(led_id: str, wavemaker_id: str | None):\n    \"\"\"\n    Configure LED to follow a wavemaker's pattern.\n    \n    Args:\n        led_id: LED device identifier\n        wavemaker_id: Wavemaker to follow, or None to disable following\n    \"\"\"\n    if wavemaker_id is None:\n        if led_id in led_follow_map:\n            del led_follow_map[led_id]\n        logging.info(f\"{led_id} no longer following wavemaker\")\n    else:\n        led_follow_map[led_id] = wavemaker_id\n        logging.info(f\"{led_id} now follows {wavemaker_id}\")\n\n\ndef set_preset_manager(preset_manager):\n    \"\"\"\n    Link PresetManager to hardware control loop.\n    \n    Args:\n        preset_manager: PresetManager instance\n    \"\"\"\n    global preset_manager_ref\n    preset_manager_ref = preset_manager\n    logging.info(\"PresetManager linked to hardware control loop\")\n\n\ndef get_control_state() -> dict:\n    \"\"\"Get current state of control system.\"\"\"\n    return {\n        \"scheduler_running\": hw_scheduler.running,\n        \"manual_devices\": list(manual_devices),\n        \"led_follow_map\": dict(led_follow_map),\n        \"gpio_mode\": device_registry.mode,\n        \"preset_linked\": preset_manager_ref is not None,\n    }\n","size_bytes":6197},"app/hw/gpio_iface.py":{"content":"\"\"\"GPIO/PWM interface protocol definitions.\"\"\"\n\nfrom typing import Protocol\n\n\nclass PWMChannel(Protocol):\n    \"\"\"Protocol for PWM channel control.\"\"\"\n    \n    def start(self, duty: float) -> None:\n        \"\"\"Start PWM with given duty cycle (0.0-1.0).\"\"\"\n        ...\n    \n    def set_frequency(self, hz: int) -> None:\n        \"\"\"Set PWM frequency in Hz.\"\"\"\n        ...\n    \n    def set_duty(self, duty: float) -> None:\n        \"\"\"Set duty cycle (0.0-1.0).\"\"\"\n        ...\n    \n    def stop(self) -> None:\n        \"\"\"Stop PWM output (set to 0).\"\"\"\n        ...\n","size_bytes":557},"app/hw/gpio_mock.py":{"content":"\"\"\"Mock GPIO driver for development/testing without hardware.\"\"\"\n\nimport logging\nfrom typing import Dict\n\n\nclass PigpioPWM:\n    \"\"\"Mock PWM channel for development without Raspberry Pi.\"\"\"\n    \n    _instances: Dict[int, 'PigpioPWM'] = {}\n    \n    def __init__(self, pin: int, freq: int = 500):\n        \"\"\"\n        Initialize mock PWM on a virtual pin.\n        \n        Args:\n            pin: Virtual GPIO pin number\n            freq: PWM frequency in Hz\n        \"\"\"\n        self.pin = pin\n        self.freq = freq\n        self.duty = 0.0\n        self.running = False\n        \n        PigpioPWM._instances[pin] = self\n        logging.info(f\"[MOCK] Initialized virtual PWM on GPIO{pin} at {freq}Hz\")\n    \n    def set_frequency(self, hz: int) -> None:\n        \"\"\"Set PWM frequency in Hz.\"\"\"\n        old_freq = self.freq\n        self.freq = hz\n        logging.debug(f\"[MOCK] GPIO{self.pin} frequency changed: {old_freq}Hz â†’ {hz}Hz\")\n    \n    def set_duty(self, duty: float) -> None:\n        \"\"\"Set duty cycle (0.0-1.0).\"\"\"\n        duty = max(0.0, min(1.0, duty))\n        if abs(self.duty - duty) > 0.01:  # Log significant changes only\n            logging.debug(f\"[MOCK] GPIO{self.pin} duty: {self.duty:.2%} â†’ {duty:.2%}\")\n        self.duty = duty\n        self.running = (duty > 0)\n    \n    def start(self, duty: float = 0.0) -> None:\n        \"\"\"Start PWM with given duty cycle.\"\"\"\n        self.running = True\n        self.set_duty(duty)\n        logging.info(f\"[MOCK] Started PWM on GPIO{self.pin} at {duty:.2%}\")\n    \n    def stop(self) -> None:\n        \"\"\"Stop PWM output.\"\"\"\n        self.running = False\n        self.duty = 0.0\n        logging.info(f\"[MOCK] Stopped PWM on GPIO{self.pin}\")\n    \n    def cleanup(self) -> None:\n        \"\"\"Cleanup resources.\"\"\"\n        self.stop()\n        if self.pin in PigpioPWM._instances:\n            del PigpioPWM._instances[self.pin]\n    \n    @classmethod\n    def get_all_states(cls) -> Dict[int, dict]:\n        \"\"\"Get current state of all mock PWM channels (for debugging).\"\"\"\n        return {\n            pin: {\n                \"duty\": inst.duty,\n                \"freq\": inst.freq,\n                \"running\": inst.running\n            }\n            for pin, inst in cls._instances.items()\n        }\n","size_bytes":2240},"app/hw/pigpio_driver.py":{"content":"\"\"\"Real Raspberry Pi GPIO driver using pigpio library.\"\"\"\n\nimport logging\n\ntry:\n    import pigpio\n    PIGPIO_AVAILABLE = True\nexcept ImportError:\n    PIGPIO_AVAILABLE = False\n    logging.warning(\"pigpio not available - using mock GPIO\")\n\n\nclass PigpioPWM:\n    \"\"\"PWM control using pigpio library for Raspberry Pi.\"\"\"\n    \n    def __init__(self, pin: int, freq: int = 500):\n        \"\"\"\n        Initialize PWM on a GPIO pin.\n        \n        Args:\n            pin: BCM GPIO pin number\n            freq: PWM frequency in Hz\n        \"\"\"\n        if not PIGPIO_AVAILABLE:\n            raise ImportError(\"pigpio library not available\")\n            \n        self.pin = pin\n        self.freq = freq\n        self.pi = pigpio.pi()\n        \n        if not self.pi.connected:\n            raise RuntimeError(f\"Failed to connect to pigpiod daemon\")\n        \n        self.pi.set_mode(pin, pigpio.OUTPUT)\n        self.set_frequency(freq)\n        self.set_duty(0.0)\n        \n        logging.info(f\"Initialized pigpio PWM on GPIO{pin} at {freq}Hz\")\n    \n    def set_frequency(self, hz: int) -> None:\n        \"\"\"Set PWM frequency in Hz.\"\"\"\n        self.freq = hz\n        self.pi.set_PWM_frequency(self.pin, hz)\n    \n    def set_duty(self, duty: float) -> None:\n        \"\"\"\n        Set duty cycle.\n        \n        Args:\n            duty: Duty cycle from 0.0 (0%) to 1.0 (100%)\n        \"\"\"\n        duty = max(0.0, min(1.0, duty))\n        # pigpio uses 0-255 range for duty cycle\n        self.pi.set_PWM_dutycycle(self.pin, int(duty * 255))\n    \n    def start(self, duty: float = 0.0) -> None:\n        \"\"\"Start PWM with given duty cycle.\"\"\"\n        self.set_duty(duty)\n    \n    def stop(self) -> None:\n        \"\"\"Stop PWM output.\"\"\"\n        self.pi.set_PWM_dutycycle(self.pin, 0)\n    \n    def cleanup(self) -> None:\n        \"\"\"Cleanup GPIO resources.\"\"\"\n        self.stop()\n        self.pi.stop()\n","size_bytes":1874},"app/services/hw_patterns.py":{"content":"\"\"\"Real-time pattern engine for wavemaker control.\"\"\"\n\nimport math\nimport time\nimport logging\nfrom typing import Dict, Optional, Literal\nfrom dataclasses import dataclass\n\n\nPatternMode = Literal[\"OFF\", \"CONSTANT\", \"PULSE\", \"GYRE\", \"RANDOM\"]\n\n\n@dataclass\nclass PatternConfig:\n    \"\"\"Configuration for a pattern.\"\"\"\n    mode: PatternMode = \"CONSTANT\"\n    period_s: float = 5.0\n    on_ratio: float = 0.5\n    phase_deg: float = 0.0\n    min_intensity: float = 0.0\n    max_intensity: float = 1.0\n\n\nclass Pattern:\n    \"\"\"Real-time pattern generator for wavemaker control.\"\"\"\n    \n    def __init__(self, config: PatternConfig):\n        \"\"\"\n        Initialize pattern generator.\n        \n        Args:\n            config: Pattern configuration\n        \"\"\"\n        self.config = config\n        self.phase_rad = math.radians(config.phase_deg)\n        self.start_time = time.time()\n        self._last_random = 0.5\n        self._random_target = 0.5\n        self._random_update_time = 0.0\n        \n    def value(self, t: Optional[float] = None) -> float:\n        \"\"\"\n        Calculate pattern value at given time.\n        \n        Args:\n            t: Timestamp (seconds since epoch). If None, uses current time.\n            \n        Returns:\n            Intensity value [0.0-1.0]\n        \"\"\"\n        if t is None:\n            t = time.time()\n        \n        # Time relative to start\n        rel_t = t - self.start_time\n        \n        # Calculate base pattern value [0, 1]\n        if self.config.mode == \"OFF\":\n            raw = 0.0\n        elif self.config.mode == \"CONSTANT\":\n            raw = 1.0\n        elif self.config.mode == \"PULSE\":\n            raw = self._pulse_pattern(rel_t)\n        elif self.config.mode == \"GYRE\":\n            raw = self._gyre_pattern(rel_t)\n        elif self.config.mode == \"RANDOM\":\n            raw = self._random_pattern(rel_t)\n        else:\n            raw = 0.0\n        \n        # Scale to [min_intensity, max_intensity]\n        return self.config.min_intensity + raw * (\n            self.config.max_intensity - self.config.min_intensity\n        )\n    \n    def _pulse_pattern(self, t: float) -> float:\n        \"\"\"Generate pulse pattern.\"\"\"\n        if self.config.period_s <= 0:\n            return 1.0\n        \n        phase = (t % self.config.period_s) / self.config.period_s\n        return 1.0 if phase < self.config.on_ratio else 0.0\n    \n    def _gyre_pattern(self, t: float) -> float:\n        \"\"\"Generate sinusoidal gyre pattern.\"\"\"\n        if self.config.period_s <= 0:\n            return 0.5\n        \n        phase = (t % self.config.period_s) / self.config.period_s\n        return 0.5 * (1.0 + math.sin(2 * math.pi * phase + self.phase_rad))\n    \n    def _random_pattern(self, t: float) -> float:\n        \"\"\"Generate smooth random pattern with transitions.\"\"\"\n        # Update target every ~10 seconds\n        if t - self._random_update_time > 10.0:\n            self._random_target = 0.3 + 0.7 * (hash(int(t / 10)) % 1000) / 1000\n            self._random_update_time = t\n        \n        # Smooth transition to target\n        alpha = min(1.0, (t - self._random_update_time) / 5.0)\n        self._last_random = self._last_random * (1 - alpha) + self._random_target * alpha\n        return self._last_random\n    \n    def update_config(self, config: PatternConfig) -> None:\n        \"\"\"Update pattern configuration.\"\"\"\n        self.config = config\n        self.phase_rad = math.radians(config.phase_deg)\n    \n    def reset(self) -> None:\n        \"\"\"Reset pattern to start.\"\"\"\n        self.start_time = time.time()\n        self._last_random = 0.5\n        self._random_target = 0.5\n        self._random_update_time = 0.0\n\n\nclass PatternRegistry:\n    \"\"\"Registry for managing patterns across devices.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize empty pattern registry.\"\"\"\n        self.patterns: Dict[str, Pattern] = {}\n    \n    def create_pattern(self, device_id: str, config: PatternConfig) -> Pattern:\n        \"\"\"\n        Create or update pattern for a device.\n        \n        Args:\n            device_id: Device identifier\n            config: Pattern configuration\n            \n        Returns:\n            Pattern instance\n        \"\"\"\n        if device_id in self.patterns:\n            self.patterns[device_id].update_config(config)\n        else:\n            self.patterns[device_id] = Pattern(config)\n        \n        logging.info(f\"Updated pattern for {device_id}: {config.mode}\")\n        return self.patterns[device_id]\n    \n    def get_pattern(self, device_id: str) -> Optional[Pattern]:\n        \"\"\"Get pattern for device.\"\"\"\n        return self.patterns.get(device_id)\n    \n    def remove_pattern(self, device_id: str) -> None:\n        \"\"\"Remove pattern for device.\"\"\"\n        if device_id in self.patterns:\n            del self.patterns[device_id]\n    \n    def get_all_values(self, t: Optional[float] = None) -> Dict[str, float]:\n        \"\"\"Get current values for all patterns.\"\"\"\n        return {\n            device_id: pattern.value(t)\n            for device_id, pattern in self.patterns.items()\n        }\n\n\n# Global pattern registry\npattern_registry = PatternRegistry()\n","size_bytes":5116},"app/routers/settings.py":{"content":"from fastapi import APIRouter, HTTPException, Request\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, List\nimport os\nimport glob\nimport logging\nimport asyncio\n\nrouter = APIRouter()\n\n\nclass DeviceConfigCreate(BaseModel):\n    device_id: str\n    name: str\n    device_type: str\n    gpio_pin: int = Field(ge=0, le=40)\n    pwm_freq_hz: int = Field(ge=50, le=10000)\n    min_intensity: float = Field(ge=0.0, le=1.0, default=0.0)\n    max_intensity: float = Field(ge=0.0, le=1.0, default=1.0)\n    volts_min: float = Field(ge=0.0, le=10.0, default=0.0)\n    volts_max: float = Field(ge=0.0, le=10.0, default=5.0)\n    follow_device_id: Optional[str] = None\n    gpio_pin_monitor: Optional[int] = Field(None, ge=0, le=40)\n    channel_name: Optional[str] = None\n\n\nclass DeviceConfigUpdate(BaseModel):\n    name: Optional[str] = None\n    gpio_pin: Optional[int] = Field(None, ge=0, le=40)\n    pwm_freq_hz: Optional[int] = Field(None, ge=50, le=10000)\n    min_intensity: Optional[float] = Field(None, ge=0.0, le=1.0)\n    max_intensity: Optional[float] = Field(None, ge=0.0, le=1.0)\n    volts_min: Optional[float] = Field(None, ge=0.0, le=10.0)\n    volts_max: Optional[float] = Field(None, ge=0.0, le=10.0)\n    follow_device_id: Optional[str] = None\n    gpio_pin_monitor: Optional[int] = Field(None, ge=0, le=40)\n    channel_name: Optional[str] = None\n\n\n@router.get('/api/settings/hardware')\nasync def get_all_devices(request: Request):\n    store = request.app.state.store\n    devices = store.get_all_device_configs()\n    return [device.model_dump() for device in devices]\n\n\n@router.get('/api/settings/hardware/{device_id}')\nasync def get_device(device_id: str, request: Request):\n    store = request.app.state.store\n    device = store.get_device_config(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"Device {device_id} not found\")\n    return device.model_dump()\n\n\n@router.post('/api/settings/hardware')\nasync def create_device(device: DeviceConfigCreate, request: Request):\n    from app.services.storage import DeviceConfigRow\n    from app.services.hw_devices import registry, DeviceConfig\n    \n    store = request.app.state.store\n    \n    existing = store.get_device_config(device.device_id)\n    if existing:\n        raise HTTPException(status_code=409, detail=f\"Device {device.device_id} already exists\")\n    \n    all_devices = store.get_all_device_configs()\n    for existing_device in all_devices:\n        if existing_device.gpio_pin == device.gpio_pin:\n            raise HTTPException(\n                status_code=409, \n                detail=f\"GPIO pin {device.gpio_pin} already in use by {existing_device.device_id}\"\n            )\n    \n    new_device = DeviceConfigRow(**device.model_dump())\n    created = store.create_device_config(new_device)\n    \n    # Immediately register device in hardware registry\n    config = DeviceConfig(\n        name=created.name,\n        gpio_pin=created.gpio_pin,\n        pwm_freq_hz=created.pwm_freq_hz,\n        min_intensity=created.min_intensity,\n        max_intensity=created.max_intensity,\n        volts_min=created.volts_min,\n        volts_max=created.volts_max,\n        gpio_pin_monitor=created.gpio_pin_monitor,\n        channel_name=created.channel_name\n    )\n    \n    if created.device_type == 'WAVEMAKER':\n        registry.register_wavemaker(created.device_id, config)\n    else:\n        registry.register_led(created.device_id, config)\n    \n    logging.info(f\"[Settings] Created and registered new device: {created.device_id}\")\n    \n    return created.model_dump()\n\n\n@router.put('/api/settings/hardware/{device_id}')\nasync def update_device(device_id: str, updates: DeviceConfigUpdate, request: Request):\n    store = request.app.state.store\n    \n    device = store.get_device_config(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"Device {device_id} not found\")\n    \n    update_data = {}\n    for field, value in updates.model_dump(exclude_unset=True).items():\n        update_data[field] = value\n    \n    if 'gpio_pin' in update_data:\n        all_devices = store.get_all_device_configs()\n        for existing_device in all_devices:\n            if existing_device.device_id != device_id and existing_device.gpio_pin == update_data['gpio_pin']:\n                raise HTTPException(\n                    status_code=409, \n                    detail=f\"GPIO pin {update_data['gpio_pin']} already in use by {existing_device.device_id}\"\n                )\n    \n    updated = store.update_device_config(device_id, **update_data)\n    \n    # Hot-reload device config for ANY parameter changes (not just GPIO/freq)\n    from app.services.hw_devices import registry, DeviceConfig\n    \n    # Check if GPIO pin changed (requires full hardware re-init)\n    gpio_changed = 'gpio_pin' in update_data\n    \n    # Build new config from updated device\n    config = DeviceConfig(\n        name=updated.name,\n        gpio_pin=updated.gpio_pin,\n        pwm_freq_hz=updated.pwm_freq_hz,\n        min_intensity=updated.min_intensity,\n        max_intensity=updated.max_intensity,\n        volts_min=updated.volts_min,\n        volts_max=updated.volts_max,\n        gpio_pin_monitor=updated.gpio_pin_monitor,\n        channel_name=updated.channel_name\n    )\n    \n    if gpio_changed:\n        # Full reload when GPIO pin changes (need to clean up old pin)\n        registry.reload_device(device_id, config, updated.device_type)\n        logging.info(f\"[Settings] Hot-reloaded {device_id} with new GPIO pin {updated.gpio_pin}\")\n    else:\n        # Just update the config in-place for other parameters\n        registry.update_device_config(device_id, config, updated.device_type)\n        logging.info(f\"[Settings] Updated {device_id} config (intensity: {updated.min_intensity:.2f}-{updated.max_intensity:.2f})\")\n    \n    return updated.model_dump()\n\n\n@router.delete('/api/settings/hardware/{device_id}')\nasync def delete_device(device_id: str, request: Request):\n    from app.services.hw_devices import registry\n    \n    store = request.app.state.store\n    \n    # First, unregister from hardware registry (stops output and cleans up)\n    registry.unregister_device(device_id)\n    \n    # Then delete from database\n    success = store.delete_device_config(device_id)\n    if not success:\n        raise HTTPException(status_code=404, detail=f\"Device {device_id} not found\")\n    \n    logging.info(f\"[Settings] Deleted device {device_id} from registry and database\")\n    return {\"success\": True}\n\n\nclass TestDeviceRequest(BaseModel):\n    gpio_pin: int = Field(ge=0, le=40)\n    duty_cycle: float = Field(ge=0.0, le=1.0, default=0.5)\n\n\n@router.post('/api/settings/hardware/test')\nasync def test_device(test_req: TestDeviceRequest, request: Request):\n    \"\"\"Test a GPIO device by setting it to specified duty cycle for 3 seconds\"\"\"\n    try:\n        from app.services.hw_devices import registry, DeviceConfig, PWMDevice\n        \n        store = request.app.state.store\n        \n        # Check if this GPIO is already assigned to a device\n        all_devices = store.get_all_device_configs()\n        existing_device_id = None\n        for dev in all_devices:\n            if dev.gpio_pin == test_req.gpio_pin:\n                existing_device_id = dev.device_id\n                break\n        \n        if existing_device_id:\n            # Use existing device for test\n            device = registry.get_led(existing_device_id) or registry.get_wavemaker(existing_device_id)\n            if device:\n                logging.info(f\"[Test] Testing existing device {existing_device_id} at {test_req.duty_cycle:.1%} for 3 seconds\")\n                \n                # Save current state (as intensity, not raw duty)\n                original_duty = device.current_duty\n                \n                # Apply test intensity using PWMDevice.apply() for proper scaling\n                device.apply(test_req.duty_cycle)\n                \n                # Wait 3 seconds\n                await asyncio.sleep(3)\n                \n                # Restore original state using apply()\n                if original_duty > 0.0:\n                    # Calculate intensity from duty within device's range\n                    intensity = (original_duty - device.config.min_intensity) / (device.config.max_intensity - device.config.min_intensity) if (device.config.max_intensity - device.config.min_intensity) > 0 else 0\n                    device.apply(intensity)\n                else:\n                    device.stop()\n                \n                logging.info(f\"[Test] Device {existing_device_id} test complete\")\n                return {\"success\": True, \"message\": f\"{existing_device_id} tested successfully\"}\n        \n        # No existing device - create temporary test device\n        config = DeviceConfig(\n            name=f\"Test GPIO {test_req.gpio_pin}\",\n            gpio_pin=test_req.gpio_pin,\n            pwm_freq_hz=800,\n            min_intensity=0.0,\n            max_intensity=1.0,\n            volts_min=0.0,\n            volts_max=5.0\n        )\n        \n        test_device = PWMDevice(config)\n        \n        logging.info(f\"[Test] Testing GPIO{test_req.gpio_pin} at {test_req.duty_cycle:.1%} for 3 seconds\")\n        \n        # Use apply() for proper driver scaling\n        test_device.apply(test_req.duty_cycle)\n        \n        # Wait 3 seconds\n        await asyncio.sleep(3)\n        \n        # Clean up\n        test_device.cleanup()\n        \n        logging.info(f\"[Test] GPIO{test_req.gpio_pin} test complete\")\n        \n        return {\"success\": True, \"message\": f\"GPIO{test_req.gpio_pin} tested successfully\"}\n    \n    except Exception as e:\n        logging.error(f\"[Test] Failed to test GPIO{test_req.gpio_pin}: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Test failed: {str(e)}\")\n\n\n@router.get('/api/logs')\nasync def get_logs(level: str = 'all'):\n    log_files = glob.glob('/tmp/logs/reef-controller_*.log')\n    if not log_files:\n        return {\"logs\": \"No log files found\"}\n    \n    latest_log_file = max(log_files, key=os.path.getmtime)\n    \n    try:\n        with open(latest_log_file, 'r') as f:\n            logs = f.read()\n        \n        if level != 'all':\n            lines = logs.split('\\n')\n            filtered_lines = [line for line in lines if level in line]\n            logs = '\\n'.join(filtered_lines)\n        \n        return {\"logs\": logs[-50000:]}\n    except Exception as e:\n        return {\"logs\": f\"Error reading logs: {str(e)}\"}\n\n\nclass ConfigImportData(BaseModel):\n    devices: Optional[List[dict]] = None\n    presets: Optional[List[dict]] = None\n    scheduled_tasks: Optional[List[dict]] = None\n    version: str = \"1.0\"\n\n\n@router.get('/api/settings/export')\nasync def export_config(request: Request):\n    \"\"\"Export full system configuration as JSON for backup\"\"\"\n    from datetime import datetime\n    \n    store = request.app.state.store\n    \n    devices = store.get_all_device_configs()\n    presets = store.get_all_presets()\n    scheduled_tasks = store.get_all_scheduled_tasks()\n    \n    export_data = {\n        \"version\": \"1.0\",\n        \"exported_at\": datetime.now().isoformat(),\n        \"devices\": [d.model_dump() for d in devices],\n        \"presets\": [\n            {\n                \"id\": p.id,\n                \"name\": p.name,\n                \"description\": p.description,\n                \"cycle_duration_sec\": p.cycle_duration_sec,\n                \"is_built_in\": p.is_built_in,\n                \"flow_curves\": p.flow_curves\n            }\n            for p in presets\n        ],\n        \"scheduled_tasks\": [t.model_dump() for t in scheduled_tasks]\n    }\n    \n    logging.info(f\"[Export] Exported config: {len(devices)} devices, {len(presets)} presets, {len(scheduled_tasks)} tasks\")\n    \n    return export_data\n\n\n@router.post('/api/settings/import')\nasync def import_config(config_data: ConfigImportData, request: Request):\n    \"\"\"Import system configuration from JSON backup - performs clean slate import\"\"\"\n    from app.services.storage import DeviceConfigRow, WavemakerPreset, ScheduledTaskRow\n    from app.services.hw_devices import registry, DeviceConfig\n    from app.hw_scheduler.realtime_loop import set_led_follow\n    from fastapi import HTTPException\n    \n    store = request.app.state.store\n    \n    # Validate incoming config for internal GPIO conflicts (within the import file itself)\n    if config_data.devices:\n        gpio_conflicts = []\n        gpio_map: dict[int, str] = {}\n        \n        for device_data in config_data.devices:\n            device_id = device_data.get('device_id')\n            if not device_id:\n                continue\n                \n            gpio_pin = device_data.get('gpio_pin')\n            gpio_pin_monitor = device_data.get('gpio_pin_monitor')\n            \n            # Check main GPIO pin for conflicts within imported config\n            if gpio_pin is not None:\n                if gpio_pin in gpio_map:\n                    conflicting_device = gpio_map[gpio_pin]\n                    gpio_conflicts.append(f\"GPIO {gpio_pin}: {device_id} conflicts with {conflicting_device}\")\n                else:\n                    gpio_map[gpio_pin] = device_id\n            \n            # Check monitor GPIO pin for conflicts within imported config\n            if gpio_pin_monitor is not None:\n                if gpio_pin_monitor in gpio_map:\n                    conflicting_device = gpio_map[gpio_pin_monitor]\n                    gpio_conflicts.append(f\"GPIO {gpio_pin_monitor}: {device_id} (monitor) conflicts with {conflicting_device}\")\n                else:\n                    gpio_map[gpio_pin_monitor] = f\"{device_id} (monitor)\"\n        \n        # Reject import if config file has internal conflicts\n        if gpio_conflicts:\n            logging.warning(f\"[Import] Rejected due to internal GPIO conflicts in config file: {gpio_conflicts}\")\n            raise HTTPException(\n                status_code=409,\n                detail={\n                    \"error\": \"GPIO pin conflicts detected within import file\",\n                    \"conflicts\": gpio_conflicts,\n                    \"message\": \"Import aborted. The config file has duplicate GPIO assignments. Please fix the conflicts.\"\n                }\n            )\n    \n    # CLEAN SLATE: Remove ALL existing devices before importing new ones\n    # This ensures the imported config is the complete system state\n    # Always clear devices when a devices array is present (even if empty)\n    devices_cleared = 0\n    existing_devices = store.get_all_device_configs()\n    if config_data.devices is not None:\n        devices_cleared = len(existing_devices)\n        for dev in existing_devices:\n            try:\n                # Unregister from hardware registry (stops output, cleans up GPIO)\n                registry.unregister_device(dev.device_id)\n                # Delete from database\n                store.delete_device_config(dev.device_id)\n                logging.info(f\"[Import] Cleared existing device: {dev.device_id}\")\n            except Exception as e:\n                logging.warning(f\"[Import] Error clearing device {dev.device_id}: {e}\")\n    \n    results = {\n        \"devices_cleared\": devices_cleared,\n        \"devices_imported\": 0,\n        \"presets_imported\": 0,\n        \"presets_skipped\": 0,\n        \"tasks_imported\": 0,\n        \"tasks_skipped\": 0,\n        \"errors\": []\n    }\n    \n    # Import all devices fresh (we've already cleared existing ones above)\n    if config_data.devices:\n        for device_data in config_data.devices:\n            try:\n                device_id = device_data.get('device_id')\n                if not device_id:\n                    results[\"errors\"].append(\"Device missing required 'device_id' field\")\n                    continue\n                \n                # Create new device in database\n                new_device = DeviceConfigRow(**device_data)\n                created = store.create_device_config(new_device)\n                \n                # Build config for hardware registry\n                config = DeviceConfig(\n                    name=created.name,\n                    gpio_pin=created.gpio_pin,\n                    pwm_freq_hz=created.pwm_freq_hz,\n                    min_intensity=created.min_intensity,\n                    max_intensity=created.max_intensity,\n                    volts_min=created.volts_min,\n                    volts_max=created.volts_max,\n                    gpio_pin_monitor=created.gpio_pin_monitor,\n                    channel_name=created.channel_name\n                )\n                \n                # Register with hardware\n                if created.device_type == 'WAVEMAKER':\n                    registry.register_wavemaker(created.device_id, config)\n                else:\n                    registry.register_led(created.device_id, config)\n                \n                logging.info(f\"[Import] Registered device {created.device_id} ({created.device_type}) on GPIO {created.gpio_pin}\")\n                results[\"devices_imported\"] += 1\n                    \n            except Exception as e:\n                results[\"errors\"].append(f\"Device {device_data.get('device_id', 'unknown')}: {str(e)}\")\n    \n    if config_data.presets:\n        for preset_data in config_data.presets:\n            try:\n                if preset_data.get('is_built_in'):\n                    results[\"presets_skipped\"] += 1\n                    continue\n                \n                preset_name = preset_data.get('name')\n                if not preset_name:\n                    results[\"errors\"].append(\"Preset missing required 'name' field\")\n                    continue\n                    \n                preset = WavemakerPreset(\n                    name=preset_name,\n                    description=preset_data.get('description') or '',\n                    cycle_duration_sec=preset_data.get('cycle_duration_sec') or 60,\n                    is_built_in=False,\n                    flow_curves=preset_data.get('flow_curves') or {}\n                )\n                store.create_preset(preset)\n                results[\"presets_imported\"] += 1\n                \n            except Exception as e:\n                results[\"errors\"].append(f\"Preset {preset_data.get('name', 'unknown')}: {str(e)}\")\n    \n    if config_data.scheduled_tasks:\n        for task_data in config_data.scheduled_tasks:\n            try:\n                task_name = task_data.get('name')\n                task_type = task_data.get('task_type')\n                task_time = task_data.get('time')\n                \n                if not task_name or not task_type or not task_time:\n                    results[\"errors\"].append(f\"Task missing required fields (name, task_type, time)\")\n                    continue\n                \n                task = ScheduledTaskRow(\n                    name=task_name,\n                    task_type=task_type,\n                    time=task_time,\n                    enabled=task_data.get('enabled', True),\n                    preset_id=task_data.get('preset_id'),\n                    days_of_week=task_data.get('days_of_week')\n                )\n                store.create_scheduled_task(task)\n                results[\"tasks_imported\"] += 1\n                \n            except Exception as e:\n                results[\"errors\"].append(f\"Task {task_data.get('name', 'unknown')}: {str(e)}\")\n    \n    for device in store.get_all_device_configs():\n        if device.device_type == \"LED\" and device.follow_device_id:\n            set_led_follow(device.device_id, device.follow_device_id)\n    \n    logging.info(f\"[Import] Imported: {results['devices_imported']} devices, {results['presets_imported']} presets, {results['tasks_imported']} tasks\")\n    \n    return results\n","size_bytes":19637},"app/hw/esp32_serial.py":{"content":"\"\"\"ESP32 serial GPIO driver for USB-to-GPIO adapter.\"\"\"\n\nimport logging\nimport serial\nfrom typing import Dict, Optional\nimport os\n\n\nclass PigpioPWM:\n    \"\"\"PWM control via ESP32 serial communication (USB adapter).\"\"\"\n    \n    _serial_conn: Optional[serial.Serial] = None\n    _instances: Dict[int, 'PigpioPWM'] = {}\n    \n    def __init__(self, pin: int, freq: int = 500):\n        \"\"\"\n        Initialize PWM on an ESP32 GPIO pin via serial.\n        \n        Args:\n            pin: ESP32 GPIO pin number (e.g., 25, 33, 32)\n            freq: PWM frequency in Hz (informational only - ESP32 uses fixed freq)\n        \"\"\"\n        self.pin = pin\n        self.freq = freq\n        self.duty = 0.0\n        self.running = False\n        \n        # Initialize serial connection if not already done\n        if PigpioPWM._serial_conn is None:\n            port = os.getenv('ESP32_SERIAL_PORT', 'COM4')\n            baudrate = int(os.getenv('ESP32_SERIAL_BAUD', '115200'))\n            \n            try:\n                PigpioPWM._serial_conn = serial.Serial(\n                    port=port,\n                    baudrate=baudrate,\n                    timeout=1,\n                    write_timeout=1\n                )\n                logging.info(f\"[ESP32] Connected to {port} at {baudrate} baud\")\n            except serial.SerialException as e:\n                logging.error(f\"[ESP32] Failed to open {port}: {e}\")\n                raise RuntimeError(f\"Cannot connect to ESP32 on {port}\") from e\n        \n        PigpioPWM._instances[pin] = self\n        logging.info(f\"[ESP32] Initialized PWM on GPIO{pin} at {freq}Hz\")\n        \n        # Set initial state (off)\n        self.set_duty(0.0)\n    \n    def _send_command(self, pwm_value: int) -> None:\n        \"\"\"\n        Send PWM command to ESP32.\n        \n        Args:\n            pwm_value: PWM value (0-255)\n        \"\"\"\n        if PigpioPWM._serial_conn is None:\n            logging.error(\"[ESP32] No serial connection available\")\n            return\n        \n        try:\n            # Format: \"PIN:VALUE\\n\"\n            command = f\"{self.pin}:{pwm_value}\\n\"\n            PigpioPWM._serial_conn.write(command.encode())\n            logging.debug(f\"[ESP32] Sent: {command.strip()}\")\n        except serial.SerialException as e:\n            logging.error(f\"[ESP32] Failed to send command to GPIO{self.pin}: {e}\")\n    \n    def set_frequency(self, hz: int) -> None:\n        \"\"\"\n        Set PWM frequency.\n        \n        Note: ESP32 firmware uses fixed frequency (analogWrite).\n        This is stored for compatibility but not sent to device.\n        \n        Args:\n            hz: PWM frequency in Hz\n        \"\"\"\n        old_freq = self.freq\n        self.freq = hz\n        logging.debug(f\"[ESP32] GPIO{self.pin} frequency changed: {old_freq}Hz â†’ {hz}Hz (informational only)\")\n    \n    def set_duty(self, duty: float) -> None:\n        \"\"\"\n        Set duty cycle and send to ESP32.\n        \n        Args:\n            duty: Duty cycle from 0.0 (0%) to 1.0 (100%)\n        \"\"\"\n        # Clamp to valid range\n        duty = max(0.0, min(1.0, duty))\n        \n        # Apply gamma correction for more natural brightness perception\n        gamma = 2.2\n        raw_pwm = (duty ** gamma) * 255\n        \n        # Enforce minimum floor for visibility (1% should still be visible)\n        if duty > 0 and raw_pwm < 5:\n            raw_pwm = 5\n        \n        # Convert to integer for ESP32\n        pwm_value = int(raw_pwm)\n        \n        # Send to ESP32\n        self._send_command(pwm_value)\n        \n        # Update internal state\n        if abs(self.duty - duty) > 0.01:  # Log significant changes only\n            logging.debug(f\"[ESP32] GPIO{self.pin} duty: {self.duty:.2%} â†’ {duty:.2%} (PWM={pwm_value})\")\n        \n        self.duty = duty\n        self.running = (duty > 0)\n    \n    def start(self, duty: float = 0.0) -> None:\n        \"\"\"\n        Start PWM with given duty cycle.\n        \n        Args:\n            duty: Initial duty cycle (0.0-1.0)\n        \"\"\"\n        self.running = True\n        self.set_duty(duty)\n        logging.info(f\"[ESP32] Started PWM on GPIO{self.pin} at {duty:.2%}\")\n    \n    def stop(self) -> None:\n        \"\"\"Stop PWM output (set to 0).\"\"\"\n        self.running = False\n        self.set_duty(0.0)\n        logging.info(f\"[ESP32] Stopped PWM on GPIO{self.pin}\")\n    \n    def cleanup(self) -> None:\n        \"\"\"Cleanup resources for this pin.\"\"\"\n        self.stop()\n        if self.pin in PigpioPWM._instances:\n            del PigpioPWM._instances[self.pin]\n    \n    @classmethod\n    def close_serial(cls) -> None:\n        \"\"\"Close the shared serial connection.\"\"\"\n        if cls._serial_conn is not None:\n            try:\n                cls._serial_conn.close()\n                logging.info(\"[ESP32] Closed serial connection\")\n            except Exception as e:\n                logging.error(f\"[ESP32] Error closing serial: {e}\")\n            finally:\n                cls._serial_conn = None\n    \n    @classmethod\n    def get_all_states(cls) -> Dict[int, dict]:\n        \"\"\"Get current state of all ESP32 PWM channels (for debugging).\"\"\"\n        return {\n            pin: {\n                \"duty\": inst.duty,\n                \"freq\": inst.freq,\n                \"running\": inst.running\n            }\n            for pin, inst in cls._instances.items()\n        }\n","size_bytes":5306},"migrate_to_percentage_keyframes.py":{"content":"\"\"\"\nMigration script to convert wavemaker preset keyframes from absolute seconds to percentages.\n\nThis script converts all existing preset flow curves from time-in-seconds to time-as-percentage,\nmaking curves independent of cycle duration.\n\nRun this once: python migrate_to_percentage_keyframes.py\n\"\"\"\n\nimport os\nfrom app.services.storage import Store, make_db, WavemakerPreset\nfrom sqlmodel import Session, select\n\ndef migrate_presets():\n    db_url = os.getenv(\"DB_URL\", \"sqlite:///reef_controller.db\")\n    engine = make_db(db_url)\n    store = Store(engine)\n    \n    with Session(store.engine) as session:\n        statement = select(WavemakerPreset)\n        presets = session.exec(statement).all()\n        \n        print(f\"Found {len(presets)} presets to migrate\")\n        \n        for preset in presets:\n            cycle_duration = preset.cycle_duration_sec\n            if cycle_duration <= 0:\n                print(f\"  Skipping preset '{preset.name}' (invalid cycle duration: {cycle_duration})\")\n                continue\n            \n            modified = False\n            flow_curves = preset.flow_curves or {}\n            \n            for wm_key, curve in flow_curves.items():\n                if not curve or len(curve) == 0:\n                    continue\n                \n                for point in curve:\n                    if 'time' in point:\n                        time_sec = point['time']\n                        time_pct = (time_sec / cycle_duration) * 100.0\n                        point['time'] = round(time_pct, 2)\n                        modified = True\n            \n            if modified:\n                preset.flow_curves = flow_curves\n                session.add(preset)\n                print(f\"  âœ“ Migrated preset '{preset.name}' (cycle: {cycle_duration}s)\")\n        \n        session.commit()\n        print(f\"\\nâœ“ Migration complete!\")\n\nif __name__ == \"__main__\":\n    migrate_presets()\n","size_bytes":1917}},"version":2}