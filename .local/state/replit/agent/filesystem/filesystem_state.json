{"file_contents":{"app/main.py":{"content":"import os\nimport logging\nfrom pathlib import Path\nfrom fastapi import FastAPI\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.responses import FileResponse\nfrom .config import CONFIG, DB_URL, APP_PORT\nfrom .services.stage_manager import StageManager\nfrom .services.scheduler import JobScheduler\nfrom .services.storage import make_db, Store\nfrom .services.automation import AutomationService\nfrom .services.system_health import SystemHealthService\nfrom .services.events import EventsService\nfrom .services.power_allocator import PowerAllocator\nfrom .services.wavemaker_manager import WavemakerManager\nfrom .services.preset_manager import PresetManager\nfrom .routers import telemetry, control, config_api, automation, arrays, history, wavemakers, presets, hardware\n\nlogger = logging.getLogger(\"uvicorn.error\")\n\n\napp = FastAPI(title=CONFIG['site']['name'])\napp.mount('/ui', StaticFiles(directory='app/web', html=True), name='ui')\n\n\n@app.get('/')\nasync def root():\n    return FileResponse(\n        'app/web/index.html',\n        headers={\n            'Cache-Control': 'no-cache, no-store, must-revalidate',\n            'Pragma': 'no-cache',\n            'Expires': '0'\n        }\n    )\n\n\napp.include_router(telemetry.router, prefix='/api')\napp.include_router(control.router, prefix='/api')\napp.include_router(config_api.router, prefix='/api')\napp.include_router(automation.router, prefix='/api')\napp.include_router(arrays.router, prefix='/api')\napp.include_router(history.router)\napp.include_router(wavemakers.router, prefix='/api')\napp.include_router(presets.router, prefix='/api')\napp.include_router(hardware.router, prefix='/api')\n\n\n@app.on_event('startup')\nasync def startup():\n    try:\n        logger.info(\"Starting Reef Controller initialization...\")\n        \n        db_path = DB_URL.replace('sqlite:///', '')\n        db_dir = os.path.dirname(db_path)\n        if db_dir and not os.path.exists(db_dir):\n            logger.info(f\"Creating database directory: {db_dir}\")\n            Path(db_dir).mkdir(parents=True, exist_ok=True)\n        \n        logger.info(\"Loading configuration...\")\n        app.state.config = CONFIG\n        \n        logger.info(\"Initializing stage manager...\")\n        app.state.stage_manager = StageManager(CONFIG)\n        app.state.mgr = app.state.stage_manager\n        \n        logger.info(\"Initializing system health service...\")\n        app.state.health = SystemHealthService()\n        \n        logger.info(\"Initializing events service...\")\n        app.state.events = EventsService(max_events=200)\n        \n        logger.info(\"Initializing power allocator...\")\n        app.state.power_allocator = PowerAllocator(CONFIG, app.state.events)\n        \n        logger.info(\"Initializing wavemaker manager...\")\n        app.state.wavemaker_manager = WavemakerManager()\n        \n        logger.info(f\"Initializing database at {DB_URL}...\")\n        engine = make_db(DB_URL)\n        app.state.store = Store(engine)\n        \n        logger.info(\"Initializing preset manager...\")\n        app.state.preset_manager = PresetManager(app.state.store)\n        \n        logger.info(\"Connecting preset manager to wavemaker manager...\")\n        app.state.wavemaker_manager.set_preset_manager(app.state.preset_manager)\n        \n        logger.info(\"Initializing automation service...\")\n        app.state.automation = AutomationService(\n            store=app.state.store,\n            preset_manager=app.state.preset_manager\n        )\n        \n        logger.info(\"Creating initial snapshot...\")\n        app.state.latest = app.state.stage_manager.snapshot()\n        \n        logger.info(\"Starting job scheduler...\")\n        scheduler = JobScheduler(\n            app.state.stage_manager,\n            persist_cb=app.state.store.persist,\n            interval_s=CONFIG['telemetry']['sample_interval_ms']/1000,\n            power_allocator=app.state.power_allocator,\n            wavemaker_manager=app.state.wavemaker_manager,\n            automation=app.state.automation\n        )\n        scheduler.start(app)\n        \n        logger.info(\"Initializing hardware control system...\")\n        from .services.hw_devices import registry as hw_registry, DeviceConfig\n        from .services.hw_patterns import pattern_registry, PatternConfig\n        from .hw_scheduler.realtime_loop import start_hw_scheduler, set_led_follow, set_preset_manager\n        \n        # Initialize WM1 (Wavemaker Channel 1) on GPIO18\n        wm1_config = DeviceConfig(\n            name=\"Wavemaker CH1\",\n            gpio_pin=18,\n            pwm_freq_hz=200,\n            min_intensity=0.05,  # Avoid full stop\n            max_intensity=1.0,\n            volts_min=0.0,\n            volts_max=0.6\n        )\n        hw_registry.register_wavemaker(\"WM1\", wm1_config)\n        \n        # Initialize LED1 on GPIO19 to mirror WM1\n        led1_config = DeviceConfig(\n            name=\"LED CH1\",\n            gpio_pin=19,\n            pwm_freq_hz=800,\n            min_intensity=0.0,\n            max_intensity=1.0,\n            volts_min=0.0,\n            volts_max=5.0\n        )\n        hw_registry.register_led(\"LED1\", led1_config)\n        \n        # Configure LED1 to follow WM1\n        set_led_follow(\"LED1\", \"WM1\")\n        \n        # Create default PULSE pattern for WM1 (fallback when no preset active)\n        default_pattern = PatternConfig(\n            mode=\"PULSE\",\n            period_s=6.0,\n            on_ratio=0.5,\n            phase_deg=0.0,\n            min_intensity=0.0,\n            max_intensity=1.0\n        )\n        pattern_registry.create_pattern(\"WM1\", default_pattern)\n        \n        # Link PresetManager to hardware control - presets drive GPIO output\n        set_preset_manager(app.state.preset_manager)\n        \n        # Start hardware scheduler (20Hz real-time loop)\n        start_hw_scheduler()\n        logger.info(f\"Hardware control started ({hw_registry.mode} mode)\")\n        \n        logger.info(\"Reef Controller startup complete!\")\n        \n    except Exception as e:\n        logger.error(f\"Failed to initialize Reef Controller: {e}\", exc_info=True)\n        raise","size_bytes":6051},"app/config.py":{"content":"import os, yaml\nfrom dotenv import load_dotenv\n\n\nload_dotenv()\n\n\nAPP_PORT = int(os.getenv(\"APP_PORT\", \"5000\"))\nDB_URL = os.getenv(\"DB_URL\", \"sqlite:///./reef.db\")\nSENSOR_DRIVER = os.getenv(\"SENSOR_DRIVER\", \"sensors_sim\")\nGPIO_DRIVER = os.getenv(\"GPIO_DRIVER\", \"gpio\")\n\n\nwith open(\"config.yaml\", \"r\") as f:\n    CONFIG = yaml.safe_load(f)","size_bytes":336},"app/services/stage_manager.py":{"content":"from datetime import datetime\nfrom ..models import Telemetry, StageStatus\nfrom ..stages.led_stage import LEDStage\nfrom ..stages.battery_stage import BatteryStage\nfrom ..drivers import sensors_sim\n\n\nclass StageManager:\n    def __init__(self, config):\n        self.config = config\n        self.stages = []\n        self.stage_dict = {}\n        \n        for idx, arr in enumerate(config[\"stages\"][\"arrays\"], start=0):\n            sid = arr['id']\n            stage = LEDStage(sid, sensors_sim.SensorSim(seed=idx, stage_config=arr), config=arr)\n            self.stages.append(stage)\n            self.stage_dict[sid] = stage\n        \n        battery_stage = BatteryStage(\"Battery\", sensors_sim.SensorSim(seed=99))\n        self.stages.append(battery_stage)\n        self.stage_dict[\"Battery\"] = battery_stage\n\n\n    def list_status(self):\n        out = []\n        for st in self.stages:\n            stage_id = st.id if hasattr(st, 'id') else st.stage_id\n            out.append(StageStatus(stage_id=stage_id, enabled=st.enabled, mode=st.mode, duty=st.duty))\n        return out\n\n\n    def control(self, stage_id, mode=None, duty=None, enable=None):\n        st = self.stage_dict.get(stage_id)\n        if not st:\n            return False\n        if mode:\n            st.set_mode(mode)\n        st.apply_control(duty, enable)\n        return True\n\n\n    def snapshot(self):\n        rows = []\n        for st in self.stages:\n            t = st.read_telemetry()\n            stage_id = st.id if hasattr(st, 'id') else st.stage_id\n            rows.append(Telemetry(stage_id=stage_id, ts=datetime.utcnow(), mode=st.mode, **t))\n        return rows\n","size_bytes":1622},"app/models.py":{"content":"from typing import Optional, Literal, List\nfrom datetime import datetime\nfrom pydantic import BaseModel\n\n\nMode = Literal[\"OFF\", \"MANUAL\", \"AUTO\", \"REDUNDANT\"]\n\n\nclass Telemetry(BaseModel):\n    stage_id: str\n    ts: datetime\n    vin_v: float\n    iin_a: float\n    vout_v: float\n    iout_a: float\n    mode: Mode\n\n\nclass ControlRequest(BaseModel):\n    stage_id: str\n    mode: Mode\n    duty: Optional[float] = None\n    enable: Optional[bool] = None\n\n\nclass StageStatus(BaseModel):\n    stage_id: str\n    enabled: bool\n    mode: Mode\n    duty: float\n\n\nclass LED(BaseModel):\n    id: str\n    label: str\n    intensity_limit_pct: int\n    priority: int\n    is_on: bool = True\n    current_intensity_pct: float = 0.0\n\n\nclass ArrayConfig(BaseModel):\n    id: str\n    name: str\n    description: str\n    max_current_a: float\n    nominal_voltage_v: float\n    leds: List[LED]\n\n\nclass ArrayStatus(BaseModel):\n    id: str\n    name: str\n    description: str\n    enabled: bool\n    mode: Mode\n    duty: float\n    leds: List[LED]\n    vin_v: float\n    iin_a: float\n    vout_v: float\n    iout_a: float\n    power_w: float\n\n\nclass LEDSettingsUpdate(BaseModel):\n    label: Optional[str] = None\n    intensity_limit_pct: Optional[int] = None\n    priority: Optional[int] = None\n    is_on: Optional[bool] = None\n\n\nclass ArraySettingsRequest(BaseModel):\n    leds: dict[str, LEDSettingsUpdate]\n\n\nclass SystemLoad(BaseModel):\n    pv_w: float\n    load_w: float\n    battery_w: float\n    net_w: float\n    budget_w: float\n    timestamp: datetime\n\n\nclass PowerEvent(BaseModel):\n    timestamp: datetime\n    event_type: Literal[\"shed\", \"restore\", \"alert\", \"warning\"]\n    array_id: Optional[str] = None\n    led_id: Optional[str] = None\n    message: str\n    details: Optional[dict] = None\n\n\nclass HistoryPoint(BaseModel):\n    t: datetime\n    v: float\n    i: float\n    p: float\n\n\nWavemakerMode = Literal[\"off\", \"constant\", \"pulse\", \"gyre_left\", \"gyre_right\", \"random_reef\"]\n\n\nclass WavemakerChannel(BaseModel):\n    id: int\n    name: str\n    mode: WavemakerMode\n    target_power_pct: int\n    pulse_duty_ratio: float\n    current_power_w: float\n    voltage_v: float\n    current_a: float\n\n\nclass WavemakerControlRequest(BaseModel):\n    mode: Optional[WavemakerMode] = None\n    target_power_pct: Optional[int] = None\n    pulse_duty_ratio: Optional[float] = None\n\n\nclass WavemakerHistoryPoint(BaseModel):\n    t: datetime\n    power_w: float\n    duty_pct: float\n    pulse_duty_ratio: float\n\n\nclass WavemakerPresetResponse(BaseModel):\n    id: int\n    name: str\n    description: str\n    cycle_duration_sec: int\n    is_built_in: bool\n    flow_curves: dict\n\n\nclass WavemakerPresetRequest(BaseModel):\n    name: str\n    description: Optional[str] = \"\"\n    cycle_duration_sec: Optional[int] = 60\n    flow_curves: Optional[dict] = {}\n\n\nclass ScheduledTask(BaseModel):\n    id: Optional[int] = None\n    name: str\n    task_type: Literal[\"preset_activation\", \"feeding\", \"maintenance\"]\n    time: str\n    enabled: bool = True\n    preset_id: Optional[int] = None\n    days_of_week: Optional[List[int]] = None\n\n\nclass ScheduledTaskRequest(BaseModel):\n    name: str\n    task_type: Literal[\"preset_activation\", \"feeding\", \"maintenance\"]\n    time: str\n    enabled: Optional[bool] = True\n    preset_id: Optional[int] = None\n    days_of_week: Optional[List[int]] = None\n","size_bytes":3292},"app/drivers/sensors_sim.py":{"content":"import random\nimport time\nimport math\nfrom datetime import datetime\n\n\nclass SensorSim:\n    def __init__(self, seed=None, stage_config=None):\n        self.rng = random.Random(seed or time.time())\n        self.stage_config = stage_config or {}\n        self.base_vin = 36.0\n        self.base_vout = stage_config.get(\"nominal_voltage_v\", 30.0) if stage_config else 30.0\n        self.max_current = stage_config.get(\"max_current_a\", 2.0) if stage_config else 2.0\n    \n    def read(self, duty=0.0, enabled=True):\n        \"\"\"\n        Simulate realistic sensor readings based on duty cycle and LED configuration\n        duty: 0.0 to 1.0 (0% to 100%)\n        enabled: whether the stage is enabled\n        \"\"\"\n        if not enabled:\n            vin = self.base_vin + self.rng.uniform(-1, 1)\n            iin = self.rng.uniform(0.0, 0.1)\n            vout = self.base_vout + self.rng.uniform(-1, 1)\n            iout = 0.0\n            return vin, iin, vout, iout\n        \n        base_current = duty * self.max_current\n        iout = base_current + self.rng.uniform(-0.05, 0.05)\n        iout = max(0.0, iout)\n        \n        voltage_drop_factor = 1.0 - (duty * 0.08)\n        vout = (self.base_vout * voltage_drop_factor) + self.rng.uniform(-0.3, 0.3)\n        \n        iin = (iout * 1.1) + self.rng.uniform(-0.02, 0.02)\n        iin = max(0.0, iin)\n        \n        vin = self.base_vin + self.rng.uniform(-1.5, 1.5)\n        \n        return vin, iin, vout, iout\n\n\nclass PVSimulator:\n    def __init__(self, max_power_w=600, seed=None):\n        self.max_power_w = max_power_w\n        self.rng = random.Random(seed or time.time())\n        self.base_voltage = 48.0\n    \n    def get_diurnal_factor(self):\n        \"\"\"\n        Returns 0.0 to 1.0 based on time of day (simulates sunrise/sunset)\n        Peak at noon, 0 at night\n        \"\"\"\n        now = datetime.now()\n        hour = now.hour + now.minute / 60.0\n        \n        if hour < 6 or hour > 20:\n            return 0.0\n        elif hour < 8:\n            return (hour - 6) / 2.0\n        elif hour < 18:\n            return 1.0 - 0.2 * abs(13 - hour) / 5.0\n        else:\n            return 1.0 - (hour - 18) / 2.0\n    \n    def read(self):\n        \"\"\"\n        Returns simulated PV panel output\n        \"\"\"\n        diurnal = self.get_diurnal_factor()\n        \n        cloud_factor = self.rng.uniform(0.7, 1.0)\n        \n        power_factor = diurnal * cloud_factor\n        current_power = self.max_power_w * power_factor\n        \n        current = current_power / self.base_voltage if self.base_voltage > 0 else 0.0\n        voltage = self.base_voltage + self.rng.uniform(-2, 2)\n        \n        return voltage, current, voltage, current\n","size_bytes":2668},"config.yaml":{"content":"site:\n  name: \"Reef Controller\"\n  timezone: \"Australia/Brisbane\"\n\n\nstages:\n  arrays:\n    - id: \"A1\"\n      name: \"Acropora (SPS) Lights\"\n      description: \"High-intensity lighting for SPS corals\"\n      enabled: true\n      auto: true\n      pwm_channel: 0\n      max_current_a: 4.0\n      nominal_voltage_v: 36.0\n      timer:\n        on: \"08:00\"\n        off: \"20:30\"\n      leds:\n        - id: \"L1\"\n          label: \"Front Blue\"\n          intensity_limit_pct: 100\n          priority: 1\n        - id: \"L2\"\n          label: \"Front White\"\n          intensity_limit_pct: 100\n          priority: 2\n        - id: \"L3\"\n          label: \"Center Blue\"\n          intensity_limit_pct: 90\n          priority: 3\n        - id: \"L4\"\n          label: \"Center White\"\n          intensity_limit_pct: 90\n          priority: 4\n        - id: \"L5\"\n          label: \"Rear Blue\"\n          intensity_limit_pct: 80\n          priority: 5\n        - id: \"L6\"\n          label: \"Rear White\"\n          intensity_limit_pct: 80\n          priority: 6\n    \n    - id: \"A2\"\n      name: \"LPS Lights\"\n      description: \"Medium-intensity lighting for LPS corals\"\n      enabled: true\n      auto: true\n      pwm_channel: 1\n      max_current_a: 3.0\n      nominal_voltage_v: 32.0\n      timer:\n        on: \"08:15\"\n        off: \"20:45\"\n      leds:\n        - id: \"L1\"\n          label: \"Front Blue\"\n          intensity_limit_pct: 100\n          priority: 1\n        - id: \"L2\"\n          label: \"Front White\"\n          intensity_limit_pct: 85\n          priority: 2\n        - id: \"L3\"\n          label: \"Center Blue\"\n          intensity_limit_pct: 85\n          priority: 3\n        - id: \"L4\"\n          label: \"Center White\"\n          intensity_limit_pct: 75\n          priority: 4\n        - id: \"L5\"\n          label: \"Rear Blue\"\n          intensity_limit_pct: 75\n          priority: 5\n        - id: \"L6\"\n          label: \"Rear White\"\n          intensity_limit_pct: 70\n          priority: 6\n    \n    - id: \"A3\"\n      name: \"Center Lights\"\n      description: \"Ambient lighting for center display\"\n      enabled: true\n      auto: true\n      pwm_channel: 2\n      max_current_a: 2.5\n      nominal_voltage_v: 28.0\n      timer:\n        on: \"08:30\"\n        off: \"21:00\"\n      leds:\n        - id: \"L1\"\n          label: \"Front Actinic\"\n          intensity_limit_pct: 100\n          priority: 1\n        - id: \"L2\"\n          label: \"Front Daylight\"\n          intensity_limit_pct: 90\n          priority: 2\n        - id: \"L3\"\n          label: \"Center Actinic\"\n          intensity_limit_pct: 80\n          priority: 3\n        - id: \"L4\"\n          label: \"Center Daylight\"\n          intensity_limit_pct: 80\n          priority: 4\n        - id: \"L5\"\n          label: \"Rear Actinic\"\n          intensity_limit_pct: 70\n          priority: 5\n        - id: \"L6\"\n          label: \"Rear Daylight\"\n          intensity_limit_pct: 70\n          priority: 6\n  \n  battery:\n    enabled: true\n    charge_limit_v: 14.2\n    float_v: 13.6\n    discharge_cutoff_v: 12.0\n    reserve_minutes: 60\n    max_discharge_w: 150\n    min_charge_surplus_w: 50\n\n\npower_budget:\n  target_watts: 400\n  restore_hysteresis_pct: 10\n  restore_delay_s: 10\n  pv_max_w: 600\n\n\nsimulator:\n  pv_diurnal_enabled: true\n  pv_cloud_variation_pct: 30\n  deterministic_seed: null\n\n\ntelemetry:\n  sample_interval_ms: 1000\n  persist_every_s: 10\n  history_retention_hours: 48\n\n\nalerts:\n  low_battery_v: 12.2\n  high_panel_v: 85.0\n  sensor_stale_s: 10\n  panel_offline_s: 120\n  webhook_url: null\n","size_bytes":3456},"app/stages/led_stage.py":{"content":"from .base import BaseStage\nfrom app.models import LED\n\n\nclass LEDStage(BaseStage):\n    def __init__(self, stage_id: str, sensor, gpio=None, config=None):\n        super().__init__(stage_id, sensor, gpio)\n        self.id = stage_id\n        self.name = config.get(\"name\", stage_id) if config else stage_id\n        self.description = config.get(\"description\", \"\") if config else \"\"\n        self.max_current_a = config.get(\"max_current_a\", 3.0) if config else 3.0\n        self.nominal_voltage_v = config.get(\"nominal_voltage_v\", 36.0) if config else 36.0\n        \n        self.leds = []\n        if config and \"leds\" in config:\n            for led_config in config[\"leds\"]:\n                led = LED(\n                    id=led_config[\"id\"],\n                    label=led_config[\"label\"],\n                    intensity_limit_pct=led_config[\"intensity_limit_pct\"],\n                    priority=led_config[\"priority\"],\n                    is_on=True,\n                    current_intensity_pct=0.0\n                )\n                self.leds.append(led)\n    \n    def apply_control(self, duty: float | None = None, enable: bool | None = None):\n        super().apply_control(duty, enable)\n        \n        for led in self.leds:\n            if led.is_on:\n                led.current_intensity_pct = (led.intensity_limit_pct / 100.0) * self.duty * 100\n","size_bytes":1340},"app/routers/telemetry.py":{"content":"from fastapi import APIRouter\n\n\nrouter = APIRouter()\n\n\n@router.get(\"/health\")\nasync def health():\n    return {\"ok\": True}\n","size_bytes":122},"app/stages/base.py":{"content":"from typing import Literal\nMode = Literal[\"OFF\", \"MANUAL\", \"AUTO\", \"REDUNDANT\"]\n\n\nclass BaseStage:\n    def __init__(self, stage_id: str, sensor, gpio=None):\n        self.stage_id = stage_id\n        self.sensor = sensor\n        self.gpio = gpio\n        self.mode: Mode = \"OFF\"\n        self.enabled = True\n        self.duty = 0.0\n    \n    def read_telemetry(self):\n        # Pass duty and enabled state to sensor for realistic simulation\n        vin, iin, vout, iout = self.sensor.read(self.duty, self.enabled)\n        return dict(vin_v=vin, iin_a=iin, vout_v=vout, iout_a=iout)\n    \n    def apply_control(self, duty: float | None = None, enable: bool | None = None):\n        if duty is not None:\n            self.duty = max(0.0, min(1.0, duty))\n        if enable is not None:\n            self.enabled = bool(enable)\n    \n    def set_mode(self, mode: Mode):\n        self.mode = mode\n    \n    def tick(self, config):\n        pass\n","size_bytes":927},"app/services/scheduler.py":{"content":"from apscheduler.schedulers.asyncio import AsyncIOScheduler\n\n\nclass JobScheduler:\n    def __init__(self, mgr, persist_cb=None, interval_s=1.0, power_allocator=None, wavemaker_manager=None, automation=None):\n        self.mgr = mgr\n        self.persist_cb = persist_cb\n        self.interval_s = interval_s\n        self.power_allocator = power_allocator\n        self.wavemaker_manager = wavemaker_manager\n        self.automation = automation\n        self.sched = AsyncIOScheduler()\n\n\n    def start(self, app):\n        @self.sched.scheduled_job(\"interval\", seconds=self.interval_s)\n        def sample_job():\n            snap = self.mgr.snapshot()\n            \n            if self.power_allocator:\n                arrays_status = []\n                pv_power = 0.0\n                battery_power = 0.0\n                \n                for stage in self.mgr.stages:\n                    if hasattr(stage, 'leds'):\n                        arrays_status.append({\n                            'id': stage.id,\n                            'name': stage.name,\n                            'description': stage.description,\n                            'enabled': stage.enabled,\n                            'mode': stage.mode,\n                            'duty': stage.duty,\n                            'leds': stage.leds,\n                            'max_current_a': stage.max_current_a,\n                            'nominal_voltage_v': stage.nominal_voltage_v,\n                            'vin_v': 0.0,\n                            'iin_a': 0.0,\n                            'vout_v': 0.0,\n                            'iout_a': 0.0,\n                            'power_w': 0.0\n                        })\n                \n                for reading in snap:\n                    if reading.stage_id == 'Battery':\n                        battery_power = reading.vout_v * reading.iout_a\n                        battery_voltage = reading.vout_v\n                    else:\n                        for arr in arrays_status:\n                            if reading.stage_id == arr['id']:\n                                arr['vin_v'] = reading.vin_v\n                                arr['iin_a'] = reading.iin_a\n                                arr['vout_v'] = reading.vout_v\n                                arr['iout_a'] = reading.iout_a\n                                arr['power_w'] = reading.vout_v * reading.iout_a\n                \n                from app.models import ArrayStatus\n                from datetime import datetime\n                import math\n                \n                array_objs = [ArrayStatus(**arr) for arr in arrays_status]\n                \n                now = datetime.now()\n                hour = now.hour + now.minute / 60.0\n                if hour < 6 or hour > 20:\n                    diurnal_factor = 0.0\n                elif hour < 8:\n                    diurnal_factor = (hour - 6) / 2.0\n                elif hour < 18:\n                    diurnal_factor = 1.0 - 0.2 * abs(13 - hour) / 5.0\n                else:\n                    diurnal_factor = 1.0 - (hour - 18) / 2.0\n                \n                max_pv_w = app.state.config.get('power_budget', {}).get('pv_max_w', 600)\n                pv_power = max_pv_w * diurnal_factor\n                \n                max_discharge_w = app.state.config.get('stages', {}).get('battery', {}).get('max_discharge_w', 150)\n                \n                low_battery_v = app.state.config.get('alerts', {}).get('low_battery_v', 12.2)\n                battery_ok = battery_voltage > low_battery_v if 'battery_voltage' in locals() else True\n                battery_available = max_discharge_w if battery_ok else 0\n                \n                shed, restored = self.power_allocator.allocate_power(array_objs, pv_power, battery_available)\n                \n                for array_id, led_id in shed + restored:\n                    stage = self.mgr.stage_dict.get(array_id)\n                    if stage and hasattr(stage, 'leds'):\n                        for led in stage.leds:\n                            if led.id == led_id:\n                                array_obj = next((a for a in array_objs if a.id == array_id), None)\n                                if array_obj:\n                                    led_obj = next((l for l in array_obj.leds if l.id == led_id), None)\n                                    if led_obj:\n                                        led.is_on = led_obj.is_on\n                                        led.current_intensity_pct = led_obj.current_intensity_pct\n                                break\n            \n            if self.persist_cb:\n                self.persist_cb(snap)\n            app.state.latest = snap\n        \n        if self.wavemaker_manager:\n            import time\n            \n            @self.sched.scheduled_job(\"interval\", seconds=0.05)\n            def wavemaker_control_loop():\n                \"\"\"20Hz wavemaker PWM control loop\"\"\"\n                self.wavemaker_manager.update_all(time.time())\n            \n            @self.sched.scheduled_job(\"interval\", seconds=1.0)\n            def wavemaker_telemetry_loop():\n                \"\"\"1Hz wavemaker telemetry sampling\"\"\"\n                self.wavemaker_manager.sample_all_power()\n        \n        if self.automation:\n            @self.sched.scheduled_job(\"interval\", seconds=60)\n            def automation_task_check():\n                \"\"\"1-minute interval task execution check\"\"\"\n                self.automation.check_and_execute_tasks()\n            \n            @self.sched.scheduled_job(\"interval\", seconds=1)\n            def feed_mode_timeout_check():\n                \"\"\"1-second interval feed mode timeout check\"\"\"\n                self.automation.check_feed_mode_timeout()\n        \n        self.sched.start()\n","size_bytes":5767},"README.md":{"content":"# Reef Controller - Professional Aquarium Automation System\n\nA sophisticated touch-enabled web application for controlling and monitoring reef aquarium equipment with intelligent power management and beautiful visualizations.\n\n## ðŸŒŠ Features\n\n### Per-LED Array Control\n- **3 LED Arrays**: Acropora (SPS), LPS, and Center Lights\n- **6 Individual LEDs per array** with configurable:\n  - Display names\n  - Intensity limits (0-100%)\n  - Priority levels for power shedding\n- Real-time intensity sliders with live telemetry feedback\n\n### Intelligent Power Management\n- **Automatic LED Shedding**: When power budget is exceeded, LEDs are automatically disabled in priority order (lowest priority first)\n- **Hysteresis-Controlled Restoration**: LEDs restore when surplus power is available for a sustained period (configurable delay)\n- **Event Logging**: All shedding and restoration events are tracked and displayed\n- **Configurable Budget**: Set target watts and restoration parameters in config.yaml\n\n### Touch-Optimized UI (1920Ã—1080)\n- **Weather-App Aesthetic**: Soft gradients, frosted glass cards, professional spacing\n- **Touch Targets**: All interactive elements â‰¥48Ã—48px (primary buttons â‰¥56Ã—56px)\n- **Responsive Layout**: Header with live clock, 3-column array grid, right sidebar\n- **Real-Time Updates**: All data refreshes every 2 seconds\n\n### System Monitoring\n- **Live Telemetry**: Voltage, current, and power for each array\n- **System Load Dashboard**: PV input, total load, battery flow, power budget\n- **System Health**: Color-coded status (green/yellow/red) with detailed alerts\n- **Event Feed**: Recent shed/restore/warning/alert events\n- **Task Scheduling**: View completed and upcoming automation tasks\n\n### Data Visualization\n- **Sparklines**: Mini power graphs on each array card (last 15 minutes)\n- **History Charts**: Click any array to view detailed voltage/current/power history\n- **Load Sparkline**: System-wide PV input visualization\n\n## ðŸš€ Quick Start\n\n### Running Locally\n```bash\n# Install dependencies (automatic on Replit)\n# Start the server\npython -m uvicorn app.main:app --host 0.0.0.0 --port 5000\n```\n\nVisit `http://localhost:5000` in your browser (optimized for 1920Ã—1080 displays).\n\n### Configuration\n\nEdit `config.yaml` to customize:\n\n```yaml\nstages:\n  arrays:\n    - id: \"A1\"\n      name: \"Acropora (SPS) Lights\"\n      max_current_a: 4.0\n      nominal_voltage_v: 36.0\n      leds:\n        - id: \"L1\"\n          label: \"Front Blue\"\n          intensity_limit_pct: 100\n          priority: 1  # Highest priority (shed last)\n\npower_budget:\n  target_watts: 400          # Maximum allowed system load\n  restore_hysteresis_pct: 10 # Require 10% surplus before restore\n  restore_delay_s: 10        # Wait 10s with surplus before restore\n```\n\n## ðŸ§ª Testing Power Shedding\n\n### Method 1: Lower the Power Budget\n1. Edit `config.yaml` and set `power_budget.target_watts: 50`\n2. Restart the application\n3. Set all arrays to 100% intensity\n4. Watch LEDs shed automatically in priority order\n5. Lower array intensity to create surplus\n6. Watch LEDs restore after 10 seconds\n\n### Method 2: Simulate Low PV Input\nThe PV simulator uses time-of-day to generate realistic solar curves:\n- **6 AM - 8 AM**: Sunrise (0% â†’ 100%)\n- **8 AM - 6 PM**: Full sun (100% with cloud variation Â±30%)\n- **6 PM - 8 PM**: Sunset (100% â†’ 0%)\n- **8 PM - 6 AM**: Night (0%)\n\nRun the app during simulated \"night\" hours or modify the simulator's time calculation.\n\n### Method 3: Manual API Testing\n```bash\n# Get current system load\ncurl http://localhost:5000/api/system/load\n\n# Set all arrays to maximum\ncurl -X POST http://localhost:5000/api/control \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"stage_id\": \"A1\", \"mode\": \"MANUAL\", \"duty\": 1.0}'\n\n# Watch events feed\ncurl http://localhost:5000/api/events?limit=20\n```\n\n## ðŸ“± Using the Touch Interface\n\n### Main Controls\n- **Array Intensity Sliders**: Drag to adjust 0-100% duty cycle\n- **Settings Button** (âš™): Click to modify LED names, limits, and priorities\n- **Array Cards**: Click to view detailed power history charts\n\n### LED Indicators\nEach LED shows:\n- **Status Dot**: Green (on) or gray (off)\n- **Current Intensity**: Actual output percentage\n- **Priority Number**: P1-P6 (P1 = highest priority, sheds last)\n\n### Settings Modal\n- Edit LED display names\n- Adjust intensity limits (0-100%)\n- Priority is shown but reordering not yet implemented\n\n### System Monitoring\n- **System Load**: Real-time PV, load, battery, and budget\n- **Upcoming Tasks**: Next scheduled automation events\n- **Completed Tasks**: Recent task history\n- **Recent Events**: Shed/restore/alert timeline\n\n## ðŸ—ï¸ Architecture\n\n### Backend (FastAPI)\n```\napp/\nâ”œâ”€â”€ main.py                    # Application entry point\nâ”œâ”€â”€ config.py                  # Configuration loader\nâ”œâ”€â”€ models.py                  # Pydantic data models\nâ”œâ”€â”€ drivers/\nâ”‚   â””â”€â”€ sensors_sim.py         # Simulated sensors (PV diurnal curve)\nâ”œâ”€â”€ services/\nâ”‚   â”œâ”€â”€ stage_manager.py       # LED array lifecycle\nâ”‚   â”œâ”€â”€ power_allocator.py     # Shedding/restoration logic\nâ”‚   â”œâ”€â”€ events.py              # Event tracking\nâ”‚   â”œâ”€â”€ automation.py          # Task scheduling\nâ”‚   â”œâ”€â”€ system_health.py       # Health monitoring\nâ”‚   â”œâ”€â”€ scheduler.py           # Periodic jobs\nâ”‚   â””â”€â”€ storage.py             # SQLite persistence\nâ”œâ”€â”€ routers/\nâ”‚   â”œâ”€â”€ arrays.py              # New LED array endpoints\nâ”‚   â”œâ”€â”€ automation.py          # Tasks and wave modes\nâ”‚   â”œâ”€â”€ control.py             # Manual control\nâ”‚   â”œâ”€â”€ config_api.py          # Status and snapshot\nâ”‚   â””â”€â”€ telemetry.py           # Health check\nâ””â”€â”€ stages/\n    â”œâ”€â”€ led_stage.py           # LED array implementation\n    â””â”€â”€ battery_stage.py       # Battery management\n```\n\n### Key Services\n\n#### Power Allocator\nImplements intelligent load management:\n- Calculates total load from all arrays\n- Sheds LEDs when load > available power\n- Restores LEDs with hysteresis and delay\n- Logs all events for auditing\n\n#### Events Service\nTracks system events in memory:\n- Shed/restore operations\n- System warnings and alerts\n- Ring buffer (200 events max)\n- Queryable via API\n\n#### PV Simulator\nRealistic solar panel behavior:\n- Diurnal curve (sunrise/sunset)\n- Cloud variation (Â±30%)\n- Time-of-day dependent output\n- Deterministic mode for testing\n\n### API Endpoints\n\n#### Array Management\n- `GET /api/arrays` - List all arrays with LED status\n- `POST /api/arrays/{id}/settings` - Update LED configuration\n- `GET /api/history/array/{id}?range_hours=1` - Array power history\n\n#### System Monitoring\n- `GET /api/system/load` - PV, load, battery, budget\n- `GET /api/system/health` - System status and alerts\n- `GET /api/events?limit=50` - Recent events\n\n#### Legacy Endpoints (Maintained)\n- `GET /api/status` - Stage status\n- `GET /api/snapshot` - Latest telemetry\n- `POST /api/control` - Manual control\n- `GET /api/automation/*` - Tasks and wave modes\n\n## ðŸ”§ Simulation Mode\n\nAll features work in simulation mode without hardware:\n\n### Simulated Behavior\n- **PV Output**: 0-600W based on time of day\n- **Array Current**: Scales with duty cycle (0-100% = 0-max_current_a)\n- **Voltage Droop**: Up to 8% drop at full load\n- **LED Intensity**: Respects individual LED limits\n- **Power Shedding**: Realistic budget enforcement\n\n### Deterministic Testing\nSet `simulator.deterministic_seed` in config.yaml for repeatable tests.\n\n## ðŸŽ¨ Design Philosophy\n\n### Touch-First\n- All controls sized for finger interaction\n- Generous spacing (8-12px gaps)\n- Large touch targets (48Ã—48px minimum)\n- Immediate visual feedback\n\n### Weather-App Aesthetic\n- Soft gradient background\n- Frosted glass cards with subtle shadows\n- Rounded corners (16-20px)\n- Professional color palette\n- Minimal, clean typography\n\n### Performance\n- Vanilla JavaScript (no frameworks)\n- Efficient 2-second polling\n- Lightweight assets\n- Single-page application\n\n## ðŸ“Š Configuration Reference\n\n### Array Settings\n```yaml\nstages:\n  arrays:\n    - id: \"A1\"              # Unique identifier\n      name: \"Display Name\"  # Shown in UI\n      description: \"Info\"   # Card subtitle\n      max_current_a: 4.0    # Maximum current draw\n      nominal_voltage_v: 36 # Nominal output voltage\n      leds: [...]           # 6 LED configurations\n```\n\n### LED Configuration\n```yaml\nleds:\n  - id: \"L1\"                    # L1-L6\n    label: \"Front Blue\"         # Display name\n    intensity_limit_pct: 100    # 0-100% cap\n    priority: 1                 # 1-6 (1=highest)\n```\n\n### Power Budget\n```yaml\npower_budget:\n  target_watts: 400              # Maximum system load\n  restore_hysteresis_pct: 10     # Surplus margin for restore\n  restore_delay_s: 10            # Delay before restore\n  pv_max_w: 600                  # Simulator PV capacity\n```\n\n## ðŸš¢ Deployment\n\nConfigured for Replit autoscale deployment:\n- Stateless design\n- SQLite persistence\n- Environment-based config\n- Port 5000 public access\n\nClick **Deploy** in Replit to publish!\n\n## ðŸ“ Future Enhancements\n\n- [ ] Drag-to-reorder LED priorities in settings\n- [ ] Real hardware integration (INA219, GPIO)\n- [ ] User authentication\n- [ ] Multi-tank support\n- [ ] Mobile responsive design\n- [ ] Advanced scheduling (sunrise/sunset sync)\n- [ ] Historical data export\n- [ ] Custom alert webhooks\n\n## ðŸ¤ Contributing\n\nThis is a demonstration project. For production use, consider:\n- Adding authentication/authorization\n- Implementing database migrations\n- Adding comprehensive testing\n- Hardware safety interlocks\n- Backup power monitoring\n\n## ðŸ“„ License\n\nMIT License - Free for personal and commercial use.\n\n---\n\n**Built with â¤ï¸ for reef aquarium hobbyists**\n","size_bytes":9771},"app/stages/battery_stage.py":{"content":"from .base import BaseStage\n\n\nclass BatteryStage(BaseStage):\n    pass\n","size_bytes":70},"app/services/storage.py":{"content":"from sqlmodel import SQLModel, Field, create_engine, Session, select, Column, JSON\nfrom datetime import datetime\nfrom typing import Optional, List\n\n\nclass TelemetryRow(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    ts: datetime\n    stage_id: str\n    vin_v: float\n    iin_a: float\n    vout_v: float\n    iout_a: float\n    mode: str\n    power_w: float = 0.0\n\n\nclass WavemakerPreset(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    name: str = Field(index=True)\n    description: str = \"\"\n    cycle_duration_sec: int = 60\n    is_built_in: bool = False\n    flow_curves: dict = Field(default={}, sa_column=Column(JSON))\n\n\nclass ScheduledTaskRow(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    name: str\n    task_type: str\n    time: str\n    enabled: bool = True\n    preset_id: Optional[int] = None\n    days_of_week: Optional[str] = None\n\n\ndef make_db(db_url: str):\n    engine = create_engine(db_url)\n    SQLModel.metadata.create_all(engine)\n    return engine\n\n\nclass Store:\n    def __init__(self, engine):\n        self.engine = engine\n    \n    def persist(self, rows):\n        with Session(self.engine) as s:\n            for r in rows:\n                data = r.model_dump()\n                if 'power_w' not in data and 'vout_v' in data and 'iout_a' in data:\n                    data['power_w'] = data['vout_v'] * data['iout_a']\n                s.add(TelemetryRow(**data))\n            s.commit()\n    \n    def get_history(self, stage_id: str, since: datetime, limit: int = 1000) -> List[TelemetryRow]:\n        with Session(self.engine) as s:\n            statement = (\n                select(TelemetryRow)\n                .where(TelemetryRow.stage_id == stage_id)\n                .where(TelemetryRow.ts >= since)\n                .order_by(TelemetryRow.ts.desc())\n                .limit(limit)\n            )\n            results = s.exec(statement).all()\n            return list(results)\n    \n    def query_telemetry_range(self, stage_id: str, start: datetime, end: datetime) -> List:\n        with Session(self.engine) as s:\n            statement = (\n                select(TelemetryRow)\n                .where(TelemetryRow.stage_id == stage_id)\n                .where(TelemetryRow.ts >= start)\n                .where(TelemetryRow.ts <= end)\n                .order_by(TelemetryRow.ts.asc())\n            )\n            results = s.exec(statement).all()\n            return [{\"timestamp\": r.ts, \"vout_v\": r.vout_v, \"iout_a\": r.iout_a, \"power_w\": r.power_w} for r in results]\n    \n    def get_all_presets(self) -> List[WavemakerPreset]:\n        with Session(self.engine) as s:\n            statement = select(WavemakerPreset).order_by(WavemakerPreset.name)\n            results = s.exec(statement).all()\n            return list(results)\n    \n    def get_preset(self, preset_id: int) -> Optional[WavemakerPreset]:\n        with Session(self.engine) as s:\n            return s.get(WavemakerPreset, preset_id)\n    \n    def get_preset_by_name(self, name: str) -> Optional[WavemakerPreset]:\n        with Session(self.engine) as s:\n            statement = select(WavemakerPreset).where(WavemakerPreset.name == name)\n            return s.exec(statement).first()\n    \n    def create_preset(self, preset: WavemakerPreset) -> WavemakerPreset:\n        with Session(self.engine) as s:\n            s.add(preset)\n            s.commit()\n            s.refresh(preset)\n            return preset\n    \n    def update_preset(self, preset_id: int, **kwargs) -> Optional[WavemakerPreset]:\n        with Session(self.engine) as s:\n            preset = s.get(WavemakerPreset, preset_id)\n            if not preset:\n                return None\n            if preset.is_built_in:\n                return None\n            for key, value in kwargs.items():\n                if hasattr(preset, key):\n                    setattr(preset, key, value)\n            s.add(preset)\n            s.commit()\n            s.refresh(preset)\n            return preset\n    \n    def delete_preset(self, preset_id: int) -> bool:\n        with Session(self.engine) as s:\n            preset = s.get(WavemakerPreset, preset_id)\n            if not preset or preset.is_built_in:\n                return False\n            s.delete(preset)\n            s.commit()\n            return True\n    \n    def get_all_scheduled_tasks(self) -> List[ScheduledTaskRow]:\n        with Session(self.engine) as s:\n            statement = select(ScheduledTaskRow).order_by(ScheduledTaskRow.time)\n            results = s.exec(statement).all()\n            return list(results)\n    \n    def get_scheduled_task(self, task_id: int) -> Optional[ScheduledTaskRow]:\n        with Session(self.engine) as s:\n            return s.get(ScheduledTaskRow, task_id)\n    \n    def create_scheduled_task(self, task: ScheduledTaskRow) -> ScheduledTaskRow:\n        with Session(self.engine) as s:\n            s.add(task)\n            s.commit()\n            s.refresh(task)\n            return task\n    \n    def update_scheduled_task(self, task_id: int, **kwargs) -> Optional[ScheduledTaskRow]:\n        with Session(self.engine) as s:\n            task = s.get(ScheduledTaskRow, task_id)\n            if not task:\n                return None\n            for key, value in kwargs.items():\n                if hasattr(task, key):\n                    setattr(task, key, value)\n            s.add(task)\n            s.commit()\n            s.refresh(task)\n            return task\n    \n    def delete_scheduled_task(self, task_id: int) -> bool:\n        with Session(self.engine) as s:\n            task = s.get(ScheduledTaskRow, task_id)\n            if not task:\n                return False\n            s.delete(task)\n            s.commit()\n            return True\n","size_bytes":5754},"app/routers/config_api.py":{"content":"from fastapi import APIRouter, Request\n\n\nrouter = APIRouter()\n\n\n@router.get(\"/status\")\nasync def status(request: Request):\n    mgr = request.app.state.mgr\n    return [s.model_dump() for s in mgr.list_status()]\n\n\n@router.get(\"/snapshot\")\nasync def snapshot(request: Request):\n    return [r.model_dump() for r in request.app.state.latest]\n","size_bytes":337},"app/routers/control.py":{"content":"from fastapi import APIRouter, HTTPException, Request\nfrom ..models import ControlRequest\n\n\nrouter = APIRouter()\n\n\n@router.post(\"/control\")\nasync def control(req: ControlRequest, request: Request):\n    mgr = request.app.state.mgr\n    if req.stage_id not in mgr.stages:\n        raise HTTPException(404, \"stage not found\")\n    mgr.control(req.stage_id, mode=req.mode, duty=req.duty, enable=req.enable)\n    return {\"ok\": True}\n","size_bytes":424},"app/services/power_allocator.py":{"content":"from datetime import datetime, timedelta\nfrom typing import Dict, List, Tuple\nfrom app.models import LED, ArrayStatus\nfrom app.services.events import EventsService\n\n\nclass PowerAllocator:\n    def __init__(self, config: dict, events: EventsService):\n        self.config = config\n        self.events = events\n        self.target_watts = config.get(\"power_budget\", {}).get(\"target_watts\", 400)\n        self.restore_hysteresis_pct = config.get(\"power_budget\", {}).get(\"restore_hysteresis_pct\", 10)\n        self.restore_delay_s = config.get(\"power_budget\", {}).get(\"restore_delay_s\", 10)\n        \n        self.last_shed_time: Dict[Tuple[str, str], datetime] = {}\n        self.surplus_start_time: Dict[Tuple[str, str], datetime] = {}\n    \n    def calculate_load(self, arrays: List[ArrayStatus]) -> float:\n        total_load = 0.0\n        for array in arrays:\n            if array.enabled:\n                total_load += array.power_w\n        return total_load\n    \n    def get_all_leds_sorted_by_priority(self, arrays: List[ArrayStatus]) -> List[Tuple[str, LED]]:\n        all_leds = []\n        for array in arrays:\n            if array.enabled:\n                for led in array.leds:\n                    all_leds.append((array.id, led))\n        \n        all_leds.sort(key=lambda x: x[1].priority, reverse=True)\n        return all_leds\n    \n    def shed_leds(\n        self,\n        arrays: List[ArrayStatus],\n        pv_w: float,\n        battery_w_available: float\n    ) -> List[Tuple[str, str]]:\n        available_power = pv_w + battery_w_available\n        current_load = self.calculate_load(arrays)\n        \n        if current_load <= available_power:\n            return []\n        \n        power_to_reduce = current_load - available_power\n        leds_to_shed = []\n        \n        all_leds = self.get_all_leds_sorted_by_priority(arrays)\n        \n        for array_id, led in all_leds:\n            if not led.is_on:\n                continue\n            \n            array = next(a for a in arrays if a.id == array_id)\n            \n            led_power = (led.current_intensity_pct / 100.0) * (array.power_w / len([l for l in array.leds if l.is_on]))\n            \n            led.is_on = False\n            led.current_intensity_pct = 0.0\n            leds_to_shed.append((array_id, led.id))\n            \n            self.last_shed_time[(array_id, led.id)] = datetime.now()\n            self.events.add_event(\n                event_type=\"shed\",\n                message=f\"Shed {array.name} - {led.label}\",\n                array_id=array_id,\n                led_id=led.id,\n                details={\n                    \"reason\": \"insufficient_power\",\n                    \"available_w\": available_power,\n                    \"load_w\": current_load,\n                    \"led_power_w\": led_power\n                }\n            )\n            \n            power_to_reduce -= led_power\n            \n            if power_to_reduce <= 0:\n                break\n        \n        return leds_to_shed\n    \n    def restore_leds(\n        self,\n        arrays: List[ArrayStatus],\n        pv_w: float,\n        battery_w_available: float\n    ) -> List[Tuple[str, str]]:\n        available_power = pv_w + battery_w_available\n        current_load = self.calculate_load(arrays)\n        \n        surplus = available_power - current_load\n        required_surplus = available_power * (self.restore_hysteresis_pct / 100.0)\n        \n        if surplus <= required_surplus:\n            self.surplus_start_time.clear()\n            return []\n        \n        leds_to_restore = []\n        \n        all_leds = self.get_all_leds_sorted_by_priority(arrays)\n        all_leds.reverse()\n        \n        now = datetime.now()\n        \n        for array_id, led in all_leds:\n            if led.is_on:\n                continue\n            \n            key = (array_id, led.id)\n            \n            if key not in self.surplus_start_time:\n                self.surplus_start_time[key] = now\n                continue\n            \n            if (now - self.surplus_start_time[key]).total_seconds() < self.restore_delay_s:\n                continue\n            \n            array = next(a for a in arrays if a.id == array_id)\n            \n            estimated_power = (led.intensity_limit_pct / 100.0) * array.duty * (array.max_current_a * array.nominal_voltage_v / len(array.leds))\n            \n            if estimated_power > surplus:\n                continue\n            \n            led.is_on = True\n            led.current_intensity_pct = led.intensity_limit_pct * array.duty\n            leds_to_restore.append((array_id, led.id))\n            \n            self.events.add_event(\n                event_type=\"restore\",\n                message=f\"Restored {array.name} - {led.label}\",\n                array_id=array_id,\n                led_id=led.id,\n                details={\n                    \"available_w\": available_power,\n                    \"load_w\": current_load,\n                    \"surplus_w\": surplus,\n                    \"estimated_led_power_w\": estimated_power\n                }\n            )\n            \n            surplus -= estimated_power\n            self.surplus_start_time.pop(key, None)\n        \n        return leds_to_restore\n    \n    def allocate_power(\n        self,\n        arrays: List[ArrayStatus],\n        pv_w: float,\n        battery_w_available: float\n    ) -> Tuple[List[Tuple[str, str]], List[Tuple[str, str]]]:\n        shed = self.shed_leds(arrays, pv_w, battery_w_available)\n        restored = self.restore_leds(arrays, pv_w, battery_w_available)\n        \n        return (shed, restored)\n","size_bytes":5575},"app/services/system_health.py":{"content":"from typing import List, Dict\nimport random\n\n\nclass SystemHealthService:\n    def __init__(self):\n        self.warnings = []\n        self.errors = []\n        self.last_check = None\n    \n    def check_health(self, stages_data) -> Dict:\n        \"\"\"Check system health based on current stage data\"\"\"\n        self.warnings = []\n        self.errors = []\n        \n        # Check battery voltage\n        for stage in stages_data:\n            if stage.get(\"stage_id\") == \"Battery\":\n                vout = stage.get(\"vout_v\", 0)\n                if vout < 12.2:\n                    self.errors.append(\"Battery critically low - charging required\")\n                elif vout < 13.0:\n                    self.warnings.append(\"Battery voltage below optimal\")\n        \n        # Check LED arrays\n        for stage in stages_data:\n            if \"Array\" in stage.get(\"stage_id\", \"\"):\n                vin = stage.get(\"vin_v\", 0)\n                if vin > 80:\n                    self.warnings.append(f\"{stage['stage_id']}: Panel voltage high\")\n                elif vin < 20:\n                    self.errors.append(f\"{stage['stage_id']}: Panel offline or disconnected\")\n        \n        # Simulate occasional warnings\n        if random.random() < 0.1:\n            self.warnings.append(\"Temperature sensor reading slightly elevated\")\n        \n        # Determine overall status\n        if self.errors:\n            status = \"error\"\n            color = \"#ff4444\"\n        elif self.warnings:\n            status = \"warning\"\n            color = \"#ffaa00\"\n        else:\n            status = \"ok\"\n            color = \"#44ff44\"\n        \n        return {\n            \"status\": status,\n            \"color\": color,\n            \"errors\": self.errors,\n            \"warnings\": self.warnings,\n            \"info\": [] if (self.errors or self.warnings) else [\"All systems nominal\"]\n        }\n","size_bytes":1854},"app/services/events.py":{"content":"from datetime import datetime\nfrom collections import deque\nfrom typing import List, Literal, Optional\nfrom app.models import PowerEvent\n\n\nclass EventsService:\n    def __init__(self, max_events: int = 100):\n        self.events: deque = deque(maxlen=max_events)\n    \n    def add_event(\n        self,\n        event_type: Literal[\"shed\", \"restore\", \"alert\", \"warning\"],\n        message: str,\n        array_id: Optional[str] = None,\n        led_id: Optional[str] = None,\n        details: Optional[dict] = None\n    ):\n        event = PowerEvent(\n            timestamp=datetime.now(),\n            event_type=event_type,\n            array_id=array_id,\n            led_id=led_id,\n            message=message,\n            details=details or {}\n        )\n        self.events.appendleft(event)\n        return event\n    \n    def get_recent_events(self, limit: int = 50) -> List[PowerEvent]:\n        return list(self.events)[:limit]\n    \n    def clear(self):\n        self.events.clear()\n","size_bytes":974},"app/routers/automation.py":{"content":"from fastapi import APIRouter, Request, HTTPException\nfrom pydantic import BaseModel\nfrom app.models import ScheduledTask, ScheduledTaskRequest\nfrom app.services.storage import ScheduledTaskRow\nimport json\n\n\nrouter = APIRouter()\n\n\nclass WaveModeRequest(BaseModel):\n    mode: str\n\n\n@router.get(\"/automation/tasks/completed\")\nasync def get_completed_tasks(request: Request):\n    automation = request.app.state.automation\n    return automation.get_completed_tasks()\n\n\n@router.get(\"/automation/tasks/upcoming\")\nasync def get_upcoming_tasks(request: Request):\n    automation = request.app.state.automation\n    return automation.get_upcoming_tasks()\n\n\n@router.get(\"/automation/wave-modes\")\nasync def get_wave_modes(request: Request):\n    automation = request.app.state.automation\n    return {\n        \"modes\": automation.get_wave_modes(),\n        \"current\": automation.get_current_wave_mode()\n    }\n\n\n@router.post(\"/automation/wave-modes\")\nasync def set_wave_mode(req: WaveModeRequest, request: Request):\n    automation = request.app.state.automation\n    success = automation.set_wave_mode(req.mode)\n    return {\"success\": success, \"mode\": req.mode if success else automation.get_current_wave_mode()}\n\n\n@router.get(\"/system/health\")\nasync def get_system_health(request: Request):\n    health = request.app.state.health\n    latest_data = [r.model_dump() for r in request.app.state.latest]\n    return health.check_health(latest_data)\n\n\n@router.get(\"/automation/scheduled\")\nasync def get_all_scheduled_tasks(request: Request):\n    store = request.app.state.store\n    tasks = store.get_all_scheduled_tasks()\n    return [\n        ScheduledTask(\n            id=t.id,\n            name=t.name,\n            task_type=t.task_type,\n            time=t.time,\n            enabled=t.enabled,\n            preset_id=t.preset_id,\n            days_of_week=json.loads(t.days_of_week) if t.days_of_week else None\n        )\n        for t in tasks\n    ]\n\n\ndef check_schedule_conflict(store, time: str, days_of_week, task_type: str, exclude_task_id=None):\n    \"\"\"Check if a scheduled task conflicts with existing tasks at the same time.\n    Only checks for conflicts between tasks of the same type (e.g., preset_activation vs preset_activation).\n    This allows different task types (presets, feeding, pumps) to be scheduled at the same time.\"\"\"\n    all_tasks = store.get_all_scheduled_tasks()\n    \n    for task in all_tasks:\n        if task.id == exclude_task_id:\n            continue\n        if not task.enabled:\n            continue\n        if task.time != time:\n            continue\n        \n        if task_type == 'preset_activation' and task.task_type == 'preset_activation':\n            task_days = json.loads(task.days_of_week) if task.days_of_week else []\n            new_days = days_of_week or []\n            \n            if len(task_days) == 0 and len(new_days) == 0:\n                return task\n            if len(task_days) == 0 or len(new_days) == 0:\n                return task\n            \n            if any(day in new_days for day in task_days):\n                return task\n    \n    return None\n\n\n@router.post(\"/automation/scheduled\")\nasync def create_scheduled_task(task_req: ScheduledTaskRequest, request: Request):\n    store = request.app.state.store\n    \n    if task_req.enabled:\n        conflict = check_schedule_conflict(store, task_req.time, task_req.days_of_week, task_req.task_type)\n        if conflict:\n            day_text = \"on selected days\" if task_req.days_of_week else \"every day\"\n            raise HTTPException(\n                status_code=409,\n                detail=f'Scheduling conflict: \"{conflict.name}\" already scheduled at {task_req.time} {day_text}'\n            )\n    \n    task_row = ScheduledTaskRow(\n        name=task_req.name,\n        task_type=task_req.task_type,\n        time=task_req.time,\n        enabled=task_req.enabled,\n        preset_id=task_req.preset_id,\n        days_of_week=json.dumps(task_req.days_of_week) if task_req.days_of_week else None\n    )\n    created = store.create_scheduled_task(task_row)\n    return ScheduledTask(\n        id=created.id,\n        name=created.name,\n        task_type=created.task_type,\n        time=created.time,\n        enabled=created.enabled,\n        preset_id=created.preset_id,\n        days_of_week=json.loads(created.days_of_week) if created.days_of_week else None\n    )\n\n\n@router.put(\"/automation/scheduled/{task_id}\")\nasync def update_scheduled_task(task_id: int, task_req: ScheduledTaskRequest, request: Request):\n    store = request.app.state.store\n    \n    if task_req.enabled:\n        conflict = check_schedule_conflict(store, task_req.time, task_req.days_of_week, task_req.task_type, exclude_task_id=task_id)\n        if conflict:\n            day_text = \"on selected days\" if task_req.days_of_week else \"every day\"\n            raise HTTPException(\n                status_code=409,\n                detail=f'Scheduling conflict: \"{conflict.name}\" already scheduled at {task_req.time} {day_text}'\n            )\n    \n    update_data = {\n        \"name\": task_req.name,\n        \"task_type\": task_req.task_type,\n        \"time\": task_req.time,\n        \"enabled\": task_req.enabled,\n        \"preset_id\": task_req.preset_id,\n        \"days_of_week\": json.dumps(task_req.days_of_week) if task_req.days_of_week else None\n    }\n    updated = store.update_scheduled_task(task_id, **update_data)\n    if not updated:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    return ScheduledTask(\n        id=updated.id,\n        name=updated.name,\n        task_type=updated.task_type,\n        time=updated.time,\n        enabled=updated.enabled,\n        preset_id=updated.preset_id,\n        days_of_week=json.loads(updated.days_of_week) if updated.days_of_week else None\n    )\n\n\n@router.delete(\"/automation/scheduled/{task_id}\")\nasync def delete_scheduled_task(task_id: int, request: Request):\n    store = request.app.state.store\n    success = store.delete_scheduled_task(task_id)\n    if not success:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    return {\"success\": True}\n\n\n@router.post(\"/feed/start\")\nasync def start_feed_mode(request: Request):\n    automation = request.app.state.automation\n    result = automation.start_feed_mode()\n    if not result.get(\"success\"):\n        raise HTTPException(status_code=400, detail=result.get(\"message\", \"Failed to start feed mode\"))\n    return result\n\n\n@router.get(\"/feed/status\")\nasync def get_feed_status(request: Request):\n    automation = request.app.state.automation\n    return automation.get_feed_mode_status()\n\n\n@router.post(\"/feed/stop\")\nasync def stop_feed_mode(request: Request):\n    automation = request.app.state.automation\n    result = automation.stop_feed_mode()\n    if not result.get(\"success\"):\n        raise HTTPException(status_code=400, detail=result.get(\"message\", \"Failed to stop feed mode\"))\n    return result\n","size_bytes":6865},"replit.md":{"content":"# Reef Controller\n\n**Current Version: v1.5.2**\n\n## Version History\n- **v1.5.2** (Nov 17, 2025): Improved calendar visibility with dark borders and white backgrounds for readable text on purple gradient, removed duplicate 8am task from database, updated conflict detection to be type-specific (only preset_activation tasks conflict with each other, allowing future pump/feeding schedules to coexist with flow presets)\n- **v1.5.1** (Nov 17, 2025): Fixed calendar grid layout using CSS Grid (proper 8Ã—25 grid with time labels + 7 day columns) and added comprehensive conflict detection system - client-side validation shows immediate toast feedback, server-side authoritative checks return HTTP 409 on scheduling conflicts, prevents multiple presets at same time with clear error messages describing conflicts\n- **v1.5.0** (Nov 17, 2025): Created dedicated full-screen Schedule Calendar modal (95vwÃ—90vh) accessible via new \"Schedule Calendar\" button, featuring weekly grid display (24 hours x 7 days) with visual task placement, clickable cells to create tasks with pre-filled time/day, and clickable task badges to edit existing tasks - calendar opens/closes independently while scheduler modal remains simple list-based editor\n- **v1.4.0** (Nov 17, 2025): Added calendar view to scheduler modal with weekly grid display (24 hours x 7 days), visual task placement at scheduled times, clickable cells to create new tasks with pre-filled time/day, and clickable task badges to edit existing tasks using proper selectTaskForEditing() integration\n- **v1.3.1** (Nov 17, 2025): UX polish - implemented toast notification system to replace iframe-blocking alert() calls with non-blocking success/error/info toasts, updated Feed Mode button to toggle functionality (click to start, click again to cancel), removed button hover bounce effects for cleaner interaction\n- **v1.3.0** (Nov 17, 2025): Added feed mode system with manual button that pauses all wavemakers for 10 minutes and automatically restores previous preset, built complete scheduler UI modal for creating/editing/deleting scheduled preset activations with time picker and day-of-week filtering, integrated feed mode with scheduler (pauses scheduled changes during feeding), improved feed mode robustness with name-based preset lookup and proper HTTP error handling\n- **v1.2.3** (Nov 17, 2025): UX improvements - changed wavemaker channel display from 0-5 to user-friendly 1-6 numbering, added individual \"Clear\" buttons to each wavemaker curve editor for resetting curves without deleting presets\n- **v1.2.2** (Nov 17, 2025): Enhanced preset selector stability with comprehensive hash-based change detection (ID, name, description) and fixed flow pattern canvas updates to refresh on every polling cycle\n- **v1.2.1** (Nov 17, 2025): UI polish - fixed Canvas keyframe editor coordinate mapping for accurate mouse interaction, removed individual wavemaker controls and added visual flow pattern displays, fixed preset selector jumping on refresh\n- **v1.2.0** (Nov 17, 2025): Added graphical preset editor with Canvas-based curve design, interactive keyframe editing, and automated scheduler for time-based preset switching\n- **v1.1.0** (Nov 17, 2025): Added preset-based wavemaker control system with 6 built-in flow patterns, interpolated power curves, REST API, and frontend preset selector\n- **v1.0.0**: Initial release with LED control, battery management, individual wavemaker control, and power allocation\n\n## Overview\nReef Controller is a sophisticated web-based application built with FastAPI, designed for real-time monitoring and control of reef aquarium equipment. Its primary purpose is to manage LED lighting arrays, battery backup systems, and wave pumps through an intuitive web interface. The project aims to provide comprehensive control over an aquarium environment, featuring real-time telemetry, interactive controls, and intelligent power management capabilities. Key ambitions include offering production-ready wave pump control with various patterns, granular per-LED control with intelligent power shedding, and a touch-optimized user interface for easy interaction.\n\n## User Preferences\nNone specified yet.\n\n## System Architecture\nThe Reef Controller is built upon a FastAPI backend and a vanilla JavaScript frontend, emphasizing a touch-optimized user experience.\n\n### UI/UX Decisions\n- **Touch-Optimized Interface**: Designed for 1920x1080 displays with large touch targets (minimum 48x48px) and a \"weather-app\" styling featuring ocean gradient backgrounds and clean card layouts.\n- **Real-time Updates**: The UI polls the backend every 2 seconds to ensure synchronized display of telemetry and control states.\n- **Interactive Modals**: Settings and history are managed through full-screen modal dialogs, including drag-to-reorder priority lists.\n- **Visual Feedback**: Disabled LEDs are visually represented as off (gray), and array cards display configured intensity limits.\n- **Chart Modals**: History and power charts utilize 90% viewport width for maximum data visibility.\n- **Preset Editor**: Full-screen modal with sidebar preset list, Canvas-based graphical curve editor for all 6 wavemakers, and interactive keyframe manipulation (click to add, drag to move, Shift+click to delete).\n- **Scheduler Calendar View**: Toggle between list and calendar views in scheduler modal. Calendar displays weekly grid (24 hours x 7 days) with scheduled tasks visually placed at their times. Click calendar cells to create new tasks with pre-filled time/day. Click task badges to edit. Disabled tasks shown in gray.\n- **Toast Notifications**: Non-blocking notification system replaces all alert() calls to prevent iframe blocking, with success (green), error (red), and info (blue) variants that auto-dismiss after 3 seconds.\n- **Clean Interactions**: Removed button hover bounce effects for smoother, more professional feel. Feed Mode button toggles between start/cancel states with clear visual feedback.\n\n### Technical Implementations\n- **Backend (FastAPI)**:\n    - **Services**: `StageManager` (LEDs, battery), `PowerAllocator` (load shedding), `EventsService` (event logging), `AutomationService` (scheduling, wave modes), `SystemHealthService`, `JobScheduler` (1Hz telemetry/power allocation), `Store` (SQLite persistence).\n    - **API Endpoints**: Comprehensive RESTful API for controlling arrays, managing wavemakers, retrieving system telemetry, events, and historical data. Supports partial updates for flexible control.\n    - **Wavemaker Control**: Implements 6 independent channels with various patterns (Off, Constant, Pulse, Gyre Left/Right, Random Reef), a 20Hz control loop for smooth operation, and a 1Hz telemetry loop.\n    - **LED Control**: Individual LED enable/disable, array-level enable/disable, and proportional scaling of LEDs based on intensity limits.\n    - **Intelligent Power Management**: Priority-based power shedding with hysteresis, running every second to respond to power budget changes.\n- **Frontend (Vanilla JavaScript)**:\n    - No external frameworks are used.\n    - Utilizes HTML5 Canvas for sparkline rendering and visual flow pattern displays.\n    - Canvas coordinate mapping uses `getBoundingClientRect()` for accurate mouse interaction in scaled layouts.\n    - Implements local state persistence for sliders and toggles (e.g., 5-second timeout for intensity sliders) to maintain user input during UI refreshes.\n    - Smart preset selector updates only when state actually changes to prevent visual jumping.\n\n### Feature Specifications\n- **Wavemaker Preset System**: Coordinated flow pattern control across all 6 wavemakers using preset-based management. Features 6 built-in presets (Gentle Flow, Pulse, Gyre Clockwise/Counter-Clockwise, Feed Mode, Random Reef) with custom flow curves per wavemaker. PresetManager interpolates power values from keyframe-based curves every 20Hz for smooth transitions. REST API supports preset CRUD operations, activation, and real-time status. Frontend includes preset selector dropdown, graphical curve editor with Canvas-based interactive keyframe editing (click to add, drag to move, Shift+click to delete), and automated scheduler for time-based preset switching.\n- **Feed Mode**: Manual feeding assistance with one-button activation that pauses all wavemakers for 10 minutes using built-in \"Feed Mode\" preset, then automatically restores the previous preset. Features real-time countdown display, feed mode status indicator, and integration with scheduler (pauses scheduled changes during feeding). Backend uses name-based preset lookup for robustness, proper HTTP error handling, and 1-second timeout checking via JobScheduler. API endpoints: POST /api/feed/start, GET /api/feed/status, POST /api/feed/stop.\n- **Automation Scheduler UI**: Full-screen modal interface for managing scheduled preset activations. Features sidebar showing all scheduled tasks with enabled/disabled badges, form editor with time picker (24-hour format), preset selector, day-of-week filtering (optional), and enabled toggle. Complete CRUD operations with create/edit/delete functionality, coordinated with feed mode to pause automated changes during feeding. Integrated with existing scheduler backend (/api/automation/scheduled endpoints).\n- **Automation Scheduler Backend**: Time-based preset activation system with minute-precision execution. Supports scheduled tasks with optional day-of-week filtering, database persistence (ScheduledTaskRow), and automatic execution via JobScheduler. REST API provides CRUD operations for scheduled tasks (/api/automation/scheduled) and upcoming task queries. Integrated with PresetManager for seamless automated preset switching throughout the day.\n- **Wavemaker Subsystem**: Supports 6 independent channels with patterns like Off, Constant, Pulse (configurable duty ratio and intensity), Gyre Left/Right (synchronized sinusoidal waves), and Random Reef (smooth random transitions). Includes API endpoints for status, control, and 15-minute history.\n- **LED Control**: Granular control over 3 arrays, each with 6 individual LEDs. Each LED has configurable name, intensity limit, and priority. Real-time telemetry for each LED.\n- **Intelligent Power Management**: Automatically sheds lowest-priority loads when the power budget is exceeded, with hysteresis for stable operation. Tracks all shedding/restoration events.\n- **System Monitoring**: Real-time display of PV input, battery flow, and net power with color-coded indicators.\n- **Simulation Mode**: Comprehensive software simulation for development and testing, including diurnal PV curves, per-LED load calculation, battery flow simulation, and configurable power budgets.\n\n### System Design Choices\n- **Hardware Abstraction Layer (HAL)**: Unifies control for both simulated and real Raspberry Pi hardware (PCA9685 PWM, INA219 sensors) via a `HARDWARE_MODE` environment variable.\n- **Database**: SQLite for telemetry and event persistence.\n- **Configuration**: Environment variables (`APP_PORT`, `DB_URL`, `SENSOR_DRIVER`, `GPIO_DRIVER`) and `config.yaml` for detailed settings.\n- **Deployment**: Designed for Replit's autoscale deployment, emphasizing statelessness and environment-based configuration.\n\n## External Dependencies\n- **FastAPI**: Web framework for building APIs.\n- **Uvicorn**: ASGI server for running the FastAPI application.\n- **SQLModel**: ORM for interacting with the SQLite database.\n- **APScheduler**: Python library for scheduling periodic tasks.\n- **PyYAML**: For parsing YAML configuration files.\n- **PCA9685 PWM Controller**: Hardware for precise pump control (I2C address 0x40, 1000Hz PWM frequency, 12-bit resolution).\n- **INA219 Power Sensors**: Hardware for monitoring current/voltage (I2C addresses 0x40-0x45, 0-26V, 0-3.2A).","size_bytes":11790},"app/routers/history.py":{"content":"from fastapi import APIRouter, Query, HTTPException, Request\nfrom typing import List, Dict, Any\nfrom datetime import datetime, timedelta\nimport math\nimport math as m\n\nrouter = APIRouter(prefix=\"/api/history\", tags=[\"history\"])\n\n@router.get(\"/array/{array_id}\")\nasync def get_array_history(\n    request: Request,\n    array_id: str,\n    time_range: str = Query(\"1h\", regex=\"^(1h|6h|24h)$\", alias=\"range\")\n):\n    store = request.app.state.store\n    \n    range_minutes = {\n        \"1h\": 60,\n        \"6h\": 360,\n        \"24h\": 1440\n    }\n    \n    minutes = range_minutes.get(time_range, 60)\n    start_time = datetime.now() - timedelta(minutes=minutes)\n    \n    try:\n        rows = store.query_telemetry_range(array_id, start_time, datetime.now())\n        \n        downsample_factor = max(1, m.ceil(len(rows) / 100))\n        sampled = rows[::downsample_factor]\n        \n        history = []\n        for row in sampled:\n            history.append({\n                \"t\": row[\"timestamp\"].isoformat(),\n                \"v\": round(row[\"vout_v\"], 2),\n                \"i\": round(row[\"iout_a\"], 3),\n                \"p\": round(row[\"power_w\"], 1)\n            })\n        \n        return {\"array_id\": array_id, \"range\": time_range, \"data\": history}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.get(\"/system\")\nasync def get_system_history(\n    request: Request,\n    time_range: str = Query(\"1h\", regex=\"^(1h|6h|24h)$\", alias=\"range\")\n):\n    store = request.app.state.store\n    \n    range_minutes = {\n        \"1h\": 60,\n        \"6h\": 360,\n        \"24h\": 1440\n    }\n    \n    minutes = range_minutes.get(time_range, 60)\n    start_time = datetime.now() - timedelta(minutes=minutes)\n    \n    try:\n        all_data = {}\n        for array_id in [\"A1\", \"A2\", \"A3\"]:\n            rows = store.query_telemetry_range(array_id, start_time, datetime.now())\n            all_data[array_id] = rows\n        \n        max_len = max((len(v) for v in all_data.values()), default=0)\n        downsample_factor = max(1, m.ceil(max_len / 100))\n        \n        history = []\n        if max_len > 0:\n            for i in range(0, max_len, downsample_factor):\n                entry = {\"t\": None, \"arrays\": {}, \"battery_w\": 0}\n                total_load = 0\n                for array_id, rows in all_data.items():\n                    if i < len(rows):\n                        row = rows[i]\n                        if entry[\"t\"] is None:\n                            entry[\"t\"] = row[\"timestamp\"].isoformat()\n                        entry[\"arrays\"][array_id] = {\n                            \"p\": round(row[\"power_w\"], 1)\n                        }\n                        total_load += row[\"power_w\"]\n                \n                pv_power = 0.0\n                if hasattr(request.app.state, \"latest\") and request.app.state.latest:\n                    for reading in request.app.state.latest:\n                        if reading.stage_id == \"PV\":\n                            pv_power = reading.vout_v * reading.iout_a\n                            break\n                entry[\"battery_w\"] = round(pv_power - total_load, 1)\n                \n                if entry[\"t\"]:\n                    history.append(entry)\n        \n        return {\"range\": time_range, \"data\": history}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n","size_bytes":3360},"app/services/automation.py":{"content":"from datetime import datetime, timedelta\nfrom typing import List, Dict, Optional\nimport json\n\n\nclass AutomationService:\n    def __init__(self, store=None, preset_manager=None):\n        self.store = store\n        self.preset_manager = preset_manager\n        self.last_executed_tasks = {}\n        \n        self.feed_mode_active = False\n        self.feed_mode_start_time = None\n        self.feed_mode_duration_minutes = 10\n        self.preset_before_feed = None\n        \n        self.completed_tasks = [\n            {\"name\": \"Morning Feeding\", \"time\": \"08:15 AM\", \"status\": \"completed\"},\n            {\"name\": \"Peak Flow Cycle\", \"time\": \"10:30 AM\", \"status\": \"completed\"},\n            {\"name\": \"Water Quality Check\", \"time\": \"12:00 PM\", \"status\": \"completed\"},\n        ]\n        \n        self.wave_modes = {\n            \"Left Swirl\": {\"pattern\": \"circular_left\", \"intensity\": 0.7},\n            \"Right Swirl\": {\"pattern\": \"circular_right\", \"intensity\": 0.7},\n            \"Front-Back Surge\": {\"pattern\": \"surge_fb\", \"intensity\": 0.8},\n            \"Cross Current\": {\"pattern\": \"cross\", \"intensity\": 0.6},\n            \"Reef Pulse\": {\"pattern\": \"pulse\", \"intensity\": 0.9},\n        }\n        \n        self.current_wave_mode = \"Reef Pulse\"\n    \n    def get_completed_tasks(self) -> List[Dict]:\n        return self.completed_tasks\n    \n    def get_upcoming_tasks(self) -> List[Dict]:\n        if not self.store:\n            return [\n                {\"name\": \"Evening Feeding\", \"time\": \"06:00 PM\", \"eta_minutes\": 45},\n                {\"name\": \"Night Mode Transition\", \"time\": \"08:30 PM\", \"eta_minutes\": 195},\n            ]\n        \n        tasks = self.store.get_all_scheduled_tasks()\n        now = datetime.now()\n        upcoming = []\n        \n        for task in tasks:\n            if not task.enabled:\n                continue\n            \n            try:\n                task_hour, task_min = task.time.split(':')\n                task_dt = now.replace(hour=int(task_hour), minute=int(task_min), second=0, microsecond=0)\n                \n                if task_dt < now:\n                    task_dt += timedelta(days=1)\n                \n                eta_minutes = int((task_dt - now).total_seconds() / 60)\n                \n                upcoming.append({\n                    \"id\": task.id,\n                    \"name\": task.name,\n                    \"time\": task.time,\n                    \"eta_minutes\": eta_minutes,\n                    \"type\": task.task_type,\n                    \"preset_id\": task.preset_id\n                })\n            except:\n                continue\n        \n        upcoming.sort(key=lambda x: x[\"eta_minutes\"])\n        return upcoming[:5]\n    \n    def get_wave_modes(self) -> List[str]:\n        return list(self.wave_modes.keys())\n    \n    def get_current_wave_mode(self) -> str:\n        return self.current_wave_mode\n    \n    def set_wave_mode(self, mode: str) -> bool:\n        if mode in self.wave_modes:\n            self.current_wave_mode = mode\n            return True\n        return False\n    \n    def start_feed_mode(self) -> Dict:\n        if not self.preset_manager or not self.store:\n            return {\"success\": False, \"message\": \"Preset manager not available\"}\n        \n        if self.feed_mode_active:\n            return {\"success\": False, \"message\": \"Feed mode already active\"}\n        \n        feed_preset = self.store.get_preset_by_name(\"Feed Mode\")\n        if not feed_preset:\n            return {\"success\": False, \"message\": \"Feed Mode preset not found\"}\n        \n        current_preset = self.preset_manager.get_active_preset()\n        self.preset_before_feed = current_preset.id if current_preset else None\n        \n        self.preset_manager.set_active_preset(feed_preset.id)\n        self.feed_mode_active = True\n        self.feed_mode_start_time = datetime.now()\n        \n        print(f\"[Feed Mode] Started - previous preset: {self.preset_before_feed}\")\n        return {\"success\": True, \"message\": \"Feed mode activated\"}\n    \n    def get_feed_mode_status(self) -> Dict:\n        if not self.feed_mode_active:\n            return {\n                \"active\": False,\n                \"remaining_seconds\": 0,\n                \"duration_minutes\": self.feed_mode_duration_minutes\n            }\n        \n        elapsed = (datetime.now() - self.feed_mode_start_time).total_seconds()\n        total_seconds = self.feed_mode_duration_minutes * 60\n        remaining = max(0, total_seconds - elapsed)\n        \n        return {\n            \"active\": True,\n            \"remaining_seconds\": int(remaining),\n            \"duration_minutes\": self.feed_mode_duration_minutes,\n            \"start_time\": self.feed_mode_start_time.isoformat()\n        }\n    \n    def stop_feed_mode(self, restore_preset: bool = True) -> Dict:\n        if not self.feed_mode_active:\n            return {\"success\": False, \"message\": \"Feed mode not active\"}\n        \n        self.feed_mode_active = False\n        \n        if restore_preset and self.preset_before_feed:\n            try:\n                self.preset_manager.set_active_preset(self.preset_before_feed)\n                print(f\"[Feed Mode] Stopped - restored preset {self.preset_before_feed}\")\n            except Exception as e:\n                print(f\"[Feed Mode] Failed to restore preset: {e}\")\n        \n        self.feed_mode_start_time = None\n        self.preset_before_feed = None\n        \n        return {\"success\": True, \"message\": \"Feed mode stopped\"}\n    \n    def check_feed_mode_timeout(self):\n        if not self.feed_mode_active or not self.feed_mode_start_time:\n            return\n        \n        elapsed = (datetime.now() - self.feed_mode_start_time).total_seconds()\n        duration_seconds = self.feed_mode_duration_minutes * 60\n        \n        if elapsed >= duration_seconds:\n            print(f\"[Feed Mode] Timeout reached, auto-stopping\")\n            self.stop_feed_mode(restore_preset=True)\n    \n    def check_and_execute_tasks(self):\n        if not self.store or not self.preset_manager:\n            return\n        \n        if self.feed_mode_active:\n            return\n        \n        tasks = self.store.get_all_scheduled_tasks()\n        now = datetime.now()\n        current_time = now.strftime(\"%H:%M\")\n        today = now.weekday()\n        \n        for task in tasks:\n            if not task.enabled:\n                continue\n            \n            if task.days_of_week:\n                try:\n                    days = json.loads(task.days_of_week) if isinstance(task.days_of_week, str) else task.days_of_week\n                    if today not in days:\n                        continue\n                except:\n                    pass\n            \n            task_key = f\"{task.id}_{task.time}\"\n            last_exec = self.last_executed_tasks.get(task_key)\n            \n            if last_exec and (now - last_exec).total_seconds() < 60:\n                continue\n            \n            if task.time == current_time:\n                self._execute_task(task)\n                self.last_executed_tasks[task_key] = now\n    \n    def _execute_task(self, task):\n        if task.task_type == \"preset_activation\" and task.preset_id:\n            try:\n                self.preset_manager.set_active_preset(task.preset_id)\n                print(f\"[Automation] Activated preset {task.preset_id} for task '{task.name}'\")\n            except Exception as e:\n                print(f\"[Automation] Failed to execute task {task.name}: {e}\")\n","size_bytes":7410},"app/drivers/__init__.py":{"content":"","size_bytes":0},"app/routers/arrays.py":{"content":"from fastapi import APIRouter, Request, HTTPException, Query\nfrom datetime import datetime, timedelta\nfrom typing import Optional\nfrom app.models import ArrayStatus, ArraySettingsRequest, SystemLoad, PowerEvent\n\n\nrouter = APIRouter()\n\n\n@router.get(\"/arrays\")\nasync def get_arrays(request: Request):\n    stage_manager = request.app.state.stage_manager\n    arrays = []\n    \n    for stage in stage_manager.stages:\n        if hasattr(stage, 'leds'):\n            array_status = ArrayStatus(\n                id=stage.id,\n                name=stage.name,\n                description=stage.description,\n                enabled=stage.enabled,\n                mode=stage.mode,\n                duty=stage.duty,\n                leds=stage.leds,\n                vin_v=0.0,\n                iin_a=0.0,\n                vout_v=0.0,\n                iout_a=0.0,\n                power_w=0.0\n            )\n            \n            latest = request.app.state.latest\n            if latest:\n                for reading in latest:\n                    if reading.stage_id == stage.id:\n                        array_status.vin_v = reading.vin_v\n                        array_status.iin_a = reading.iin_a\n                        array_status.vout_v = reading.vout_v\n                        array_status.iout_a = reading.iout_a\n                        array_status.power_w = reading.vout_v * reading.iout_a\n                        break\n            \n            arrays.append(array_status)\n    \n    return {\"arrays\": arrays}\n\n\n@router.post(\"/arrays/{array_id}/settings\")\nasync def update_array_settings(\n    array_id: str,\n    settings: ArraySettingsRequest,\n    request: Request\n):\n    stage_manager = request.app.state.stage_manager\n    \n    stage = None\n    for s in stage_manager.stages:\n        if s.id == array_id:\n            stage = s\n            break\n    \n    if not stage:\n        raise HTTPException(status_code=404, detail=\"Array not found\")\n    \n    if not hasattr(stage, 'leds'):\n        raise HTTPException(status_code=400, detail=\"Stage is not an array\")\n    \n    for led_id, updates in settings.leds.items():\n        led = next((l for l in stage.leds if l.id == led_id), None)\n        if not led:\n            continue\n        \n        if updates.label is not None:\n            led.label = updates.label\n        if updates.intensity_limit_pct is not None:\n            led.intensity_limit_pct = max(0, min(100, updates.intensity_limit_pct))\n        if updates.priority is not None:\n            led.priority = updates.priority\n        if updates.is_on is not None:\n            led.is_on = updates.is_on\n    \n    stage.apply_control()\n    \n    return {\"success\": True, \"array_id\": array_id}\n\n\n@router.get(\"/system/load\")\nasync def get_system_load(request: Request):\n    latest = request.app.state.latest\n    \n    pv_w = 0.0\n    load_w = 0.0\n    \n    if latest:\n        for reading in latest:\n            if reading.stage_id == \"PV\":\n                pv_w = reading.vout_v * reading.iout_a\n            else:\n                load_w += reading.vout_v * reading.iout_a\n    \n    battery_w = pv_w - load_w\n    \n    config = request.app.state.config\n    budget_w = config.get(\"power_budget\", {}).get(\"target_watts\", 400)\n    \n    return SystemLoad(\n        pv_w=pv_w,\n        load_w=load_w,\n        battery_w=battery_w,\n        net_w=pv_w - load_w,\n        budget_w=budget_w,\n        timestamp=datetime.now()\n    )\n\n\n@router.get(\"/events\")\nasync def get_events(request: Request, limit: int = Query(default=50, ge=1, le=200)):\n    events_service = request.app.state.events\n    events = events_service.get_recent_events(limit=limit)\n    return {\"events\": events}\n","size_bytes":3638},"app/routers/wavemakers.py":{"content":"\"\"\"\nWavemaker API Endpoints\n\"\"\"\nfrom fastapi import APIRouter, HTTPException, Request\nfrom typing import List\nfrom ..models import WavemakerChannel, WavemakerControlRequest, WavemakerHistoryPoint\n\nrouter = APIRouter()\n\n\n@router.get('/wavemakers', response_model=List[WavemakerChannel])\nasync def get_all_wavemakers(request: Request):\n    \"\"\"Get status of all 6 wavemaker channels\"\"\"\n    manager = request.app.state.wavemaker_manager\n    return manager.get_all_status()\n\n\n@router.get('/wavemakers/{channel_id}', response_model=WavemakerChannel)\nasync def get_wavemaker(channel_id: int, request: Request):\n    \"\"\"Get status of a specific wavemaker channel\"\"\"\n    try:\n        manager = request.app.state.wavemaker_manager\n        return manager.get_channel_status(channel_id)\n    except ValueError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n\n\n@router.put('/wavemakers/{channel_id}', response_model=WavemakerChannel)\nasync def update_wavemaker(channel_id: int, update: WavemakerControlRequest, request: Request):\n    \"\"\"Update wavemaker channel mode and/or target power\"\"\"\n    try:\n        manager = request.app.state.wavemaker_manager\n        manager.update_channel(\n            channel_id,\n            mode=update.mode,\n            target_pct=update.target_power_pct,\n            pulse_duty_ratio=update.pulse_duty_ratio\n        )\n        return manager.get_channel_status(channel_id)\n    except ValueError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n\n\n@router.get('/wavemakers/{channel_id}/history', response_model=List[WavemakerHistoryPoint])\nasync def get_wavemaker_history(channel_id: int, request: Request, window: int = 900):\n    \"\"\"\n    Get power history for a wavemaker channel\n    \n    Args:\n        channel_id: Channel ID (0-5)\n        window: Time window in seconds (default 900 = 15 minutes)\n    \"\"\"\n    if not (0 <= channel_id < 6):\n        raise HTTPException(status_code=404, detail=f\"Invalid channel ID: {channel_id}\")\n        \n    manager = request.app.state.wavemaker_manager\n    return manager.get_channel_history(channel_id, window_s=window)\n\n\n@router.post('/wavemakers/emergency-stop')\nasync def emergency_stop(request: Request):\n    \"\"\"Emergency stop all wavemaker channels\"\"\"\n    manager = request.app.state.wavemaker_manager\n    manager.emergency_stop()\n    return {\"status\": \"all channels stopped\"}\n","size_bytes":2368},"app/hardware/__init__.py":{"content":"","size_bytes":0},"app/services/wavemaker_manager.py":{"content":"\"\"\"\nWavemaker Manager Service\nCoordinates 6 wavemaker channels with different wave patterns\n\"\"\"\nimport time\nimport math\nimport random\nfrom datetime import datetime, timedelta\nfrom collections import deque\nfrom typing import List, Dict, Deque\nfrom ..models import WavemakerMode, WavemakerChannel, WavemakerHistoryPoint\nfrom ..hardware.hal import WavemakerHAL\n\n\nclass Channel:\n    \"\"\"Individual wavemaker channel with pattern generation\"\"\"\n    \n    def __init__(self, channel_id: int, name: str):\n        self.id = channel_id\n        self.name = name\n        self.mode: WavemakerMode = \"off\"\n        self.target_power_pct: int = 0\n        self.current_duty: float = 0.0\n        \n        self.voltage_v: float = 0.0\n        self.current_a: float = 0.0\n        self.power_w: float = 0.0\n        \n        self.pattern_phase: float = 0.0\n        self.pulse_on_time: float = 0.0\n        self.pulse_period: float = 10.0\n        self.pulse_duty_ratio: float = 0.6\n        \n        self.random_current: float = 0.0\n        self.random_target: float = 0.0\n        self.random_transition_start: float = 0.0\n        self.random_transition_duration: float = 2.0\n        \n    def _compute_duty_from_mode(self, t_now: float) -> float:\n        \"\"\"\n        Compute PWM duty cycle based on current mode and time\n        \n        Returns:\n            Duty cycle from 0.0 to 1.0\n        \"\"\"\n        if self.mode == \"off\":\n            return 0.0\n            \n        if self.mode == \"constant\":\n            return self.target_power_pct / 100.0\n            \n        if self.mode == \"pulse\":\n            time_in_cycle = (t_now - self.pulse_on_time) % self.pulse_period\n            on_duration = self.pulse_period * self.pulse_duty_ratio\n            \n            if time_in_cycle < on_duration:\n                return self.target_power_pct / 100.0\n            else:\n                return 0.0\n                \n        if self.mode == \"gyre_left\":\n            phase = (t_now / 30.0) * 2 * math.pi + self.pattern_phase\n            wave = (math.sin(phase) + 1) / 2\n            \n            if self.id % 2 == 0:\n                duty = wave * (self.target_power_pct / 100.0)\n            else:\n                duty = (1 - wave) * (self.target_power_pct / 100.0)\n            return max(0.0, min(1.0, duty))\n            \n        if self.mode == \"gyre_right\":\n            phase = (t_now / 30.0) * 2 * math.pi + self.pattern_phase\n            wave = (math.sin(phase) + 1) / 2\n            \n            if self.id % 2 == 0:\n                duty = (1 - wave) * (self.target_power_pct / 100.0)\n            else:\n                duty = wave * (self.target_power_pct / 100.0)\n            return max(0.0, min(1.0, duty))\n            \n        if self.mode == \"random_reef\":\n            elapsed = t_now - self.random_transition_start\n            \n            if elapsed >= self.random_transition_duration:\n                self.random_current = self.random_target\n                self.random_target = random.uniform(0.3, 1.0) * (self.target_power_pct / 100.0)\n                self.random_transition_start = t_now\n                self.random_transition_duration = random.uniform(5.0, 15.0)\n                elapsed = 0.0\n                \n            progress = min(1.0, elapsed / self.random_transition_duration)\n            smooth_progress = 0.5 * (1 - math.cos(progress * math.pi))\n            \n            duty = (1 - smooth_progress) * self.random_current + smooth_progress * self.random_target\n            return max(0.0, min(1.0, duty))\n            \n        return 0.0\n        \n    def update_pwm(self, t_now: float, hal: WavemakerHAL):\n        \"\"\"Update PWM output based on current mode\"\"\"\n        new_duty = self._compute_duty_from_mode(t_now)\n        self.current_duty = new_duty\n        hal.set_channel_pwm(self.id, new_duty)\n        \n    def read_power(self, hal: WavemakerHAL):\n        \"\"\"Read power telemetry from sensor\"\"\"\n        telemetry = hal.read_channel_power(self.id)\n        self.voltage_v = telemetry[\"voltage\"]\n        self.current_a = telemetry[\"current\"]\n        self.power_w = telemetry[\"power\"]\n        \n    def set_mode(self, mode: WavemakerMode, target_pct: int, pulse_duty_ratio: float = None):\n        \"\"\"Update channel mode and target power\"\"\"\n        self.mode = mode\n        self.target_power_pct = max(0, min(100, target_pct))\n        \n        if pulse_duty_ratio is not None:\n            self.pulse_duty_ratio = max(0.0, min(1.0, pulse_duty_ratio))\n        \n        if mode == \"pulse\":\n            self.pulse_on_time = time.time()\n            \n        if mode == \"random_reef\":\n            self.random_current = self.current_duty\n            self.random_target = self.target_power_pct / 100.0\n            self.random_transition_start = time.time()\n            \n    def to_model(self) -> WavemakerChannel:\n        \"\"\"Convert to API model\"\"\"\n        return WavemakerChannel(\n            id=self.id,\n            name=self.name,\n            mode=self.mode,\n            target_power_pct=self.target_power_pct,\n            pulse_duty_ratio=self.pulse_duty_ratio,\n            current_power_w=round(self.power_w, 2),\n            voltage_v=round(self.voltage_v, 2),\n            current_a=round(self.current_a, 3)\n        )\n\n\nclass WavemakerManager:\n    \"\"\"Manages all 6 wavemaker channels\"\"\"\n    \n    def __init__(self):\n        self.hal = WavemakerHAL()\n        \n        self.channels = [\n            Channel(0, \"Front Left\"),\n            Channel(1, \"Front Right\"),\n            Channel(2, \"Mid Left\"),\n            Channel(3, \"Mid Right\"),\n            Channel(4, \"Back Left\"),\n            Channel(5, \"Back Right\")\n        ]\n        \n        self.history_window_s = 900\n        self.history: Dict[int, Deque[WavemakerHistoryPoint]] = {\n            i: deque(maxlen=900) for i in range(6)\n        }\n        \n        self.last_telemetry_time = 0.0\n        self.preset_manager = None\n        \n    def set_preset_manager(self, preset_manager):\n        \"\"\"Inject preset manager for preset-based control\"\"\"\n        self.preset_manager = preset_manager\n    \n    def apply_preset_power_levels(self):\n        \"\"\"Apply power levels from active preset to all channels\"\"\"\n        if not self.preset_manager:\n            return\n        \n        power_levels = self.preset_manager.get_current_power_levels()\n        \n        for wavemaker_num, power_pct in power_levels.items():\n            channel_index = wavemaker_num - 1\n            if 0 <= channel_index < len(self.channels):\n                channel = self.channels[channel_index]\n                channel.mode = \"constant\"\n                channel.target_power_pct = int(power_pct)\n    \n    def update_all(self, t_now: float):\n        \"\"\"Update all channels (20 Hz control loop)\"\"\"\n        if self.preset_manager and self.preset_manager.get_active_preset():\n            self.apply_preset_power_levels()\n        \n        for channel in self.channels:\n            channel.update_pwm(t_now, self.hal)\n            \n    def sample_all_power(self):\n        \"\"\"Sample power from all channels (1 Hz telemetry loop)\"\"\"\n        current_time = time.time()\n        \n        if current_time - self.last_telemetry_time < 0.5:\n            return\n            \n        self.last_telemetry_time = current_time\n        \n        for channel in self.channels:\n            channel.read_power(self.hal)\n            \n            point = WavemakerHistoryPoint(\n                t=datetime.now(),\n                power_w=channel.power_w,\n                duty_pct=round(channel.current_duty * 100, 1),\n                pulse_duty_ratio=channel.pulse_duty_ratio\n            )\n            self.history[channel.id].append(point)\n            \n    def get_channel_status(self, channel_id: int) -> WavemakerChannel:\n        \"\"\"Get status for a specific channel\"\"\"\n        if 0 <= channel_id < len(self.channels):\n            return self.channels[channel_id].to_model()\n        raise ValueError(f\"Invalid channel ID: {channel_id}\")\n        \n    def get_all_status(self) -> List[WavemakerChannel]:\n        \"\"\"Get status for all channels\"\"\"\n        return [ch.to_model() for ch in self.channels]\n        \n    def update_channel(self, channel_id: int, mode: WavemakerMode = None, target_pct: int = None, pulse_duty_ratio: float = None):\n        \"\"\"Update a channel's mode and/or target power (partial updates supported)\"\"\"\n        if not (0 <= channel_id < len(self.channels)):\n            raise ValueError(f\"Invalid channel ID: {channel_id}\")\n            \n        channel = self.channels[channel_id]\n        \n        new_mode = mode if mode is not None else channel.mode\n        new_target = target_pct if target_pct is not None else channel.target_power_pct\n        \n        channel.set_mode(new_mode, new_target, pulse_duty_ratio)\n        \n    def get_channel_history(self, channel_id: int, window_s: int = 900) -> List[WavemakerHistoryPoint]:\n        \"\"\"Get power history for a channel\"\"\"\n        if channel_id not in self.history:\n            return []\n            \n        cutoff_time = datetime.now() - timedelta(seconds=window_s)\n        \n        return [\n            point for point in self.history[channel_id]\n            if point.t >= cutoff_time\n        ]\n        \n    def emergency_stop(self):\n        \"\"\"Emergency stop all channels\"\"\"\n        for channel in self.channels:\n            channel.set_mode(\"off\", 0)\n        self.hal.shutdown_all()\n","size_bytes":9338},"app/hardware/pca.py":{"content":"\"\"\"\nPCA9685 PWM Controller - Hardware Abstraction\nSupports both simulated and real PCA9685 16-channel PWM driver\n\"\"\"\nimport os\nimport time\nimport math\nfrom typing import Optional\n\nHARDWARE_MODE = os.getenv(\"HARDWARE_MODE\", \"sim\")\n\n\nclass PCA9685Simulated:\n    \"\"\"Simulated PCA9685 for development/testing\"\"\"\n    \n    def __init__(self, address: int = 0x40):\n        self.address = address\n        self.channels = [0] * 16\n        self.frequency = 1000\n        \n    def set_pwm_freq(self, freq: int):\n        \"\"\"Set PWM frequency\"\"\"\n        self.frequency = freq\n        \n    def set_pwm(self, channel: int, on: int, off: int):\n        \"\"\"Set PWM duty cycle for a channel\"\"\"\n        if 0 <= channel < 16:\n            duty = off / 4096.0\n            self.channels[channel] = duty\n            \n    def set_pwm_duty(self, channel: int, duty: float):\n        \"\"\"Set PWM duty cycle (0.0 to 1.0)\"\"\"\n        if 0 <= channel < 16:\n            off_value = int(duty * 4095)\n            self.set_pwm(channel, 0, off_value)\n            self.channels[channel] = duty\n\n\nclass PCA9685Real:\n    \"\"\"Real PCA9685 hardware driver\"\"\"\n    \n    def __init__(self, address: int = 0x40):\n        try:\n            from adafruit_pca9685 import PCA9685\n            import board\n            import busio\n            \n            i2c = busio.I2C(board.SCL, board.SDA)\n            self.pca = PCA9685(i2c, address=address)\n            self.pca.frequency = 1000\n        except ImportError:\n            raise RuntimeError(\"Real hardware libraries not available. Install adafruit-circuitpython-pca9685\")\n            \n    def set_pwm_freq(self, freq: int):\n        \"\"\"Set PWM frequency\"\"\"\n        self.pca.frequency = freq\n        \n    def set_pwm(self, channel: int, on: int, off: int):\n        \"\"\"Set PWM for channel\"\"\"\n        self.pca.channels[channel].duty_cycle = off\n        \n    def set_pwm_duty(self, channel: int, duty: float):\n        \"\"\"Set PWM duty cycle (0.0 to 1.0)\"\"\"\n        duty_cycle = int(duty * 65535)\n        self.pca.channels[channel].duty_cycle = duty_cycle\n\n\ndef create_pca9685(address: int = 0x40):\n    \"\"\"Factory function to create appropriate PCA9685 instance\"\"\"\n    if HARDWARE_MODE == \"pi\":\n        return PCA9685Real(address)\n    else:\n        return PCA9685Simulated(address)\n","size_bytes":2272},"app/hardware/hal.py":{"content":"\"\"\"\nHardware Abstraction Layer (HAL)\nProvides unified interface for wavemaker hardware control\n\"\"\"\nimport os\nfrom typing import Dict\nfrom .pca import create_pca9685\nfrom .sensors import SensorArray\n\nHARDWARE_MODE = os.getenv(\"HARDWARE_MODE\", \"sim\")\n\n\nclass WavemakerHAL:\n    \"\"\"Hardware abstraction for 6-channel wavemaker system\"\"\"\n    \n    def __init__(self):\n        self.pca = create_pca9685(address=0x40)\n        self.pca.set_pwm_freq(1000)\n        \n        sensor_addresses = {\n            0: 0x40,\n            1: 0x41,\n            2: 0x44,\n            3: 0x45,\n            4: 0x48,\n            5: 0x49\n        }\n        self.sensors = SensorArray(sensor_addresses)\n        \n        self.channel_map = {\n            0: 0,\n            1: 1,\n            2: 2,\n            3: 3,\n            4: 4,\n            5: 5\n        }\n        \n    def set_channel_pwm(self, channel_id: int, duty: float):\n        \"\"\"\n        Set PWM duty cycle for a channel\n        \n        Args:\n            channel_id: Channel number (0-5)\n            duty: Duty cycle 0.0 to 1.0\n        \"\"\"\n        if channel_id not in self.channel_map:\n            return\n            \n        duty = max(0.0, min(1.0, duty))\n        pwm_channel = self.channel_map[channel_id]\n        \n        self.pca.set_pwm_duty(pwm_channel, duty)\n        \n        self.sensors.update_pwm_duty(channel_id, duty)\n        \n    def read_channel_power(self, channel_id: int) -> Dict[str, float]:\n        \"\"\"\n        Read power telemetry for a channel\n        \n        Returns:\n            Dict with voltage, current, power\n        \"\"\"\n        return self.sensors.read_channel(channel_id)\n        \n    def read_all_power(self) -> Dict[int, Dict[str, float]]:\n        \"\"\"Read power for all channels\"\"\"\n        return {\n            channel_id: self.read_channel_power(channel_id)\n            for channel_id in range(6)\n        }\n        \n    def shutdown_all(self):\n        \"\"\"Emergency shutdown - set all channels to 0%\"\"\"\n        for channel_id in range(6):\n            self.set_channel_pwm(channel_id, 0.0)\n","size_bytes":2053},"app/hardware/sensors.py":{"content":"\"\"\"\nINA219/INA226 Power Sensors - Hardware Abstraction\nSupports both simulated and real power monitoring sensors\n\"\"\"\nimport os\nimport time\nimport random\nimport math\nfrom typing import Dict\n\nHARDWARE_MODE = os.getenv(\"HARDWARE_MODE\", \"sim\")\n\n\nclass INA219Simulated:\n    \"\"\"Simulated INA219 power sensor\"\"\"\n    \n    def __init__(self, address: int, max_expected_amps: float = 2.0):\n        self.address = address\n        self.max_amps = max_expected_amps\n        self.base_voltage = 24.0\n        self.pwm_duty = 0.0\n        self.last_update = time.time()\n        \n    def set_pwm_duty(self, duty: float):\n        \"\"\"Update the PWM duty cycle to calculate realistic power\"\"\"\n        self.pwm_duty = max(0.0, min(1.0, duty))\n        \n    def voltage(self) -> float:\n        \"\"\"Simulate bus voltage with slight variation\"\"\"\n        base_drop = 0.5 * self.pwm_duty\n        noise = random.uniform(-0.1, 0.1)\n        return self.base_voltage - base_drop + noise\n        \n    def current(self) -> float:\n        \"\"\"Simulate current draw based on PWM duty\"\"\"\n        if self.pwm_duty < 0.05:\n            return 0.0\n            \n        base_current = self.max_amps * self.pwm_duty\n        efficiency = 0.85 + 0.1 * self.pwm_duty\n        noise = random.uniform(-0.02, 0.02)\n        \n        return (base_current / efficiency) + noise\n        \n    def power(self) -> float:\n        \"\"\"Calculate power (V * I)\"\"\"\n        return self.voltage() * self.current()\n\n\nclass INA219Real:\n    \"\"\"Real INA219 hardware sensor\"\"\"\n    \n    def __init__(self, address: int, max_expected_amps: float = 2.0):\n        try:\n            from ina219 import INA219\n            self.ina = INA219(shunt_ohms=0.1, max_expected_amps=max_expected_amps, address=address)\n            self.ina.configure(voltage_range=self.ina.RANGE_32V)\n        except ImportError:\n            raise RuntimeError(\"Real hardware libraries not available. Install pi-ina219\")\n            \n    def set_pwm_duty(self, duty: float):\n        \"\"\"No-op for real sensors - they measure actual current draw\"\"\"\n        pass\n            \n    def voltage(self) -> float:\n        \"\"\"Read bus voltage\"\"\"\n        return self.ina.voltage()\n        \n    def current(self) -> float:\n        \"\"\"Read current in amps\"\"\"\n        return self.ina.current() / 1000.0\n        \n    def power(self) -> float:\n        \"\"\"Read power in watts\"\"\"\n        return self.ina.power() / 1000.0\n\n\nclass SensorArray:\n    \"\"\"Manages multiple power sensors\"\"\"\n    \n    def __init__(self, sensor_addresses: Dict[int, int]):\n        \"\"\"\n        Args:\n            sensor_addresses: Dict mapping channel_id to I2C address\n        \"\"\"\n        self.sensors: Dict[int, INA219Simulated | INA219Real] = {}\n        \n        for channel_id, address in sensor_addresses.items():\n            if HARDWARE_MODE == \"pi\":\n                self.sensors[channel_id] = INA219Real(address, max_expected_amps=3.0)\n            else:\n                self.sensors[channel_id] = INA219Simulated(address, max_expected_amps=2.5)\n                \n    def read_channel(self, channel_id: int) -> Dict[str, float]:\n        \"\"\"Read voltage, current, power for a channel\"\"\"\n        if channel_id not in self.sensors:\n            return {\"voltage\": 0.0, \"current\": 0.0, \"power\": 0.0}\n            \n        sensor = self.sensors[channel_id]\n        return {\n            \"voltage\": round(sensor.voltage(), 2),\n            \"current\": round(sensor.current(), 3),\n            \"power\": round(sensor.power(), 2)\n        }\n        \n    def update_pwm_duty(self, channel_id: int, duty: float):\n        \"\"\"Update PWM duty for simulated sensors (no-op for real sensors)\"\"\"\n        if channel_id in self.sensors:\n            self.sensors[channel_id].set_pwm_duty(duty)\n","size_bytes":3719},"app/routers/presets.py":{"content":"from fastapi import APIRouter, HTTPException, Request\nfrom typing import List\nfrom ..models import WavemakerPresetResponse, WavemakerPresetRequest\nfrom ..services.storage import WavemakerPreset\n\nrouter = APIRouter()\n\n\n@router.get('/presets', response_model=List[WavemakerPresetResponse])\nasync def list_presets(request: Request):\n    presets = request.app.state.store.get_all_presets()\n    return [WavemakerPresetResponse(**p.model_dump()) for p in presets]\n\n\n@router.get('/presets/{preset_id}', response_model=WavemakerPresetResponse)\nasync def get_preset(preset_id: int, request: Request):\n    preset = request.app.state.store.get_preset(preset_id)\n    if not preset:\n        raise HTTPException(status_code=404, detail=\"Preset not found\")\n    return WavemakerPresetResponse(**preset.model_dump())\n\n\n@router.post('/presets', response_model=WavemakerPresetResponse)\nasync def create_preset(data: WavemakerPresetRequest, request: Request):\n    preset = WavemakerPreset(\n        name=data.name,\n        description=data.description or \"\",\n        cycle_duration_sec=data.cycle_duration_sec or 60,\n        is_built_in=False,\n        flow_curves=data.flow_curves or {}\n    )\n    created = request.app.state.store.create_preset(preset)\n    return WavemakerPresetResponse(**created.model_dump())\n\n\n@router.put('/presets/{preset_id}', response_model=WavemakerPresetResponse)\nasync def update_preset(preset_id: int, data: WavemakerPresetRequest, request: Request):\n    updates = {}\n    if data.name:\n        updates['name'] = data.name\n    if data.description is not None:\n        updates['description'] = data.description\n    if data.cycle_duration_sec is not None:\n        updates['cycle_duration_sec'] = data.cycle_duration_sec\n    if data.flow_curves is not None:\n        updates['flow_curves'] = data.flow_curves\n    \n    updated = request.app.state.store.update_preset(preset_id, **updates)\n    if not updated:\n        raise HTTPException(status_code=404, detail=\"Preset not found or is built-in\")\n    return WavemakerPresetResponse(**updated.model_dump())\n\n\n@router.delete('/presets/{preset_id}')\nasync def delete_preset(preset_id: int, request: Request):\n    success = request.app.state.store.delete_preset(preset_id)\n    if not success:\n        raise HTTPException(status_code=404, detail=\"Preset not found or is built-in\")\n    return {\"success\": True}\n\n\n@router.post('/presets/{preset_id}/activate')\nasync def activate_preset(preset_id: int, request: Request):\n    success = request.app.state.preset_manager.set_active_preset(preset_id)\n    if not success:\n        raise HTTPException(status_code=404, detail=\"Preset not found\")\n    return {\"success\": True, \"active_preset_id\": preset_id}\n\n\n@router.get('/presets/active/status')\nasync def get_active_preset_status(request: Request):\n    preset = request.app.state.preset_manager.get_active_preset()\n    if not preset:\n        return {\"active_preset\": None, \"power_levels\": {}}\n    \n    power_levels = request.app.state.preset_manager.get_current_power_levels()\n    \n    return {\n        \"active_preset\": WavemakerPresetResponse(**preset.model_dump()),\n        \"power_levels\": power_levels\n    }\n","size_bytes":3148},"app/services/preset_manager.py":{"content":"import time\nimport math\nfrom typing import Optional, Dict, List\nfrom .storage import WavemakerPreset, Store\n\n\nclass PresetManager:\n    def __init__(self, store: Store):\n        self.store = store\n        self.active_preset_id: Optional[int] = None\n        self.cycle_start_time: float = time.time()\n        self._initialize_built_in_presets()\n    \n    def _initialize_built_in_presets(self):\n        existing = self.store.get_all_presets()\n        if not existing:\n            built_in_presets = [\n                self._create_gentle_preset(),\n                self._create_pulse_preset(),\n                self._create_gyre_cw_preset(),\n                self._create_gyre_ccw_preset(),\n                self._create_feed_mode_preset(),\n                self._create_random_reef_preset()\n            ]\n            \n            for preset in built_in_presets:\n                self.store.create_preset(preset)\n    \n    def _create_gentle_preset(self) -> WavemakerPreset:\n        flow_curves = {}\n        for i in range(1, 7):\n            flow_curves[f\"wavemaker_{i}\"] = [\n                {\"time\": 0, \"power\": 30},\n                {\"time\": 60, \"power\": 30}\n            ]\n        \n        return WavemakerPreset(\n            name=\"Gentle Flow\",\n            description=\"Calm, steady flow for sensitive corals\",\n            cycle_duration_sec=60,\n            is_built_in=True,\n            flow_curves=flow_curves\n        )\n    \n    def _create_pulse_preset(self) -> WavemakerPreset:\n        flow_curves = {}\n        for i in range(1, 7):\n            flow_curves[f\"wavemaker_{i}\"] = [\n                {\"time\": 0, \"power\": 20},\n                {\"time\": 2, \"power\": 80},\n                {\"time\": 5, \"power\": 20},\n                {\"time\": 10, \"power\": 20}\n            ]\n        \n        return WavemakerPreset(\n            name=\"Pulse\",\n            description=\"Short bursts of strong flow\",\n            cycle_duration_sec=10,\n            is_built_in=True,\n            flow_curves=flow_curves\n        )\n    \n    def _create_gyre_cw_preset(self) -> WavemakerPreset:\n        flow_curves = {}\n        phase_offsets = [0, 60, 120, 180, 240, 300]\n        \n        for i, offset in enumerate(phase_offsets, 1):\n            points = []\n            for t in range(0, 361, 30):\n                phase = (t + offset) % 360\n                power = int(50 + 30 * math.sin(math.radians(phase)))\n                points.append({\"time\": t / 6, \"power\": power})\n            flow_curves[f\"wavemaker_{i}\"] = points\n        \n        return WavemakerPreset(\n            name=\"Gyre Clockwise\",\n            description=\"Rotating flow pattern, clockwise\",\n            cycle_duration_sec=60,\n            is_built_in=True,\n            flow_curves=flow_curves\n        )\n    \n    def _create_gyre_ccw_preset(self) -> WavemakerPreset:\n        flow_curves = {}\n        phase_offsets = [0, 300, 240, 180, 120, 60]\n        \n        for i, offset in enumerate(phase_offsets, 1):\n            points = []\n            for t in range(0, 361, 30):\n                phase = (t + offset) % 360\n                power = int(50 + 30 * math.sin(math.radians(phase)))\n                points.append({\"time\": t / 6, \"power\": power})\n            flow_curves[f\"wavemaker_{i}\"] = points\n        \n        return WavemakerPreset(\n            name=\"Gyre Counter-Clockwise\",\n            description=\"Rotating flow pattern, counter-clockwise\",\n            cycle_duration_sec=60,\n            is_built_in=True,\n            flow_curves=flow_curves\n        )\n    \n    def _create_feed_mode_preset(self) -> WavemakerPreset:\n        flow_curves = {}\n        for i in range(1, 7):\n            flow_curves[f\"wavemaker_{i}\"] = [\n                {\"time\": 0, \"power\": 5},\n                {\"time\": 600, \"power\": 5}\n            ]\n        \n        return WavemakerPreset(\n            name=\"Feed Mode\",\n            description=\"Minimal flow for feeding time\",\n            cycle_duration_sec=600,\n            is_built_in=True,\n            flow_curves=flow_curves\n        )\n    \n    def _create_random_reef_preset(self) -> WavemakerPreset:\n        import random\n        random.seed(42)\n        \n        flow_curves = {}\n        for i in range(1, 7):\n            points = [{\"time\": 0, \"power\": random.randint(40, 70)}]\n            for t in range(5, 65, 5):\n                points.append({\"time\": t, \"power\": random.randint(30, 80)})\n            flow_curves[f\"wavemaker_{i}\"] = points\n        \n        return WavemakerPreset(\n            name=\"Random Reef\",\n            description=\"Chaotic natural reef flow\",\n            cycle_duration_sec=60,\n            is_built_in=True,\n            flow_curves=flow_curves\n        )\n    \n    def set_active_preset(self, preset_id: int) -> bool:\n        preset = self.store.get_preset(preset_id)\n        if not preset:\n            return False\n        \n        self.active_preset_id = preset_id\n        self.cycle_start_time = time.time()\n        return True\n    \n    def get_active_preset(self) -> Optional[WavemakerPreset]:\n        if self.active_preset_id is None:\n            return None\n        return self.store.get_preset(self.active_preset_id)\n    \n    def get_current_power_levels(self) -> Dict[int, float]:\n        if self.active_preset_id is None:\n            return {i: 0.0 for i in range(1, 7)}\n        \n        preset = self.store.get_preset(self.active_preset_id)\n        if not preset:\n            return {i: 0.0 for i in range(1, 7)}\n        \n        elapsed = time.time() - self.cycle_start_time\n        position_in_cycle = elapsed % preset.cycle_duration_sec\n        \n        power_levels = {}\n        for i in range(1, 7):\n            wm_key = f\"wavemaker_{i}\"\n            if wm_key in preset.flow_curves:\n                power_levels[i] = self._interpolate_power(\n                    preset.flow_curves[wm_key],\n                    position_in_cycle\n                )\n            else:\n                power_levels[i] = 0.0\n        \n        return power_levels\n    \n    def _interpolate_power(self, curve: List[Dict], time_pos: float) -> float:\n        if not curve:\n            return 0.0\n        \n        curve_sorted = sorted(curve, key=lambda x: x[\"time\"])\n        \n        if time_pos <= curve_sorted[0][\"time\"]:\n            return float(curve_sorted[0][\"power\"])\n        \n        if time_pos >= curve_sorted[-1][\"time\"]:\n            return float(curve_sorted[-1][\"power\"])\n        \n        for i in range(len(curve_sorted) - 1):\n            p1 = curve_sorted[i]\n            p2 = curve_sorted[i + 1]\n            \n            if p1[\"time\"] <= time_pos <= p2[\"time\"]:\n                t_range = p2[\"time\"] - p1[\"time\"]\n                if t_range == 0:\n                    return float(p1[\"power\"])\n                \n                t_ratio = (time_pos - p1[\"time\"]) / t_range\n                power = p1[\"power\"] + t_ratio * (p2[\"power\"] - p1[\"power\"])\n                return float(power)\n        \n        return float(curve_sorted[-1][\"power\"])\n","size_bytes":6915},"app/services/hw_devices.py":{"content":"\"\"\"Device registry for managing hardware PWM devices (wavemakers, LEDs).\"\"\"\n\nimport logging\nfrom typing import Dict, Optional\nfrom dataclasses import dataclass\n\ntry:\n    import pigpio\n    # If pigpio module exists, try to use it\n    from app.hw.pigpio_driver import PigpioPWM\n    GPIO_MODE = \"HARDWARE\"\nexcept (ImportError, RuntimeError):\n    # Pigpio not available, use mock\n    from app.hw.gpio_mock import PigpioPWM\n    GPIO_MODE = \"MOCK\"\n\nlogging.info(f\"GPIO Mode: {GPIO_MODE}\")\n\n\n@dataclass\nclass DeviceConfig:\n    \"\"\"Configuration for a PWM device.\"\"\"\n    name: str\n    gpio_pin: int\n    pwm_freq_hz: int\n    min_intensity: float = 0.0\n    max_intensity: float = 1.0\n    volts_min: float = 0.0\n    volts_max: float = 5.0\n\n\nclass PWMDevice:\n    \"\"\"Represents a single PWM-controlled device (wavemaker or LED).\"\"\"\n    \n    def __init__(self, config: DeviceConfig):\n        \"\"\"\n        Initialize PWM device.\n        \n        Args:\n            config: Device configuration\n        \"\"\"\n        self.config = config\n        self.hw = PigpioPWM(config.gpio_pin, config.pwm_freq_hz)\n        self.current_duty = 0.0\n        \n        logging.info(\n            f\"Initialized {config.name} on GPIO{config.gpio_pin} \"\n            f\"({config.pwm_freq_hz}Hz, range {config.min_intensity:.2f}-{config.max_intensity:.2f})\"\n        )\n    \n    def apply(self, intensity: float) -> None:\n        \"\"\"\n        Apply intensity value to device.\n        \n        Args:\n            intensity: Target intensity [0.0-1.0]\n        \"\"\"\n        # Clamp to [0, 1]\n        intensity = max(0.0, min(1.0, intensity))\n        \n        # Map to [min_intensity, max_intensity] range\n        scaled = self.config.min_intensity + intensity * (\n            self.config.max_intensity - self.config.min_intensity\n        )\n        \n        self.hw.set_duty(scaled)\n        self.current_duty = scaled\n    \n    def set_frequency(self, freq_hz: int) -> None:\n        \"\"\"Update PWM frequency.\"\"\"\n        self.config.pwm_freq_hz = freq_hz\n        self.hw.set_frequency(freq_hz)\n    \n    def set_range(self, min_intensity: float, max_intensity: float) -> None:\n        \"\"\"Update intensity range.\"\"\"\n        self.config.min_intensity = min_intensity\n        self.config.max_intensity = max_intensity\n    \n    def stop(self) -> None:\n        \"\"\"Stop device output.\"\"\"\n        self.hw.stop()\n        self.current_duty = 0.0\n    \n    def get_voltage(self) -> float:\n        \"\"\"Calculate approximate output voltage based on current duty.\"\"\"\n        return self.config.volts_min + self.current_duty * (\n            self.config.volts_max - self.config.volts_min\n        )\n    \n    def to_dict(self) -> dict:\n        \"\"\"Export device state as dictionary.\"\"\"\n        return {\n            \"name\": self.config.name,\n            \"gpio_pin\": self.config.gpio_pin,\n            \"pwm_freq_hz\": self.config.pwm_freq_hz,\n            \"min_intensity\": self.config.min_intensity,\n            \"max_intensity\": self.config.max_intensity,\n            \"volts_min\": self.config.volts_min,\n            \"volts_max\": self.config.volts_max,\n            \"current_duty\": self.current_duty,\n            \"current_voltage\": self.get_voltage(),\n        }\n\n\nclass DeviceRegistry:\n    \"\"\"Central registry for all PWM devices.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize empty registry.\"\"\"\n        self.wavemakers: Dict[str, PWMDevice] = {}\n        self.leds: Dict[str, PWMDevice] = {}\n        self.mode = GPIO_MODE\n    \n    def register_wavemaker(self, device_id: str, config: DeviceConfig) -> PWMDevice:\n        \"\"\"\n        Register a wavemaker device.\n        \n        Args:\n            device_id: Unique identifier (e.g., \"WM1\")\n            config: Device configuration\n            \n        Returns:\n            Created PWMDevice instance\n        \"\"\"\n        device = PWMDevice(config)\n        self.wavemakers[device_id] = device\n        logging.info(f\"Registered wavemaker {device_id}\")\n        return device\n    \n    def register_led(self, device_id: str, config: DeviceConfig) -> PWMDevice:\n        \"\"\"\n        Register an LED device.\n        \n        Args:\n            device_id: Unique identifier (e.g., \"LED1\")\n            config: Device configuration\n            \n        Returns:\n            Created PWMDevice instance\n        \"\"\"\n        device = PWMDevice(config)\n        self.leds[device_id] = device\n        logging.info(f\"Registered LED {device_id}\")\n        return device\n    \n    def get_wavemaker(self, device_id: str) -> Optional[PWMDevice]:\n        \"\"\"Get wavemaker device by ID.\"\"\"\n        return self.wavemakers.get(device_id)\n    \n    def get_led(self, device_id: str) -> Optional[PWMDevice]:\n        \"\"\"Get LED device by ID.\"\"\"\n        return self.leds.get(device_id)\n    \n    def stop_all(self) -> None:\n        \"\"\"Emergency stop - zero all outputs.\"\"\"\n        logging.warning(\"EMERGENCY STOP - Zeroing all device outputs\")\n        for device in list(self.wavemakers.values()) + list(self.leds.values()):\n            device.stop()\n    \n    def get_all_states(self) -> dict:\n        \"\"\"Get current state of all devices.\"\"\"\n        return {\n            \"mode\": self.mode,\n            \"wavemakers\": {\n                device_id: device.to_dict()\n                for device_id, device in self.wavemakers.items()\n            },\n            \"leds\": {\n                device_id: device.to_dict()\n                for device_id, device in self.leds.items()\n            },\n        }\n\n\n# Global registry instance\nregistry = DeviceRegistry()\n","size_bytes":5485},"app/routers/hardware.py":{"content":"\"\"\"API endpoints for hardware device control.\"\"\"\n\nimport logging\nfrom fastapi import APIRouter, HTTPException, Request\nfrom pydantic import BaseModel, Field\nfrom typing import Literal, Optional\n\nfrom app.services.hw_devices import registry as device_registry, DeviceConfig\nfrom app.services.hw_patterns import pattern_registry, PatternConfig, PatternMode\nfrom app.hw_scheduler.realtime_loop import (\n    set_manual_mode,\n    set_led_follow,\n    get_control_state,\n    manual_devices,\n)\n\n\nrouter = APIRouter()\n\n\n# Request models\nclass DeviceSettingsUpdate(BaseModel):\n    \"\"\"Update device hardware settings.\"\"\"\n    gpio_pin: Optional[int] = Field(None, ge=0, le=27, description=\"BCM GPIO pin number\")\n    pwm_freq_hz: Optional[int] = Field(None, ge=50, le=10000, description=\"PWM frequency in Hz\")\n    min_intensity: Optional[float] = Field(None, ge=0.0, le=1.0)\n    max_intensity: Optional[float] = Field(None, ge=0.0, le=1.0)\n    volts_min: Optional[float] = Field(None, ge=0.0, le=10.0)\n    volts_max: Optional[float] = Field(None, ge=0.0, le=10.0)\n\n\nclass PatternUpdate(BaseModel):\n    \"\"\"Update device pattern.\"\"\"\n    mode: PatternMode\n    period_s: Optional[float] = Field(5.0, ge=0.1, le=60.0)\n    on_ratio: Optional[float] = Field(0.5, ge=0.0, le=1.0)\n    phase_deg: Optional[float] = Field(0.0, ge=0.0, le=360.0)\n    min_intensity: Optional[float] = Field(0.0, ge=0.0, le=1.0)\n    max_intensity: Optional[float] = Field(1.0, ge=0.0, le=1.0)\n\n\nclass ManualControl(BaseModel):\n    \"\"\"Manual control request.\"\"\"\n    duty: float = Field(..., ge=0.0, le=1.0, description=\"Manual duty cycle\")\n\n\nclass ModeSwitch(BaseModel):\n    \"\"\"Mode switch request.\"\"\"\n    manual: bool = Field(..., description=\"True for manual mode, False for automatic\")\n\n\nclass LEDFollowConfig(BaseModel):\n    \"\"\"LED follow configuration.\"\"\"\n    wavemaker_id: Optional[str] = Field(None, description=\"Wavemaker ID to follow, null to disable\")\n\n\n# Endpoints\n\n@router.get(\"/hardware/status\")\nasync def get_hardware_status():\n    \"\"\"Get overall hardware and control status.\"\"\"\n    return {\n        \"devices\": device_registry.get_all_states(),\n        \"control\": get_control_state(),\n    }\n\n\n@router.post(\"/hardware/emergency_stop\")\nasync def emergency_stop():\n    \"\"\"Emergency stop - zero all device outputs.\"\"\"\n    device_registry.stop_all()\n    return {\"status\": \"all devices stopped\"}\n\n\n@router.get(\"/hardware/wavemakers/{device_id}\")\nasync def get_wavemaker_status(device_id: str):\n    \"\"\"Get status of specific wavemaker.\"\"\"\n    device = device_registry.get_wavemaker(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"Wavemaker {device_id} not found\")\n    \n    pattern = pattern_registry.get_pattern(device_id)\n    is_manual = device_id in manual_devices\n    \n    return {\n        \"device\": device.to_dict(),\n        \"pattern\": {\n            \"mode\": pattern.config.mode if pattern else \"OFF\",\n            \"config\": vars(pattern.config) if pattern else None,\n        } if pattern else None,\n        \"manual_mode\": is_manual,\n    }\n\n\n@router.post(\"/hardware/wavemakers/{device_id}/settings\")\nasync def update_wavemaker_settings(device_id: str, settings: DeviceSettingsUpdate):\n    \"\"\"Update wavemaker hardware settings (GPIO pin, PWM freq, voltage range).\"\"\"\n    device = device_registry.get_wavemaker(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"Wavemaker {device_id} not found\")\n    \n    # Apply updates\n    if settings.pwm_freq_hz is not None:\n        device.set_frequency(settings.pwm_freq_hz)\n    \n    if settings.min_intensity is not None and settings.max_intensity is not None:\n        if settings.min_intensity >= settings.max_intensity:\n            raise HTTPException(status_code=400, detail=\"min_intensity must be < max_intensity\")\n        device.set_range(settings.min_intensity, settings.max_intensity)\n    \n    if settings.volts_min is not None:\n        device.config.volts_min = settings.volts_min\n    \n    if settings.volts_max is not None:\n        device.config.volts_max = settings.volts_max\n    \n    # Note: GPIO pin change requires device restart (not supported dynamically)\n    if settings.gpio_pin is not None:\n        logging.warning(f\"GPIO pin change requested for {device_id} but requires restart\")\n        return {\n            \"status\": \"partial_update\",\n            \"message\": \"GPIO pin change requires device restart\",\n            \"device\": device.to_dict()\n        }\n    \n    return {\"status\": \"updated\", \"device\": device.to_dict()}\n\n\n@router.post(\"/hardware/wavemakers/{device_id}/pattern\")\nasync def update_wavemaker_pattern(device_id: str, pattern_update: PatternUpdate):\n    \"\"\"Update wavemaker pattern configuration.\"\"\"\n    device = device_registry.get_wavemaker(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"Wavemaker {device_id} not found\")\n    \n    # Create pattern config\n    pattern_config = PatternConfig(\n        mode=pattern_update.mode,\n        period_s=pattern_update.period_s if pattern_update.period_s is not None else 5.0,\n        on_ratio=pattern_update.on_ratio if pattern_update.on_ratio is not None else 0.5,\n        phase_deg=pattern_update.phase_deg if pattern_update.phase_deg is not None else 0.0,\n        min_intensity=pattern_update.min_intensity if pattern_update.min_intensity is not None else 0.0,\n        max_intensity=pattern_update.max_intensity if pattern_update.max_intensity is not None else 1.0,\n    )\n    \n    # Update pattern\n    pattern_registry.create_pattern(device_id, pattern_config)\n    \n    return {\n        \"status\": \"pattern_updated\",\n        \"device_id\": device_id,\n        \"pattern\": vars(pattern_config),\n    }\n\n\n@router.post(\"/hardware/wavemakers/{device_id}/mode\")\nasync def set_wavemaker_mode(device_id: str, mode: ModeSwitch):\n    \"\"\"Switch between manual and automatic (pattern) mode.\"\"\"\n    device = device_registry.get_wavemaker(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"Wavemaker {device_id} not found\")\n    \n    set_manual_mode(device_id, mode.manual)\n    \n    return {\n        \"status\": \"mode_updated\",\n        \"device_id\": device_id,\n        \"manual_mode\": mode.manual,\n    }\n\n\n@router.post(\"/hardware/wavemakers/{device_id}/manual\")\nasync def set_wavemaker_manual_duty(device_id: str, control: ManualControl):\n    \"\"\"Set manual duty cycle (only works in manual mode).\"\"\"\n    device = device_registry.get_wavemaker(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"Wavemaker {device_id} not found\")\n    \n    if device_id not in manual_devices:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Device {device_id} not in manual mode. Switch to manual mode first.\"\n        )\n    \n    device.apply(control.duty)\n    \n    return {\n        \"status\": \"duty_set\",\n        \"device_id\": device_id,\n        \"duty\": control.duty,\n        \"voltage\": device.get_voltage(),\n    }\n\n\n# LED endpoints\n\n@router.get(\"/hardware/leds/{device_id}\")\nasync def get_led_status(device_id: str):\n    \"\"\"Get status of specific LED.\"\"\"\n    device = device_registry.get_led(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"LED {device_id} not found\")\n    \n    is_manual = device_id in manual_devices\n    \n    from app.hw_scheduler.realtime_loop import led_follow_map\n    following = led_follow_map.get(device_id)\n    \n    return {\n        \"device\": device.to_dict(),\n        \"manual_mode\": is_manual,\n        \"following\": following,\n    }\n\n\n@router.post(\"/hardware/leds/{device_id}/follow\")\nasync def set_led_follow_mode(device_id: str, config: LEDFollowConfig):\n    \"\"\"Configure LED to follow a wavemaker's pattern.\"\"\"\n    device = device_registry.get_led(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"LED {device_id} not found\")\n    \n    # Verify wavemaker exists if specified\n    if config.wavemaker_id:\n        wm_device = device_registry.get_wavemaker(config.wavemaker_id)\n        if not wm_device:\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Wavemaker {config.wavemaker_id} not found\"\n            )\n    \n    set_led_follow(device_id, config.wavemaker_id)\n    \n    # If following, take LED out of manual mode\n    if config.wavemaker_id:\n        set_manual_mode(device_id, False)\n    \n    return {\n        \"status\": \"follow_configured\",\n        \"led_id\": device_id,\n        \"following\": config.wavemaker_id,\n    }\n\n\n@router.post(\"/hardware/leds/{device_id}/mode\")\nasync def set_led_mode(device_id: str, mode: ModeSwitch):\n    \"\"\"Switch LED between manual and automatic mode.\"\"\"\n    device = device_registry.get_led(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"LED {device_id} not found\")\n    \n    set_manual_mode(device_id, mode.manual)\n    \n    return {\n        \"status\": \"mode_updated\",\n        \"device_id\": device_id,\n        \"manual_mode\": mode.manual,\n    }\n\n\n@router.post(\"/hardware/leds/{device_id}/manual\")\nasync def set_led_manual_duty(device_id: str, control: ManualControl):\n    \"\"\"Set manual LED brightness (only works in manual mode).\"\"\"\n    device = device_registry.get_led(device_id)\n    if not device:\n        raise HTTPException(status_code=404, detail=f\"LED {device_id} not found\")\n    \n    if device_id not in manual_devices:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"LED {device_id} not in manual mode. Switch to manual mode first.\"\n        )\n    \n    device.apply(control.duty)\n    \n    return {\n        \"status\": \"duty_set\",\n        \"device_id\": device_id,\n        \"duty\": control.duty,\n        \"voltage\": device.get_voltage(),\n    }\n","size_bytes":9708},"app/hw/__init__.py":{"content":"\"\"\"Hardware abstraction layer for GPIO/PWM control.\"\"\"\n","size_bytes":55},"app/hw_scheduler/__init__.py":{"content":"\"\"\"Hardware control scheduler.\"\"\"\n","size_bytes":34},"app/hw_scheduler/realtime_loop.py":{"content":"\"\"\"Real-time control loop for GPIO/PWM devices.\"\"\"\n\nimport logging\nimport time\nfrom typing import Dict, Set, Optional\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\n\nfrom app.services.hw_devices import registry as device_registry\nfrom app.services.hw_patterns import pattern_registry\n\n\n# LED follow mappings (LED_ID -> WAVEMAKER_ID)\nled_follow_map: Dict[str, str] = {}\n\n# Devices in manual mode (don't apply patterns)\nmanual_devices: Set[str] = set()\n\n# Reference to PresetManager (set during startup)\npreset_manager_ref: Optional[object] = None\n\n\nasync def realtime_tick():\n    \"\"\"\n    Real-time control loop - runs at 10-20Hz.\n    \n    Evaluates patterns and applies to hardware devices.\n    Priority: Preset power levels > Pattern values\n    \"\"\"\n    try:\n        current_time = time.time()\n        \n        # Check if we have an active preset - if so, use preset power levels\n        preset_power_levels = {}\n        if preset_manager_ref is not None:\n            try:\n                preset_power_levels = preset_manager_ref.get_current_power_levels()\n            except Exception as e:\n                logging.debug(f\"Could not get preset power levels: {e}\")\n        \n        # Get all pattern values at current time (fallback)\n        pattern_values = pattern_registry.get_all_values(current_time)\n        \n        # Apply to wavemakers (preset takes priority over patterns)\n        for wm_num in range(1, 7):  # Wavemakers 1-6\n            wm_id = f\"WM{wm_num}\"\n            \n            if wm_id in manual_devices:\n                continue\n            \n            # Check for preset power level first (convert 0-100 to 0.0-1.0)\n            if wm_num in preset_power_levels:\n                intensity = preset_power_levels[wm_num] / 100.0\n            elif wm_id in pattern_values:\n                intensity = pattern_values[wm_id]\n            else:\n                continue  # No value available\n            \n            device = device_registry.get_wavemaker(wm_id)\n            if device:\n                device.apply(intensity)\n        \n        # Apply LED follow mappings\n        for led_id, wavemaker_id in led_follow_map.items():\n            if led_id in manual_devices:\n                continue\n            \n            # Get the intensity value that was applied to the wavemaker\n            # Extract wavemaker number from WM1 format\n            try:\n                wm_num = int(wavemaker_id.replace(\"WM\", \"\"))\n                if wm_num in preset_power_levels:\n                    intensity = preset_power_levels[wm_num] / 100.0\n                elif wavemaker_id in pattern_values:\n                    intensity = pattern_values[wavemaker_id]\n                else:\n                    continue\n                \n                led_device = device_registry.get_led(led_id)\n                if led_device:\n                    led_device.apply(intensity)\n            except (ValueError, AttributeError):\n                logging.debug(f\"Could not extract wavemaker number from {wavemaker_id}\")\n    \n    except Exception as e:\n        logging.error(f\"Error in realtime tick: {e}\", exc_info=True)\n\n\n# APScheduler instance\nhw_scheduler = AsyncIOScheduler()\n\n\ndef start_hw_scheduler():\n    \"\"\"Start the hardware control scheduler.\"\"\"\n    if hw_scheduler.running:\n        logging.warning(\"Hardware scheduler already running\")\n        return\n    \n    # Add real-time control job at 20Hz (50ms interval)\n    hw_scheduler.add_job(\n        realtime_tick,\n        \"interval\",\n        seconds=0.05,  # 20Hz\n        id=\"realtime_control\",\n        replace_existing=True\n    )\n    \n    hw_scheduler.start()\n    logging.info(\"Hardware scheduler started at 20Hz\")\n\n\ndef stop_hw_scheduler():\n    \"\"\"Stop the hardware scheduler.\"\"\"\n    if hw_scheduler.running:\n        hw_scheduler.shutdown()\n        logging.info(\"Hardware scheduler stopped\")\n\n\ndef set_manual_mode(device_id: str, manual: bool):\n    \"\"\"\n    Set device to manual or automatic (pattern) mode.\n    \n    Args:\n        device_id: Device identifier\n        manual: True for manual mode, False for automatic\n    \"\"\"\n    if manual:\n        manual_devices.add(device_id)\n        logging.info(f\"{device_id} set to MANUAL mode\")\n    else:\n        manual_devices.discard(device_id)\n        logging.info(f\"{device_id} set to AUTOMATIC mode\")\n\n\ndef set_led_follow(led_id: str, wavemaker_id: str | None):\n    \"\"\"\n    Configure LED to follow a wavemaker's pattern.\n    \n    Args:\n        led_id: LED device identifier\n        wavemaker_id: Wavemaker to follow, or None to disable following\n    \"\"\"\n    if wavemaker_id is None:\n        if led_id in led_follow_map:\n            del led_follow_map[led_id]\n        logging.info(f\"{led_id} no longer following wavemaker\")\n    else:\n        led_follow_map[led_id] = wavemaker_id\n        logging.info(f\"{led_id} now follows {wavemaker_id}\")\n\n\ndef set_preset_manager(preset_manager):\n    \"\"\"\n    Link PresetManager to hardware control loop.\n    \n    Args:\n        preset_manager: PresetManager instance\n    \"\"\"\n    global preset_manager_ref\n    preset_manager_ref = preset_manager\n    logging.info(\"PresetManager linked to hardware control loop\")\n\n\ndef get_control_state() -> dict:\n    \"\"\"Get current state of control system.\"\"\"\n    return {\n        \"scheduler_running\": hw_scheduler.running,\n        \"manual_devices\": list(manual_devices),\n        \"led_follow_map\": dict(led_follow_map),\n        \"gpio_mode\": device_registry.mode,\n        \"preset_linked\": preset_manager_ref is not None,\n    }\n","size_bytes":5493},"app/hw/gpio_iface.py":{"content":"\"\"\"GPIO/PWM interface protocol definitions.\"\"\"\n\nfrom typing import Protocol\n\n\nclass PWMChannel(Protocol):\n    \"\"\"Protocol for PWM channel control.\"\"\"\n    \n    def start(self, duty: float) -> None:\n        \"\"\"Start PWM with given duty cycle (0.0-1.0).\"\"\"\n        ...\n    \n    def set_frequency(self, hz: int) -> None:\n        \"\"\"Set PWM frequency in Hz.\"\"\"\n        ...\n    \n    def set_duty(self, duty: float) -> None:\n        \"\"\"Set duty cycle (0.0-1.0).\"\"\"\n        ...\n    \n    def stop(self) -> None:\n        \"\"\"Stop PWM output (set to 0).\"\"\"\n        ...\n","size_bytes":557},"app/hw/gpio_mock.py":{"content":"\"\"\"Mock GPIO driver for development/testing without hardware.\"\"\"\n\nimport logging\nfrom typing import Dict\n\n\nclass PigpioPWM:\n    \"\"\"Mock PWM channel for development without Raspberry Pi.\"\"\"\n    \n    _instances: Dict[int, 'PigpioPWM'] = {}\n    \n    def __init__(self, pin: int, freq: int = 500):\n        \"\"\"\n        Initialize mock PWM on a virtual pin.\n        \n        Args:\n            pin: Virtual GPIO pin number\n            freq: PWM frequency in Hz\n        \"\"\"\n        self.pin = pin\n        self.freq = freq\n        self.duty = 0.0\n        self.running = False\n        \n        PigpioPWM._instances[pin] = self\n        logging.info(f\"[MOCK] Initialized virtual PWM on GPIO{pin} at {freq}Hz\")\n    \n    def set_frequency(self, hz: int) -> None:\n        \"\"\"Set PWM frequency in Hz.\"\"\"\n        old_freq = self.freq\n        self.freq = hz\n        logging.debug(f\"[MOCK] GPIO{self.pin} frequency changed: {old_freq}Hz â†’ {hz}Hz\")\n    \n    def set_duty(self, duty: float) -> None:\n        \"\"\"Set duty cycle (0.0-1.0).\"\"\"\n        duty = max(0.0, min(1.0, duty))\n        if abs(self.duty - duty) > 0.01:  # Log significant changes only\n            logging.debug(f\"[MOCK] GPIO{self.pin} duty: {self.duty:.2%} â†’ {duty:.2%}\")\n        self.duty = duty\n        self.running = (duty > 0)\n    \n    def start(self, duty: float = 0.0) -> None:\n        \"\"\"Start PWM with given duty cycle.\"\"\"\n        self.running = True\n        self.set_duty(duty)\n        logging.info(f\"[MOCK] Started PWM on GPIO{self.pin} at {duty:.2%}\")\n    \n    def stop(self) -> None:\n        \"\"\"Stop PWM output.\"\"\"\n        self.running = False\n        self.duty = 0.0\n        logging.info(f\"[MOCK] Stopped PWM on GPIO{self.pin}\")\n    \n    def cleanup(self) -> None:\n        \"\"\"Cleanup resources.\"\"\"\n        self.stop()\n        if self.pin in PigpioPWM._instances:\n            del PigpioPWM._instances[self.pin]\n    \n    @classmethod\n    def get_all_states(cls) -> Dict[int, dict]:\n        \"\"\"Get current state of all mock PWM channels (for debugging).\"\"\"\n        return {\n            pin: {\n                \"duty\": inst.duty,\n                \"freq\": inst.freq,\n                \"running\": inst.running\n            }\n            for pin, inst in cls._instances.items()\n        }\n","size_bytes":2240},"app/hw/pigpio_driver.py":{"content":"\"\"\"Real Raspberry Pi GPIO driver using pigpio library.\"\"\"\n\nimport logging\n\ntry:\n    import pigpio\n    PIGPIO_AVAILABLE = True\nexcept ImportError:\n    PIGPIO_AVAILABLE = False\n    logging.warning(\"pigpio not available - using mock GPIO\")\n\n\nclass PigpioPWM:\n    \"\"\"PWM control using pigpio library for Raspberry Pi.\"\"\"\n    \n    def __init__(self, pin: int, freq: int = 500):\n        \"\"\"\n        Initialize PWM on a GPIO pin.\n        \n        Args:\n            pin: BCM GPIO pin number\n            freq: PWM frequency in Hz\n        \"\"\"\n        if not PIGPIO_AVAILABLE:\n            raise ImportError(\"pigpio library not available\")\n            \n        self.pin = pin\n        self.freq = freq\n        self.pi = pigpio.pi()\n        \n        if not self.pi.connected:\n            raise RuntimeError(f\"Failed to connect to pigpiod daemon\")\n        \n        self.pi.set_mode(pin, pigpio.OUTPUT)\n        self.set_frequency(freq)\n        self.set_duty(0.0)\n        \n        logging.info(f\"Initialized pigpio PWM on GPIO{pin} at {freq}Hz\")\n    \n    def set_frequency(self, hz: int) -> None:\n        \"\"\"Set PWM frequency in Hz.\"\"\"\n        self.freq = hz\n        self.pi.set_PWM_frequency(self.pin, hz)\n    \n    def set_duty(self, duty: float) -> None:\n        \"\"\"\n        Set duty cycle.\n        \n        Args:\n            duty: Duty cycle from 0.0 (0%) to 1.0 (100%)\n        \"\"\"\n        duty = max(0.0, min(1.0, duty))\n        # pigpio uses 0-255 range for duty cycle\n        self.pi.set_PWM_dutycycle(self.pin, int(duty * 255))\n    \n    def start(self, duty: float = 0.0) -> None:\n        \"\"\"Start PWM with given duty cycle.\"\"\"\n        self.set_duty(duty)\n    \n    def stop(self) -> None:\n        \"\"\"Stop PWM output.\"\"\"\n        self.pi.set_PWM_dutycycle(self.pin, 0)\n    \n    def cleanup(self) -> None:\n        \"\"\"Cleanup GPIO resources.\"\"\"\n        self.stop()\n        self.pi.stop()\n","size_bytes":1874},"app/services/hw_patterns.py":{"content":"\"\"\"Real-time pattern engine for wavemaker control.\"\"\"\n\nimport math\nimport time\nimport logging\nfrom typing import Dict, Optional, Literal\nfrom dataclasses import dataclass\n\n\nPatternMode = Literal[\"OFF\", \"CONSTANT\", \"PULSE\", \"GYRE\", \"RANDOM\"]\n\n\n@dataclass\nclass PatternConfig:\n    \"\"\"Configuration for a pattern.\"\"\"\n    mode: PatternMode = \"CONSTANT\"\n    period_s: float = 5.0\n    on_ratio: float = 0.5\n    phase_deg: float = 0.0\n    min_intensity: float = 0.0\n    max_intensity: float = 1.0\n\n\nclass Pattern:\n    \"\"\"Real-time pattern generator for wavemaker control.\"\"\"\n    \n    def __init__(self, config: PatternConfig):\n        \"\"\"\n        Initialize pattern generator.\n        \n        Args:\n            config: Pattern configuration\n        \"\"\"\n        self.config = config\n        self.phase_rad = math.radians(config.phase_deg)\n        self.start_time = time.time()\n        self._last_random = 0.5\n        self._random_target = 0.5\n        self._random_update_time = 0.0\n        \n    def value(self, t: Optional[float] = None) -> float:\n        \"\"\"\n        Calculate pattern value at given time.\n        \n        Args:\n            t: Timestamp (seconds since epoch). If None, uses current time.\n            \n        Returns:\n            Intensity value [0.0-1.0]\n        \"\"\"\n        if t is None:\n            t = time.time()\n        \n        # Time relative to start\n        rel_t = t - self.start_time\n        \n        # Calculate base pattern value [0, 1]\n        if self.config.mode == \"OFF\":\n            raw = 0.0\n        elif self.config.mode == \"CONSTANT\":\n            raw = 1.0\n        elif self.config.mode == \"PULSE\":\n            raw = self._pulse_pattern(rel_t)\n        elif self.config.mode == \"GYRE\":\n            raw = self._gyre_pattern(rel_t)\n        elif self.config.mode == \"RANDOM\":\n            raw = self._random_pattern(rel_t)\n        else:\n            raw = 0.0\n        \n        # Scale to [min_intensity, max_intensity]\n        return self.config.min_intensity + raw * (\n            self.config.max_intensity - self.config.min_intensity\n        )\n    \n    def _pulse_pattern(self, t: float) -> float:\n        \"\"\"Generate pulse pattern.\"\"\"\n        if self.config.period_s <= 0:\n            return 1.0\n        \n        phase = (t % self.config.period_s) / self.config.period_s\n        return 1.0 if phase < self.config.on_ratio else 0.0\n    \n    def _gyre_pattern(self, t: float) -> float:\n        \"\"\"Generate sinusoidal gyre pattern.\"\"\"\n        if self.config.period_s <= 0:\n            return 0.5\n        \n        phase = (t % self.config.period_s) / self.config.period_s\n        return 0.5 * (1.0 + math.sin(2 * math.pi * phase + self.phase_rad))\n    \n    def _random_pattern(self, t: float) -> float:\n        \"\"\"Generate smooth random pattern with transitions.\"\"\"\n        # Update target every ~10 seconds\n        if t - self._random_update_time > 10.0:\n            self._random_target = 0.3 + 0.7 * (hash(int(t / 10)) % 1000) / 1000\n            self._random_update_time = t\n        \n        # Smooth transition to target\n        alpha = min(1.0, (t - self._random_update_time) / 5.0)\n        self._last_random = self._last_random * (1 - alpha) + self._random_target * alpha\n        return self._last_random\n    \n    def update_config(self, config: PatternConfig) -> None:\n        \"\"\"Update pattern configuration.\"\"\"\n        self.config = config\n        self.phase_rad = math.radians(config.phase_deg)\n    \n    def reset(self) -> None:\n        \"\"\"Reset pattern to start.\"\"\"\n        self.start_time = time.time()\n        self._last_random = 0.5\n        self._random_target = 0.5\n        self._random_update_time = 0.0\n\n\nclass PatternRegistry:\n    \"\"\"Registry for managing patterns across devices.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize empty pattern registry.\"\"\"\n        self.patterns: Dict[str, Pattern] = {}\n    \n    def create_pattern(self, device_id: str, config: PatternConfig) -> Pattern:\n        \"\"\"\n        Create or update pattern for a device.\n        \n        Args:\n            device_id: Device identifier\n            config: Pattern configuration\n            \n        Returns:\n            Pattern instance\n        \"\"\"\n        if device_id in self.patterns:\n            self.patterns[device_id].update_config(config)\n        else:\n            self.patterns[device_id] = Pattern(config)\n        \n        logging.info(f\"Updated pattern for {device_id}: {config.mode}\")\n        return self.patterns[device_id]\n    \n    def get_pattern(self, device_id: str) -> Optional[Pattern]:\n        \"\"\"Get pattern for device.\"\"\"\n        return self.patterns.get(device_id)\n    \n    def remove_pattern(self, device_id: str) -> None:\n        \"\"\"Remove pattern for device.\"\"\"\n        if device_id in self.patterns:\n            del self.patterns[device_id]\n    \n    def get_all_values(self, t: Optional[float] = None) -> Dict[str, float]:\n        \"\"\"Get current values for all patterns.\"\"\"\n        return {\n            device_id: pattern.value(t)\n            for device_id, pattern in self.patterns.items()\n        }\n\n\n# Global pattern registry\npattern_registry = PatternRegistry()\n","size_bytes":5116}},"version":2}